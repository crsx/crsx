/* Generated By:JavaCC: Do not edit this line. DerivParser.java */
package net.sf.crsx.samples.guide;

/** PG Grammar for HOACS module net.sf.crsx.samples.guide.Deriv.
 * @version $Id: DerivParser.jj,v 1.8 2013/09/19 16:08:23 krisrose Exp $
 */
public class DerivParser implements net.sf.crsx.Parser, DerivParserConstants {
        /** Factory. */
        net.sf.crsx.Factory<? extends net.sf.crsx.Term> factory;
        /** Compilation unit name for error messages. */
        String unit;
        /** Whether the parser should capture token locations. */
        boolean captureLocations = true;
        /** Constructor with token location information. */
        private net.sf.crsx.Constructor makeTConstructor(net.sf.crsx.Sink sink, Token t, Object object, String sort)
        {
                net.sf.crsx.Constructor c = sort == null ? sink.makeConstructor(object) : sink.makeLiteral(object, sort);
                if (t == null) t = token;
                if (captureLocations && t != null)
                {
                        if (factory.get("meta") == null)
                                c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn);
                }
                return c;
        }

        /** Free variables encountered during parsing. */
        java.util.Map<String,net.sf.crsx.Variable> freeVariables;
        private net.sf.crsx.Variable freeOrFresh(net.sf.crsx.Maker maker, String name, boolean promiscuous) {if (!freeVariables.containsKey(name)) freeVariables.put(name, maker.makeVariable(name, promiscuous)); return freeVariables.get(name);}

        /** Helper interface with category non-terminal calls. */
        abstract class CategoryCall { abstract net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException; }
        /** Direct category invocations. */
        java.util.Map<String,CategoryCall> categoryCall = new java.util.HashMap<String,CategoryCall>();
        {
                categoryCall.put("deriv", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_B$WithEOF(sink, bound);} });
                categoryCall.put("derivB", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_B$WithEOF(sink, bound);} });
                categoryCall.put("derivExp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Exp$WithEOF(sink, bound);} });
                categoryCall.put("derivFun", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Fun$WithEOF(sink, bound);} });
                categoryCall.put("derivInt", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Int$WithEOF(sink, bound);} });
                categoryCall.put("derivVar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Var$WithEOF(sink, bound);} });
        }

        // Constructor.

        /** Construct dummy instance. */
        public DerivParser()
        {
                this((java.io.Reader) null);
                disable_tracing();
        }

        // Parser implementation.

        public net.sf.crsx.Parser parser(net.sf.crsx.Factory<? extends net.sf.crsx.Term> f)
        {
                if (factory != null)
                {
                        net.sf.crsx.Parser parser = new DerivParser().parser(f);
                        parser.setParserVerbose(trace_enabled); parser.setParserLocation(captureLocations);
                        return parser;
                }
                else
                {
                        factory = f;
                        return this;
                }
        }

        public void setParserVerbose(boolean verbose)
        {
                if (verbose)
                        enable_tracing();
                else
                        disable_tracing();
        }

        public void setParserLocation(boolean capture)
        {
                captureLocations = capture;
        }

        public void setEmbeddedParser(net.sf.crsx.Parser subparser) throws net.sf.crsx.CRSException
        {}

        public Iterable<String> categories()
        {
                return categoryCall.keySet();
        }

        public net.sf.crsx.Sink parse(net.sf.crsx.Sink sink, String category, java.io.Reader reader, String unit, int firstLine, int firstColumn, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound, java.util.Map<String, net.sf.crsx.Variable> free) throws net.sf.crsx.CRSException, java.io.IOException
        {
                try
                {
                        this.unit = unit;
                        ReInit((java.io.Reader) null);
                        jj_input_stream.ReInit(reader, firstLine, firstColumn); token_source = new DerivParserTokenManager(jj_input_stream); // hacks to update line and column numbers
                        if (bound == null) bound = new net.sf.crsx.util.LinkedExtensibleMap<String, net.sf.crsx.Variable>();
                        freeVariables = (free != null ? free : new java.util.HashMap<String, net.sf.crsx.Variable>());
                        if (category == null || category.length() == 0) return N_B(sink, bound);
                        else if (categoryCall.containsKey(category)) return categoryCall.get(category).call(sink, bound);
                        else throw new net.sf.crsx.CRSException("Parser category '"+category+"' not supported!");
                }
                catch (ParseException e)
                {
                        throw new net.sf.crsx.CRSException(e.getMessage());
                }
        }

        public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound, java.util.Map<String, net.sf.crsx.Variable> free) throws net.sf.crsx.CRSException, java.io.IOException
        {
                net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
                parse(buffer.sink(), category, reader, null, 1, 1, bound, free);
                return buffer.term(true);
        }


static String unmeta(String s, int i) {String inner = s.substring(1, s.length()-1).trim(); return (inner.length() > i ? inner.substring(i) : inner).trim();}

        /**
	 * Run the parser and print the resulting term.
	 * @param args should contain two strings: the category and an input file name
	 */
        public static void main(String[] args)
        {
                try
                {
                        if (args.length != 2)
                        {
                                System.err.println("Usage: DerivParser category input");
                                System.exit(2);
                        }
                        String category = args[0];
                        java.io.Reader reader = new java.io.FileReader(args[1]);
                        net.sf.crsx.Factory<net.sf.crsx.generic.GenericTerm> factory = new net.sf.crsx.generic.GenericFactory();
                        net.sf.crsx.Parser parser = new DerivParser();
                        net.sf.crsx.Sink sink = factory.sink(System.out);
                        parser.parser(factory).parse(sink, category, reader, null, 1, 1, null, null);
                }
                catch (net.sf.crsx.CRSException e)
                {
                        System.err.println("CRS error: "+e);
                        System.exit(1);
                }
                catch (java.io.IOException e)
                {
                        System.err.println("I/O error: "+e);
                        System.exit(1);
                }
        }

/* GRAMMAR. */

/* Productions for B with precedence 0. */

/** <em>B$WithEOF</em> ::= <em>B</em> EOF . */
  final public net.sf.crsx.Sink N_B$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_B$WithEOF");
    try {
      sink = N_B(sink, env);
      jj_consume_token(0);
                             {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_B$WithEOF");
    }
  }

/**
 * <em>B</em> ::=  <a href="#N_B1">&lang;B1&rang;</a>  
 */
  final public net.sf.crsx.Sink N_B(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_B");
    try {
        Token t = null;
      sink = N_B1(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_B");
    }
  }

/* Productions for B with precedence 1. */

/**
 * <em>B1</em> ::=  <a href="#N_B2">&lang;B2&rang;</a> <font color="red">:#1</font>   (   "<code>∨</code>"   (  <font color="red">{'B1_B__M__u2228_inline'}</font>   <font color="red">{{#1}}</font>   <a href="#N_B1">&lang;B1&rang;</a>   )  |  <font color="red">{{#1}}</font>  ) 
 */
  final public net.sf.crsx.Sink N_B1(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_B1");
    try {
        Token t = null;
        net.sf.crsx.util.Buffer b__1 = new net.sf.crsx.util.Buffer(sink);
      N_B2(b__1.sink(), env);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 1:
        jj_consume_token(1);
                                sink = sink .start(makeTConstructor(sink, t, "B1_B__M__u2228_inline", null)) ;
                                sink = sink .copy(b__1, true) ;
        sink = N_B1(sink, env);
                                sink = sink .end() ;
        break;
      default:
        jj_la1[0] = jj_gen;
                        sink = sink .copy(b__1, true) ;
      }
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_B1");
    }
  }

/* Productions for B with precedence 2. */

/**
 * <em>B2</em> ::=  <a href="#N_B3">&lang;B3&rang;</a> <font color="red">:#1</font>   (   "<code>∧</code>"   (  <font color="red">{'B2_B__M__u2227_inline'}</font>   <font color="red">{{#1}}</font>   <a href="#N_B2">&lang;B2&rang;</a>   )  |  <font color="red">{{#1}}</font>  ) 
 */
  final public net.sf.crsx.Sink N_B2(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_B2");
    try {
        Token t = null;
        net.sf.crsx.util.Buffer b__1 = new net.sf.crsx.util.Buffer(sink);
      N_B3(b__1.sink(), env);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 2:
        jj_consume_token(2);
                                sink = sink .start(makeTConstructor(sink, t, "B2_B__M__u2227_inline", null)) ;
                                sink = sink .copy(b__1, true) ;
        sink = N_B2(sink, env);
                                sink = sink .end() ;
        break;
      default:
        jj_la1[1] = jj_gen;
                        sink = sink .copy(b__1, true) ;
      }
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_B2");
    }
  }

/* Productions for B with precedence 3. */

/**
 * <em>B3</em> ::=   "<code>¬</code>"   (  <font color="red">{'B3__M__u00ac_inline'}</font>   <a href="#N_B3">&lang;B3&rang;</a>   )  <br>
 *  |  <a href="#N_B4">&lang;B4&rang;</a>  
 */
  final public net.sf.crsx.Sink N_B3(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_B3");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 3:
        jj_consume_token(3);
                        sink = sink .start(makeTConstructor(sink, t, "B3__M__u00ac_inline", null)) ;
        sink = N_B3(sink, env);
                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case 4:
      case 6:
      case 7:
      case T_meta1_T_M_B:
      case T_meta2_T_M_B:
        sink = N_B4(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_B3");
    }
  }

/* Productions for B with (highest) precedence 4. */

/**
 * <em>B4</em> ::=   <a href="#T_meta1_T_M_B">meta1_T_M_B</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_B">meta2_T_M_B</a><font color="red">$$:%{unmeta(#,1)%}</font>  <br>
 *  |   "<code>(</code>"   (  <font color="red">{'B4__M__28_inline'}</font>   <a href="#N_B">&lang;B&rang;</a>     "<code>)</code>"   (  )  )  <br>
 *  |   "<code>f</code>"   (  <font color="red">{'B4__M_f_inline'}</font>  )  <br>
 *  |  <font color="red">{'B4_inline'}</font>    "<code>t</code>"   (  ) 
 */
  final public net.sf.crsx.Sink N_B4(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_B4");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_B:
        t = jj_consume_token(T_meta1_T_M_B);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_B:
        t = jj_consume_token(T_meta2_T_M_B);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),1)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case 4:
        jj_consume_token(4);
                        sink = sink .start(makeTConstructor(sink, t, "B4__M__28_inline", null)) ;
        sink = N_B(sink, env);
        jj_consume_token(5);

                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case 6:
        jj_consume_token(6);
                        sink = sink .start(makeTConstructor(sink, t, "B4__M_f_inline", null)) ;
                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case 7:
                sink = sink .start(makeTConstructor(sink, t, "B4_inline", null)) ;
        jj_consume_token(7);

                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_B4");
    }
  }

/* Productions for Exp with precedence 0. */

/** <em>Exp$WithEOF</em> ::= <em>Exp</em> EOF . */
  final public net.sf.crsx.Sink N_Exp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp$WithEOF");
    try {
      sink = N_Exp(sink, env);
      jj_consume_token(0);
                               {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp$WithEOF");
    }
  }

/**
 * <em>Exp</em> ::=  <a href="#N_Exp1">&lang;Exp1&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Exp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp");
    try {
        Token t = null;
      sink = N_Exp1(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp");
    }
  }

/* Productions for Exp with precedence 1. */

/* Handle left recursion. */

/**
 * <em>Exp1LR</em> ::=   "<code>+</code>"   (  <a href="#N_Exp2">&lang;Exp2&rang;</a> <font color="red">:#2</font>   (  <a href="#N_Exp1LR">&lang;Exp1LR {{Exp1_LR__M__2b_Exp[#1, #2]}}&rang;</a>   )  )  <br>
 *  |   "<code>-</code>"   (  <a href="#N_Exp2">&lang;Exp2&rang;</a> <font color="red">:#2</font>   (  <a href="#N_Exp1LR">&lang;Exp1LR {{Exp1_LR__M____Exp[#1, #2]}}&rang;</a>   )  )  <br>
 *  |  <font color="red">{{#1}}</font> 
 */
  final public net.sf.crsx.Sink N_Exp1LR(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__1) throws ParseException {
    trace_call("N_Exp1LR");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__2 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 14:
        jj_consume_token(14);
        N_Exp2(b__2.sink(), env);
                                s1 = b1.sink();
                                s1 .start(s1.makeConstructor("Exp1_LR__M__2b_Exp")) .copy(b__1, false) .copy(b__2, true) .end() ;
        sink = N_Exp1LR(sink, env, b1);
         {if (true) return sink;}
        break;
      case 15:
        jj_consume_token(15);
        N_Exp2(b__2.sink(), env);
                                s1 = b1.sink();
                                s1 .start(s1.makeConstructor("Exp1_LR__M____Exp")) .copy(b__1, false) .copy(b__2, true) .end() ;
        sink = N_Exp1LR(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[4] = jj_gen;
                sink = sink .copy(b__1, false) ;
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp1LR");
    }
  }

/**
 * <em>Exp1</em> ::=   "<code>+</code>"   (  <a href="#N_Exp2">&lang;Exp2&rang;</a> <font color="red">:#1</font>   (  <a href="#N_Exp1LR">&lang;Exp1LR {{Exp1__M__2b_Exp[#1]}}&rang;</a>   )  )  <br>
 *  |   "<code>-</code>"   (  <a href="#N_Exp2">&lang;Exp2&rang;</a> <font color="red">:#1</font>   (  <a href="#N_Exp1LR">&lang;Exp1LR {{Exp1__M____Exp[#1]}}&rang;</a>   )  )  <br>
 *  |  <a href="#N_Exp2">&lang;Exp2&rang;</a> <font color="red">:#1</font>   (  <a href="#N_Exp1LR">&lang;Exp1LR {{#1}}&rang;</a>   ) 
 */
  final public net.sf.crsx.Sink N_Exp1(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp1");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 14:
        jj_consume_token(14);
        N_Exp2(b__1.sink(), env);
                                s1 = b1.sink();
                                s1 .start(s1.makeConstructor("Exp1__M__2b_Exp")) .copy(b__1, true) .end() ;
        sink = N_Exp1LR(sink, env, b1);
         {if (true) return sink;}
        break;
      case 15:
        jj_consume_token(15);
        N_Exp2(b__1.sink(), env);
                                s1 = b1.sink();
                                s1 .start(s1.makeConstructor("Exp1__M____Exp")) .copy(b__1, true) .end() ;
        sink = N_Exp1LR(sink, env, b1);
         {if (true) return sink;}
        break;
      case 4:
      case 18:
      case 19:
      case T_meta1_T_M_EXP:
      case T_meta2_T_M_EXP:
      case 29:
      case 30:
      case 31:
      case 32:
      case T_meta1_T_M_FUN:
      case T_meta2_T_M_FUN:
      case T_meta1_T_M_INT:
      case T_meta2_T_M_INT:
      case T_meta1_T_M_VAR:
      case T_meta2_T_M_VAR:
      case T_T_M_INT:
      case T_T_M_VAR:
        N_Exp2(b__1.sink(), env);
                        s1 = b1.sink();
                        s1 .copy(b__1, true) ;
        sink = N_Exp1LR(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp1");
    }
  }

/* Productions for Exp with precedence 2. */

/* Handle left recursion. */

/**
 * <em>Exp2LR</em> ::=   "<code>*</code>"   (  <a href="#N_Exp3">&lang;Exp3&rang;</a> <font color="red">:#2</font>   (  <a href="#N_Exp2LR">&lang;Exp2LR {{Exp2_LR__M__2a_Exp[#1, #2]}}&rang;</a>   )  )  <br>
 *  |   "<code>/</code>"   (  <a href="#N_Exp3">&lang;Exp3&rang;</a> <font color="red">:#2</font>   (  <a href="#N_Exp2LR">&lang;Exp2LR {{Exp2_LR__M__2f_Exp[#1, #2]}}&rang;</a>   )  )  <br>
 *  |  <font color="red">{{#1}}</font> 
 */
  final public net.sf.crsx.Sink N_Exp2LR(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__1) throws ParseException {
    trace_call("N_Exp2LR");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__2 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 16:
        jj_consume_token(16);
        N_Exp3(b__2.sink(), env);
                                s1 = b1.sink();
                                s1 .start(s1.makeConstructor("Exp2_LR__M__2a_Exp")) .copy(b__1, false) .copy(b__2, true) .end() ;
        sink = N_Exp2LR(sink, env, b1);
         {if (true) return sink;}
        break;
      case 17:
        jj_consume_token(17);
        N_Exp3(b__2.sink(), env);
                                s1 = b1.sink();
                                s1 .start(s1.makeConstructor("Exp2_LR__M__2f_Exp")) .copy(b__1, false) .copy(b__2, true) .end() ;
        sink = N_Exp2LR(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[6] = jj_gen;
                sink = sink .copy(b__1, false) ;
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp2LR");
    }
  }

/**
 * <em>Exp2</em> ::=  <a href="#N_Exp3">&lang;Exp3&rang;</a> <font color="red">:#1</font>   (  <a href="#N_Exp2LR">&lang;Exp2LR {{#1}}&rang;</a>   ) 
 */
  final public net.sf.crsx.Sink N_Exp2(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp2");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__1 = new net.sf.crsx.util.Buffer(sink);
      N_Exp3(b__1.sink(), env);
                        s1 = b1.sink();
                        s1 .copy(b__1, true) ;
      sink = N_Exp2LR(sink, env, b1);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp2");
    }
  }

/* Productions for Exp with precedence 3. */

/**
 * <em>Exp3</em> ::=   "<code>D</code>"   (  <font color="red">{'Exp3__M_D_inline'}</font>   <a href="#N_Exp">&lang;Exp&rang;</a>     "<code>[</code>"   (  <a href="#N_Var">&lang;Var&rang;</a> <font color="red">^vVar1</font>   (   "<code>↦</code>"   (  <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">[vVar1]</font>    "<code>]</code>"   (  )  )  )  )  )  <br>
 *  |  <a href="#N_Fun">&lang;Fun&rang;</a> <font color="red">:#1</font>   (  <font color="red">{'Exp3_Fun_inline'}</font>   <font color="red">{{#1}}</font>   <a href="#N_Exp4">&lang;Exp4&rang;</a>   )  <br>
 *  |  <a href="#N_Exp4">&lang;Exp4&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Exp3(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp3");
    try {
        net.sf.crsx.util.Buffer b_vVar1 = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        String c0 = null;
        net.sf.crsx.util.Buffer b__1 = new net.sf.crsx.util.Buffer(sink);
        String s_vVar1 = null;
        net.sf.crsx.Variable v_vVar1 = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 18:
        jj_consume_token(18);
                        sink = sink .start(makeTConstructor(sink, t, "Exp3__M_D_inline", null)) ;
        sink = N_Exp(sink, env);
        jj_consume_token(19);
        N_Var(b_vVar1.sink(), env);
                                if (b_vVar1.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_vVar1.term(false).arity() != 0)
                                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_vVar1.term(false)+")");}
                                c0 = b_vVar1.term(true).constructor().symbol();
                                s_vVar1 = c0;
                                v_vVar1 = sink.makeVariable(s_vVar1,true);
        jj_consume_token(20);
                                                {
                                                        net.sf.crsx.Variable[] bs1 = {v_vVar1};
                                                        sink = sink .binds(bs1) ;
                                                }
        sink = N_Exp(sink, env.extend(s_vVar1, v_vVar1));
        jj_consume_token(21);

                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case 19:
      case 29:
      case 30:
      case 31:
      case 32:
      case T_meta1_T_M_FUN:
      case T_meta2_T_M_FUN:
        N_Fun(b__1.sink(), env);
                        sink = sink .start(makeTConstructor(sink, t, "Exp3_Fun_inline", null)) ;
                        sink = sink .copy(b__1, true) ;
        sink = N_Exp4(sink, env);
                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case 4:
      case T_meta1_T_M_EXP:
      case T_meta2_T_M_EXP:
      case T_meta1_T_M_INT:
      case T_meta2_T_M_INT:
      case T_meta1_T_M_VAR:
      case T_meta2_T_M_VAR:
      case T_T_M_INT:
      case T_T_M_VAR:
        sink = N_Exp4(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp3");
    }
  }

/* Productions for Exp with (highest) precedence 4. */

/**
 * <em>Exp4</em> ::=   <a href="#T_meta1_T_M_EXP">meta1_T_M_EXP</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_EXP">meta2_T_M_EXP</a><font color="red">$$:%{unmeta(#,3)%}</font>  <br>
 *  |   "<code>(</code>"   (  <font color="red">{'Exp4__M__28_inline'}</font>   <a href="#N_Exp">&lang;Exp&rang;</a>     "<code>)</code>"   (  )  )  <br>
 *  |  <a href="#N_Int">&lang;Int&rang;</a> <font color="red">:#1</font>   (  <font color="red">{'Exp4_Int_inline'}</font>   <font color="red">{{#1}}</font>  )  <br>
 *  |  <a href="#N_Var">&lang;Var&rang;</a> <font color="red">!!!</font> 
 */
  final public net.sf.crsx.Sink N_Exp4(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Exp4");
    try {
        net.sf.crsx.util.Buffer b_Var = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.Variable v_Var = null;
        String c2 = null;
        net.sf.crsx.util.Buffer b__1 = new net.sf.crsx.util.Buffer(sink);
        String s_Var = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_EXP:
        t = jj_consume_token(T_meta1_T_M_EXP);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_EXP:
        t = jj_consume_token(T_meta2_T_M_EXP);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),3)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case 4:
        jj_consume_token(4);
                        sink = sink .start(makeTConstructor(sink, t, "Exp4__M__28_inline", null)) ;
        sink = N_Exp(sink, env);
        jj_consume_token(5);

                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case T_meta1_T_M_INT:
      case T_meta2_T_M_INT:
      case T_T_M_INT:
        N_Int(b__1.sink(), env);
                        sink = sink .start(makeTConstructor(sink, t, "Exp4_Int_inline", null)) ;
                        sink = sink .copy(b__1, true) ;
                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case T_meta1_T_M_VAR:
      case T_meta2_T_M_VAR:
      case T_T_M_VAR:
        N_Var(b_Var.sink(), env);
                if (b_Var.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_Var.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_Var.term(false)+")");}
                c2 = b_Var.term(true).constructor().symbol();
                s_Var = c2;
                v_Var = (env.containsKey(s_Var) ? env.get(s_Var) : freeOrFresh(sink,s_Var,true));
                if (v_Var == null) {if (true) throw new ParseException("Variable "+s_Var+" cannot be resolved?");}
                sink = sink .use(v_Var) ;
         {if (true) return sink;}
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Exp4");
    }
  }

/* Productions for Fun with precedence 0. */

/** <em>Fun$WithEOF</em> ::= <em>Fun</em> EOF . */
  final public net.sf.crsx.Sink N_Fun$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Fun$WithEOF");
    try {
      sink = N_Fun(sink, env);
      jj_consume_token(0);
                               {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Fun$WithEOF");
    }
  }

/**
 * <em>Fun</em> ::=  <a href="#N_Fun1">&lang;Fun1&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Fun(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Fun");
    try {
        Token t = null;
      sink = N_Fun1(sink, env);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Fun");
    }
  }

/* Productions for Fun with precedence 1. */

/* Handle left recursion. */

/**
 * <em>Fun1LR</em> ::=   "<code>'</code>"   (  <a href="#N_Fun1LR">&lang;Fun1LR {{Fun1_LR__M__27[#1]}}&rang;</a>   )  <br>
 *  |  <font color="red">{{#1}}</font> 
 */
  final public net.sf.crsx.Sink N_Fun1LR(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__1) throws ParseException {
    trace_call("N_Fun1LR");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 28:
        jj_consume_token(28);
                        s1 = b1.sink();
                        s1 .start(s1.makeConstructor("Fun1_LR__M__27")) .copy(b__1, false) .end() ;
        sink = N_Fun1LR(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[9] = jj_gen;
                sink = sink .copy(b__1, false) ;
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Fun1LR");
    }
  }

/**
 * <em>Fun1</em> ::=  <a href="#N_Fun2">&lang;Fun2&rang;</a> <font color="red">:#1</font>   (  <a href="#N_Fun1LR">&lang;Fun1LR {{#1}}&rang;</a>   ) 
 */
  final public net.sf.crsx.Sink N_Fun1(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Fun1");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__1 = new net.sf.crsx.util.Buffer(sink);
      N_Fun2(b__1.sink(), env);
                        s1 = b1.sink();
                        s1 .copy(b__1, true) ;
      sink = N_Fun1LR(sink, env, b1);
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Fun1");
    }
  }

/* Productions for Fun with (highest) precedence 2. */

/**
 * <em>Fun2</em> ::=   <a href="#T_meta1_T_M_FUN">meta1_T_M_FUN</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_FUN">meta2_T_M_FUN</a><font color="red">$$:%{unmeta(#,3)%}</font>  <br>
 *  |   "<code>[</code>"   (  <font color="red">{'Fun2__M__5b_inline'}</font>   <a href="#N_Var">&lang;Var&rang;</a> <font color="red">^vVar1</font>   (   "<code>↦</code>"   (  <a href="#N_Exp">&lang;Exp&rang;</a> <font color="red">[vVar1]</font>    "<code>]</code>"   (  )  )  )  )  <br>
 *  |   "<code>cos</code>"   (  <font color="red">{'Fun2__M_cos_inline'}</font>  )  <br>
 *  |   "<code>exp</code>"   (  <font color="red">{'Fun2__M_exp_inline'}</font>  )  <br>
 *  |   "<code>ln</code>"   (  <font color="red">{'Fun2__M_ln_inline'}</font>  )  <br>
 *  |  <font color="red">{'Fun2_inline'}</font>    "<code>sin</code>"   (  ) 
 */
  final public net.sf.crsx.Sink N_Fun2(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Fun2");
    try {
        net.sf.crsx.util.Buffer b_vVar1 = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        String c1 = null;
        String s_vVar1 = null;
        net.sf.crsx.Variable v_vVar1 = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_FUN:
        t = jj_consume_token(T_meta1_T_M_FUN);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_FUN:
        t = jj_consume_token(T_meta2_T_M_FUN);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),3)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case 19:
        jj_consume_token(19);
                        sink = sink .start(makeTConstructor(sink, t, "Fun2__M__5b_inline", null)) ;
        N_Var(b_vVar1.sink(), env);
                        if (b_vVar1.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_vVar1.term(false).arity() != 0)
                         {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_vVar1.term(false)+")");}
                        c1 = b_vVar1.term(true).constructor().symbol();
                        s_vVar1 = c1;
                        v_vVar1 = sink.makeVariable(s_vVar1,true);
        jj_consume_token(20);
                                        {
                                                net.sf.crsx.Variable[] bs1 = {v_vVar1};
                                                sink = sink .binds(bs1) ;
                                        }
        sink = N_Exp(sink, env.extend(s_vVar1, v_vVar1));
        jj_consume_token(21);

                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case 29:
        jj_consume_token(29);
                        sink = sink .start(makeTConstructor(sink, t, "Fun2__M_cos_inline", null)) ;
                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case 30:
        jj_consume_token(30);
                        sink = sink .start(makeTConstructor(sink, t, "Fun2__M_exp_inline", null)) ;
                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case 31:
        jj_consume_token(31);
                        sink = sink .start(makeTConstructor(sink, t, "Fun2__M_ln_inline", null)) ;
                        sink = sink .end() ;
         {if (true) return sink;}
        break;
      case 32:
                sink = sink .start(makeTConstructor(sink, t, "Fun2_inline", null)) ;
        jj_consume_token(32);

                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Fun2");
    }
  }

/** <em>Int$WithEOF</em> ::= <em>Int</em> EOF . */
  final public net.sf.crsx.Sink N_Int$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Int$WithEOF");
    try {
      sink = N_Int(sink, env);
      jj_consume_token(0);
                               {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Int$WithEOF");
    }
  }

/**
 * <em>Int</em> ::=   <a href="#T_meta1_T_M_INT">meta1_T_M_INT</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_INT">meta2_T_M_INT</a><font color="red">$$:%{unmeta(#,3)%}</font>  <br>
 *  |   <a href="#T_T_M_INT">T_M_INT</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_Int(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Int");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_INT:
        t = jj_consume_token(T_meta1_T_M_INT);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_INT:
        t = jj_consume_token(T_meta2_T_M_INT);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),3)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_INT:
        t = jj_consume_token(T_T_M_INT);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Int");
    }
  }

/** <em>Var$WithEOF</em> ::= <em>Var</em> EOF . */
  final public net.sf.crsx.Sink N_Var$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Var$WithEOF");
    try {
      sink = N_Var(sink, env);
      jj_consume_token(0);
                               {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Var$WithEOF");
    }
  }

/**
 * <em>Var</em> ::=   <a href="#T_meta1_T_M_VAR">meta1_T_M_VAR</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_VAR">meta2_T_M_VAR</a><font color="red">$$:%{unmeta(#,3)%}</font>  <br>
 *  |   <a href="#T_T_M_VAR">T_M_VAR</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_Var(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Var");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_meta1_T_M_VAR:
        t = jj_consume_token(T_meta1_T_M_VAR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_meta2_T_M_VAR:
        t = jj_consume_token(T_meta2_T_M_VAR);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),3)), unit, t.beginLine, t.beginColumn+1, env, freeVariables);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      case T_T_M_VAR:
        t = jj_consume_token(T_T_M_VAR);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Var");
    }
  }

  /** Generated Token Manager. */
  public DerivParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[13];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2,0x4,0x11d8,0x11d0,0xc000,0xe44cc010,0x30000,0xe44c0010,0x4400010,0x10000000,0xe0080000,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x30228a3,0x0,0x30228a3,0x3022880,0x0,0x23,0x1000880,0x2022000,};
   }

  /** Constructor with InputStream. */
  public DerivParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public DerivParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new DerivParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public DerivParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DerivParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public DerivParser(DerivParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(DerivParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[59];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 13; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 59; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}

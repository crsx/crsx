/* net.sf.crsx.hoacs.bootstrap.Raw: PG-generated JavaCC parser specification. */

options {
	SANITY_CHECK  = true;
	BUILD_PARSER = true;
	JDK_VERSION = "1.5";
	ERROR_REPORTING = true;
	DEBUG_PARSER = true;
	BUILD_TOKEN_MANAGER = true;
	FORCE_LA_CHECK = true;
	STATIC = false;
}

PARSER_BEGIN(Raw)
package net.sf.crsx.hoacs.bootstrap;

/**
 * Grammar for "raw" HOACS systems, in PG form.
 * Used to bootstrap HOACS on a crsx3 system.
 *
 * @author <a href="http://www.research.ibm.com/people/k/krisrose">Kristoffer Rose</a>.
 * @version $Id: Raw.pg,v 1.32 2013/12/05 03:28:29 krisrose Exp $
 */
public class Raw implements net.sf.crsx.Parser
{
	/** Factory. */
	net.sf.crsx.Factory<? extends net.sf.crsx.Term> factory;
	/** Compilation unit name for error messages. */
	String unit;
	/** Whether the parser should capture token locations. */
	boolean captureLocations = true;
	/** Constructor with token location information. */
	private net.sf.crsx.Constructor makeTConstructor(net.sf.crsx.Sink sink, Token t, Object object, String sort)
	{
		net.sf.crsx.Constructor c = sort == null ? sink.makeConstructor(object) : sink.makeLiteral(object, sort);
		if (t == null) t = token;
		if (captureLocations && t != null)
		{
			if (factory.get("meta") == null)
				c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn);
		}
		return c;
	}

	/** Helper interface with category non-terminal calls. */
	abstract class CategoryCall { abstract net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException; }
	/** Direct category invocations. */
	java.util.Map<String,CategoryCall> categoryCall = new java.util.HashMap<String,CategoryCall>();
	{
		categoryCall.put("raw", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Module$WithEOF(sink, bound);} });
		categoryCall.put("rawModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Module$WithEOF(sink, bound);} });
		categoryCall.put("rawModuleName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ModuleName$WithEOF(sink, bound);} });
		categoryCall.put("rawEmbeddedModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_EmbeddedModule$WithEOF(sink, bound);} });
		categoryCall.put("rawDeclaration", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Declaration$WithEOF(sink, bound);} });
		categoryCall.put("rawDeclarations", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Declarations$WithEOF(sink, bound);} });
		categoryCall.put("rawSortAbstraction", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortAbstraction$WithEOF(sink, bound);} });
		categoryCall.put("rawRule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Rule$WithEOF(sink, bound);} });
		categoryCall.put("rawSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Sort$WithEOF(sink, bound);} });
		categoryCall.put("rawSortParam", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortParam$WithEOF(sink, bound);} });
		categoryCall.put("rawSortName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortName$WithEOF(sink, bound);} });
		categoryCall.put("rawSortNames", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortNames$WithEOF(sink, bound);} });
		categoryCall.put("rawSimpleSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SimpleSort$WithEOF(sink, bound);} });
		categoryCall.put("rawSimpleSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SimpleSorts$WithEOF(sink, bound);} });
		categoryCall.put("rawSubstituteSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SubstituteSorts$WithEOF(sink, bound);} });
		categoryCall.put("rawSubstituteSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SubstituteSort$WithEOF(sink, bound);} });
		categoryCall.put("rawTagging", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Tagging$WithEOF(sink, bound);} });
		categoryCall.put("rawSortAlternative", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortAlternative$WithEOF(sink, bound);} });
		categoryCall.put("rawSortAlternatives", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortAlternatives$WithEOF(sink, bound);} });
		categoryCall.put("rawForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Form$WithEOF(sink, bound);} });
		categoryCall.put("rawFormPrec", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_FormPrec$WithEOF(sink, bound);} });
		categoryCall.put("rawInheritedRefs", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_InheritedRefs$WithEOF(sink, bound);} });
		categoryCall.put("rawInheritedRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_InheritedRef$WithEOF(sink, bound);} });
		categoryCall.put("rawAttributeKind", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeKind$WithEOF(sink, bound);} });
		categoryCall.put("rawAttributeForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeForm$WithEOF(sink, bound);} });
		categoryCall.put("rawAttributeOptions", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeOptions$WithEOF(sink, bound);} });
		categoryCall.put("rawAttributeOption", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeOption$WithEOF(sink, bound);} });
		categoryCall.put("rawLexerState", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_LexerState$WithEOF(sink, bound);} });
		categoryCall.put("rawScopeSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ScopeSorts$WithEOF(sink, bound);} });
		categoryCall.put("rawScopeSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ScopeSort$WithEOF(sink, bound);} });
		categoryCall.put("rawParsedForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ParsedForm$WithEOF(sink, bound);} });
		categoryCall.put("rawRepeat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Repeat$WithEOF(sink, bound);} });
		categoryCall.put("rawPriority", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Priority$WithEOF(sink, bound);} });
		categoryCall.put("rawFragmentName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_FragmentName$WithEOF(sink, bound);} });
		categoryCall.put("rawFragmentRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_FragmentRef$WithEOF(sink, bound);} });
		categoryCall.put("rawRegExp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExp$WithEOF(sink, bound);} });
		categoryCall.put("rawRegExpChoice", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpChoice$WithEOF(sink, bound);} });
		categoryCall.put("rawRegExpUnits", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpUnits$WithEOF(sink, bound);} });
		categoryCall.put("rawRegExpUnit", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpUnit$WithEOF(sink, bound);} });
		categoryCall.put("rawRegExpSimple", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpSimple$WithEOF(sink, bound);} });
		categoryCall.put("rawRegExpLeaf", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpLeaf$WithEOF(sink, bound);} });
		categoryCall.put("rawWord", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Word$WithEOF(sink, bound);} });
		categoryCall.put("rawTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Term$WithEOF(sink, bound);} });
		categoryCall.put("rawNotVariableTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_NotVariableTerm$WithEOF(sink, bound);} });
		categoryCall.put("rawAttributes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Attributes$WithEOF(sink, bound);} });
		categoryCall.put("rawAttribute", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Attribute$WithEOF(sink, bound);} });
		categoryCall.put("rawAttributeValue", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeValue$WithEOF(sink, bound);} });
		categoryCall.put("rawScopes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Scopes$WithEOF(sink, bound);} });
		categoryCall.put("rawScope", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Scope$WithEOF(sink, bound);} });
		categoryCall.put("rawTerms", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Terms$WithEOF(sink, bound);} });
		categoryCall.put("rawParsed", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Parsed$WithEOF(sink, bound);} });
		categoryCall.put("rawLiteral", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Literal$WithEOF(sink, bound);} });
		categoryCall.put("rawConstructor", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Constructor$WithEOF(sink, bound);} });
		categoryCall.put("rawMetaVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_MetaVariable$WithEOF(sink, bound);} });
		categoryCall.put("rawMetaVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_MetaVariables$WithEOF(sink, bound);} });
		categoryCall.put("rawVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Variable$WithEOF(sink, bound);} });
		categoryCall.put("rawVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Variables$WithEOF(sink, bound);} });
		categoryCall.put("rawAttributeName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeName$WithEOF(sink, bound);} });
		categoryCall.put("rawRegExpClass", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpClass$WithEOF(sink, bound);} });
		categoryCall.put("rawCC", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC$WithEOF(sink, bound);} });
		categoryCall.put("rawCC_RangesTop", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_RangesTop$WithEOF(sink, bound);} });
		categoryCall.put("rawCC_Ranges", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_Ranges$WithEOF(sink, bound);} });
		categoryCall.put("rawCC_FirstRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_FirstRangeStartChar$WithEOF(sink, bound);} });
		categoryCall.put("rawCC_NonDashRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_NonDashRangeStartChar$WithEOF(sink, bound);} });
		categoryCall.put("rawCC_RangeChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_RangeChar$WithEOF(sink, bound);} });
	}

	// Constructor.

	/** Construct dummy instance. */
	public Raw()
	{
		this((java.io.Reader) null);
		disable_tracing();
	}

	// Parser implementation.

	public net.sf.crsx.Parser parser(net.sf.crsx.Factory<? extends net.sf.crsx.Term> f)
	{
		if (factory != null)
		{
			net.sf.crsx.Parser parser = new Raw().parser(f);
			parser.setParserVerbose(trace_enabled); parser.setParserLocation(captureLocations);
			return parser;
		}
		else
		{
			factory = f;
			assert f != null : "Or Else!";
			return this;
		}
	}

	public void setParserVerbose(boolean verbose)
	{
		if (verbose)
			enable_tracing();
		else
			disable_tracing();
	}

	public void setParserLocation(boolean capture)
	{
		captureLocations = capture;
	}

	public void setEmbeddedParser(net.sf.crsx.Parser subparser) throws net.sf.crsx.CRSException
	{}

	public Iterable<String> categories()
	{
		return categoryCall.keySet();
	}

	public net.sf.crsx.Sink parse(net.sf.crsx.Sink sink, String category, java.io.Reader reader, String unit, int firstLine, int firstColumn, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
	{
		try
		{
			this.unit = unit;
			ReInit((java.io.Reader) null);
			jj_input_stream.ReInit(reader, firstLine, firstColumn); token_source = new RawTokenManager(jj_input_stream); // hacks to update line and column numbers
			if (bound == null) bound = new net.sf.crsx.util.LinkedExtensibleMap<String, net.sf.crsx.Variable>();
			if (category == null || category.length() == 0) return N_Module(sink, bound);
			else if (categoryCall.containsKey(category)) return categoryCall.get(category).call(sink, bound);
			else throw new net.sf.crsx.CRSException("Parser category '"+category+"' not supported!");
		}
		catch (ParseException e)
		{
			throw new net.sf.crsx.CRSException(e.getMessage());
		}
	}

	public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
	{
		net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
		parse(buffer.sink(), category, reader, null, 1, 1, bound);
		return buffer.term(true);
	}


  static String raw(String s) {return "RAW-"+s;} // prefix for constructors
  static String unembed(String s) {return s.substring(1, s.length()-1);}

	/**
	 * Run the parser and print the resulting term.
	 * @param args should contain two strings: the category and an input file name
	 */
	public static void main(String[] args)
	{
		try
		{
			if (args.length != 2)
			{
				System.err.println("Usage: Raw category input");
				System.exit(2);
			}
			String category = args[0];
			java.io.Reader reader = new java.io.FileReader(args[1]);
			net.sf.crsx.Factory<net.sf.crsx.generic.GenericTerm> factory = new net.sf.crsx.generic.GenericFactory();
			net.sf.crsx.Parser parser = new Raw();
			net.sf.crsx.Sink sink = factory.sink(System.out);
			parser.parser(factory).parse(sink, category, reader, null, 1, 1, null);
		}
		catch (net.sf.crsx.CRSException e)
		{
			System.err.println("CRS error: "+e);
			System.exit(1);
		}
		catch (java.io.IOException e)
		{
			System.err.println("I/O error: "+e);
			System.exit(1);
		}
	}

}
PARSER_END(Raw)

/**
 * <em>Embedded</em> ::=   <a href="#T_Embedded">Embedded</a><font color="red">$$:unembed</font> 
 */
net.sf.crsx.Sink N_Embedded(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	 ( 
	t=<T_Embedded>
	{
		try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unembed(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

/** <em>Module$WithEOF</em> ::= <em>Module</em> EOF . */
net.sf.crsx.Sink N_Module$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Module(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Module production. */
TOKEN : {<MT_Module : "#Module" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Module production. */
TOKEN : {<IT_Module : "%Module">}

/**
 * <em>Module</em> ::=  <font color="red">{top-module}</font><font color="red">:raw</font>   <a href="#N_EmbeddedModule">&lang;EmbeddedModule&rang;</a>  
 */
net.sf.crsx.Sink N_Module(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Module> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Module>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("top-module"), null)) ;
	}
	 ) 
	 ( 
	sink=N_EmbeddedModule(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>EmbeddedModule$WithEOF</em> ::= <em>EmbeddedModule</em> EOF . */
net.sf.crsx.Sink N_EmbeddedModule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_EmbeddedModule(sink, env) <EOF> {return sink;} }

/** Special meta-variable for EmbeddedModule production. */
TOKEN : {<MT_EmbeddedModule : "#EmbeddedModule" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token EmbeddedModule production. */
TOKEN : {<IT_EmbeddedModule : "%EmbeddedModule">}

/**
 * <em>EmbeddedModule</em> ::=   <a href="#T_MODULE">MODULE</a><font color="red">:raw</font>   <a href="#N_ModuleName">&lang;ModuleName&rang;</a>     <a href="#T_LBRACE">LBRACE</a>   <a href="#N_Declarations">&lang;Declarations&rang;</a>     <a href="#T_RBRACE">RBRACE</a> 
 */
net.sf.crsx.Sink N_EmbeddedModule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_EmbeddedModule> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_EmbeddedModule>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_MODULE>
	{
		sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_ModuleName(sink, env)
	 ) 
	 ( 
	 <T_LBRACE>
	 ) 
	 ( 
	sink=N_Declarations(sink, env)
	 ) 
	 ( 
	 <T_RBRACE>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Declarations$WithEOF</em> ::= <em>Declarations</em> EOF . */
net.sf.crsx.Sink N_Declarations$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Declarations(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Declarations production. */
TOKEN : {<MT_Declarations : "#Declarations" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Declarations production. */
TOKEN : {<IT_Declarations : "%Declarations">}

/**
 * <em>Declarations</em> ::=  (  <font color="red">{$Cons}</font><font color="red">:raw</font>   <a href="#N_Declaration">&lang;Declaration&rang;</a>    <a href="#N_Declarations">&lang;Declarations&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Declarations(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Declarations> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Declarations>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("Declarations$Cons"), null)) ;
		}
		 ) 
		 ( 
		sink=N_Declaration(sink, env)
		 ) 
		 ( 
		sink=N_Declarations(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "Declarations$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Declaration$WithEOF</em> ::= <em>Declaration</em> EOF . */
net.sf.crsx.Sink N_Declaration$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Declaration(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Declaration production. */
TOKEN : {<MT_Declaration : "#Declaration" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Declaration production. */
TOKEN : {<IT_Declaration : "%Declaration">}

/**
 * <em>Declaration</em> ::=  <font color="red">{embedded-module}</font><font color="red">:raw</font>   <a href="#N_EmbeddedModule">&lang;EmbeddedModule&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_IMPORT">IMPORT</a><font color="red">:raw</font>   <a href="#N_ModuleName">&lang;ModuleName&rang;</a>    (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_SortNames">&lang;SortNames&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |  <font color="red">{$Nil}</font>  )    <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_SPACE">SPACE</a><font color="red">:raw</font>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_TOKEN">TOKEN</a>   (  <font color="red">{'token'}</font><font color="red">:raw</font>   <a href="#N_SortName">&lang;SortName&rang;</a>     <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>    <a href="#N_LexerState">&lang;LexerState&rang;</a>     <a href="#T_SEMI">SEMI</a>  |   <a href="#T_FRAGMENT">FRAGMENT</a><font color="red">:raw</font>   <a href="#N_FragmentName">&lang;FragmentName&rang;</a>     <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  )  <br>
 *  |   <a href="#T_FRAGMENT">FRAGMENT</a><font color="red">:raw</font>   <a href="#N_FragmentName">&lang;FragmentName&rang;</a>     <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_ATTRIBUTE">ATTRIBUTE</a><font color="red">:raw</font>   <a href="#N_AttributeKind">&lang;AttributeKind&rang;</a>    <a href="#N_AttributeName">&lang;AttributeName&rang;</a>    <a href="#N_AttributeForm">&lang;AttributeForm&rang;</a>    <a href="#N_AttributeOptions">&lang;AttributeOptions&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_SORT">SORT</a><font color="red">:raw</font>   <a href="#N_SortName">&lang;SortName&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>    <a href="#N_SortAbstraction">&lang;SortAbstraction&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  <font color="red">{anonymous}</font><font color="red">:raw</font>   <a href="#N_SortAlternatives">&lang;SortAlternatives&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  (   <a href="#T_RULE">RULE</a>  )?   <font color="red">{rule}</font><font color="red">:raw</font>   <a href="#N_Rule">&lang;Rule&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  <font color="red">{nestedDeclarations}</font><font color="red">:raw</font>    <a href="#T_LBRACE">LBRACE</a>   <a href="#N_Declarations">&lang;Declarations&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  <br>
 *  |   <a href="#T_LEXER">LEXER</a><font color="red">:raw</font>   <a href="#N_SortName">&lang;SortName&rang;</a>     <a href="#T_SEMI">SEMI</a> 
 */
net.sf.crsx.Sink N_Declaration(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Declaration> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Declaration>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("embedded-module"), null)) ;
	}
	 ) 
	 ( 
	sink=N_EmbeddedModule(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_IMPORT>
	{
		sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_ModuleName(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_LPAREN>
		 ) 
		 ( 
			 ( 
			sink=N_SortNames(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_RPAREN>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_SPACE>
	{
		sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExp(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_TOKEN>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("token"), null)) ;
		}
		 ) 
		 ( 
		sink=N_SortName(sink, env)
		 ) 
		 ( 
		 <T_BAR>
		 ) 
		 ( 
		sink=N_RegExp(sink, env)
		 ) 
		 ( 
		sink=N_LexerState(sink, env)
		 ) 
		 ( 
		 <T_SEMI>
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_FRAGMENT>
		{
			sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_FragmentName(sink, env)
		 ) 
		 ( 
		 <T_BAR>
		 ) 
		 ( 
		sink=N_RegExp(sink, env)
		 ) 
		 ( 
		 <T_SEMI>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	t=<T_FRAGMENT>
	{
		sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_FragmentName(sink, env)
	 ) 
	 ( 
	 <T_BAR>
	 ) 
	 ( 
	sink=N_RegExp(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_ATTRIBUTE>
	{
		sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_AttributeKind(sink, env)
	 ) 
	 ( 
	sink=N_AttributeName(sink, env)
	 ) 
	 ( 
	sink=N_AttributeForm(sink, env)
	 ) 
	 ( 
	sink=N_AttributeOptions(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_SORT>
	{
		sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortName(sink, env)
	 ) 
	 ( 
	sink=N_Repeat(sink, env)
	 ) 
	 ( 
	sink=N_SortAbstraction(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("anonymous"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortAlternatives(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
		 ( 
		 <T_RULE>
		 ) 
	 )? 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("rule"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Rule(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("nestedDeclarations"), null)) ;
	}
	 ) 
	 ( 
	 <T_LBRACE>
	 ) 
	 ( 
	sink=N_Declarations(sink, env)
	 ) 
	 ( 
	 <T_RBRACE>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_LEXER>
	{
		sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortName(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>LexerState$WithEOF</em> ::= <em>LexerState</em> EOF . */
net.sf.crsx.Sink N_LexerState$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_LexerState(sink, env) <EOF> {return sink;} }

/** Special meta-variable for LexerState production. */
<RE, DEFAULT> TOKEN : {<MT_LexerState : "#LexerState" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token LexerState production. */
<RE, DEFAULT> TOKEN : {<IT_LexerState : "%LexerState">}

/**
 * <em>LexerState</em> ::=  <font color="red">{ChangeState}</font><font color="red">:raw</font>    <a href="#T_ARROW">ARROW</a>   <a href="#N_SortName">&lang;SortName&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_LexerState(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_LexerState> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_LexerState>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ChangeState"), null)) ;
	}
	 ) 
	 ( 
	 <T_ARROW>
	 ) 
	 ( 
	sink=N_SortName(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "LexerState$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExp$WithEOF</em> ::= <em>RegExp</em> EOF . */
net.sf.crsx.Sink N_RegExp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExp(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExp production. */
<RE> TOKEN : {<MT_RegExp : "#RegExp" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExp production. */
<RE> TOKEN : {<IT_RegExp : "%RegExp">}

/**
 * <em>RegExp</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_RegExpChoice">&lang;RegExpChoice&rang;</a>    (   <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_RegExp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExp> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExp>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "RegExp$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpChoice(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_BAR>
		 ) 
		 ( 
		sink=N_RegExp(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "RegExp$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpChoice$WithEOF</em> ::= <em>RegExpChoice</em> EOF . */
net.sf.crsx.Sink N_RegExpChoice$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpChoice(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpChoice production. */
<RE> TOKEN : {<MT_RegExpChoice : "#RegExpChoice" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpChoice production. */
<RE> TOKEN : {<IT_RegExpChoice : "%RegExpChoice">}

/**
 * <em>RegExpChoice</em> ::=   <a href="#T_NESTED">NESTED</a><font color="red">:raw</font>   <a href="#N_RegExpSimple">&lang;RegExpSimple&rang;</a>    <a href="#N_RegExpSimple">&lang;RegExpSimple&rang;</a>   <br>
 *  |  <font color="red">{RegExpConcat}</font><font color="red">:raw</font>   <a href="#N_RegExpUnits">&lang;RegExpUnits&rang;</a>  
 */
net.sf.crsx.Sink N_RegExpChoice(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpChoice> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpChoice>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_NESTED>
	{
		sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpSimple(sink, env)
	 ) 
	 ( 
	sink=N_RegExpSimple(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpConcat"), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpUnits(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpUnits$WithEOF</em> ::= <em>RegExpUnits</em> EOF . */
net.sf.crsx.Sink N_RegExpUnits$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpUnits(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpUnits production. */
<RE> TOKEN : {<MT_RegExpUnits : "#RegExpUnits" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpUnits production. */
<RE> TOKEN : {<IT_RegExpUnits : "%RegExpUnits">}

/**
 * <em>RegExpUnits</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_RegExpUnit">&lang;RegExpUnit&rang;</a>    <a href="#N_RegExpUnits">&lang;RegExpUnits&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_RegExpUnits(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpUnits> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpUnits>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpUnit(sink, env)
	 ) 
	 ( 
	sink=N_RegExpUnits(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpUnit$WithEOF</em> ::= <em>RegExpUnit</em> EOF . */
net.sf.crsx.Sink N_RegExpUnit$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpUnit(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpUnit production. */
<RE> TOKEN : {<MT_RegExpUnit : "#RegExpUnit" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpUnit production. */
<RE> TOKEN : {<IT_RegExpUnit : "%RegExpUnit">}

/**
 * <em>RegExpUnit</em> ::=  <font color="red">{RegExpUnit}</font><font color="red">:raw</font>   <a href="#N_RegExpSimple">&lang;RegExpSimple&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>  
 */
net.sf.crsx.Sink N_RegExpUnit(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpUnit> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpUnit>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpUnit"), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpSimple(sink, env)
	 ) 
	 ( 
	sink=N_Repeat(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Repeat$WithEOF</em> ::= <em>Repeat</em> EOF . */
net.sf.crsx.Sink N_Repeat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_Repeat(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Repeat production. */
<DEFAULT, RE> TOKEN : {<MT_Repeat : "#Repeat" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Repeat production. */
<DEFAULT, RE> TOKEN : {<IT_Repeat : "%Repeat">}

/**
 * <em>Repeat</em> ::=   <a href="#T_PLUS">PLUS</a>   (  <font color="red">{RepeatSomeSep}</font><font color="red">:raw</font>    <a href="#T_SUB">SUB</a>   (  <a href="#N_RegExpLeaf">&lang;RegExpLeaf&rang;</a>   |  <font color="red">{RegExpWord}</font><font color="red">:raw</font>   <a href="#N_Separator">&lang;Separator&rang;</a>   )  |  <font color="red">{RepeatSome}</font><font color="red">:raw</font>  )  <br>
 *  |  <font color="red">{RepeatMaybeSome}</font><font color="red">:raw</font>    <a href="#T_STAR">STAR</a>  <br>
 *  |  <font color="red">{RepeatMaybe}</font><font color="red">:raw</font>    <a href="#T_QUEST">QUEST</a>  <br>
 *  |  <font color="red">{RepeatSingle}</font><font color="red">:raw</font> 
 */
net.sf.crsx.Sink N_Repeat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Repeat> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Repeat>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	 <T_PLUS>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("RepeatSomeSep"), null)) ;
		}
		 ) 
		 ( 
		 <T_SUB>
		 ) 
		 ( 
			 ( 
			sink=N_RegExpLeaf(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, raw("RegExpWord"), null)) ;
			}
			 ) 
			 ( 
			sink=N_Separator(sink, env)
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("RepeatSome"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RepeatMaybeSome"), null)) ;
	}
	 ) 
	 ( 
	 <T_STAR>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RepeatMaybe"), null)) ;
	}
	 ) 
	 ( 
	 <T_QUEST>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RepeatSingle"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpLeaf$WithEOF</em> ::= <em>RegExpLeaf</em> EOF . */
net.sf.crsx.Sink N_RegExpLeaf$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_RegExpLeaf(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpLeaf production. */
<DEFAULT, RE> TOKEN : {<MT_RegExpLeaf : "#RegExpLeaf" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpLeaf production. */
<DEFAULT, RE> TOKEN : {<IT_RegExpLeaf : "%RegExpLeaf">}

/**
 * <em>RegExpLeaf</em> ::=  <font color="red">{RegExpString}</font><font color="red">:raw</font>   <a href="#N_String">&lang;String&rang;</a>   <br>
 *  |  <font color="red">{RegExpWord}</font><font color="red">:raw</font>   <a href="#N_Word">&lang;Word&rang;</a>  
 */
net.sf.crsx.Sink N_RegExpLeaf(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpLeaf> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpLeaf>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpString"), null)) ;
	}
	 ) 
	 ( 
	sink=N_String(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpWord"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Word(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpSimple$WithEOF</em> ::= <em>RegExpSimple</em> EOF . */
net.sf.crsx.Sink N_RegExpSimple$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpSimple(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpSimple production. */
<RE> TOKEN : {<MT_RegExpSimple : "#RegExpSimple" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpSimple production. */
<RE> TOKEN : {<IT_RegExpSimple : "%RegExpSimple">}

/**
 * <em>RegExpSimple</em> ::=  <a href="#N_RegExpLeaf">&lang;RegExpLeaf&rang;</a>   <br>
 *  |  <font color="red">{RegExpRef}</font><font color="red">:raw</font>   <a href="#N_FragmentRef">&lang;FragmentRef&rang;</a>   <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:raw</font>   <a href="#N_RegExpClass">&lang;RegExpClass&rang;</a>   <br>
 *  |  <font color="red">{RegExpAny}</font><font color="red">:raw</font>    <a href="#T_DOT">DOT</a>  <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:raw</font>   <font color="red">{RegExpClassChar}</font><font color="red">:raw</font>   (   <a href="#T_ESCAPEDCHAR">ESCAPEDCHAR</a><font color="red">$</font>  )   <font color="red">{RegExpClassDone}</font><font color="red">:raw</font>  <br>
 *  |  <font color="red">{RegExpNest}</font><font color="red">:raw</font>    <a href="#T_LPAREN">LPAREN</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_RPAREN">RPAREN</a> 
 */
net.sf.crsx.Sink N_RegExpSimple(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpSimple> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpSimple>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_RegExpLeaf(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpRef"), null)) ;
	}
	 ) 
	 ( 
	sink=N_FragmentRef(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpClass"), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpClass(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpAny"), null)) ;
	}
	 ) 
	 ( 
	 <T_DOT>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpClass"), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassChar"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		t=<T_ESCAPEDCHAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassDone"), null)) ;
	}
	 ) 
	{
		return sink .end().end().end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpNest"), null)) ;
	}
	 ) 
	 ( 
	 <T_LPAREN>
	 ) 
	 ( 
	sink=N_RegExp(sink, env)
	 ) 
	 ( 
	 <T_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>AttributeForm$WithEOF</em> ::= <em>AttributeForm</em> EOF . */
net.sf.crsx.Sink N_AttributeForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeForm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeForm production. */
TOKEN : {<MT_AttributeForm : "#AttributeForm" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeForm production. */
TOKEN : {<IT_AttributeForm : "%AttributeForm">}

/**
 * <em>AttributeForm</em> ::=  <font color="red">{AttributeFormSimple}</font><font color="red">:raw</font>    <a href="#T_LPAREN">LPAREN</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RPAREN">RPAREN</a>  <br>
 *  |   <a href="#T_LBRACE">LBRACE</a>   <a href="#N_Sort">&lang;Sort&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeFormMap}</font><font color="red">:raw</font>   <font color="red">{{#}}</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  |  <font color="red">{AttributeFormSet}</font><font color="red">:raw</font>   <font color="red">{{#}}</font>    <a href="#T_RBRACE">RBRACE</a>  ) 
 */
net.sf.crsx.Sink N_AttributeForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink bs__ = null;
	net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_AttributeForm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeForm>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("AttributeFormSimple"), null)) ;
	}
	 ) 
	 ( 
	 <T_LPAREN>
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	 <T_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_LBRACE>
	 ) 
	 ( 
	{
		bs__ = b__.sink();
	}
	N_Sort(bs__, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("AttributeFormMap"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__, true) ;
		}
		 ) 
		 ( 
		 <T_COLON>
		 ) 
		 ( 
		sink=N_Sort(sink, env)
		 ) 
		 ( 
		 <T_RBRACE>
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("AttributeFormSet"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__, true) ;
		}
		 ) 
		 ( 
		 <T_RBRACE>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>AttributeOptions$WithEOF</em> ::= <em>AttributeOptions</em> EOF . */
net.sf.crsx.Sink N_AttributeOptions$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeOptions(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeOptions production. */
TOKEN : {<MT_AttributeOptions : "#AttributeOptions" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeOptions production. */
TOKEN : {<IT_AttributeOptions : "%AttributeOptions">}

/**
 * <em>AttributeOptions</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_AttributeOption">&lang;AttributeOption&rang;</a>    <a href="#N_AttributeOptions">&lang;AttributeOptions&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_AttributeOptions(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_AttributeOptions> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeOptions>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_AttributeOption(sink, env)
	 ) 
	 ( 
	sink=N_AttributeOptions(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>AttributeOption$WithEOF</em> ::= <em>AttributeOption</em> EOF . */
net.sf.crsx.Sink N_AttributeOption$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeOption(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeOption production. */
TOKEN : {<MT_AttributeOption : "#AttributeOption" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeOption production. */
TOKEN : {<IT_AttributeOption : "%AttributeOption">}

/**
 * <em>AttributeOption</em> ::=  <font color="red">{AttributeOption}</font><font color="red">:raw</font>   <a href="#N_Variable">&lang;Variable&rang;</a>    <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_AttributeOption(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_AttributeOption> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeOption>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("AttributeOption"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Variable(sink, env)
	 ) 
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortNames$WithEOF</em> ::= <em>SortNames</em> EOF . */
net.sf.crsx.Sink N_SortNames$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortNames(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortNames production. */
TOKEN : {<MT_SortNames : "#SortNames" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortNames production. */
TOKEN : {<IT_SortNames : "%SortNames">}

/**
 * <em>SortNames</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SortName">&lang;SortName&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_SortNames">&lang;SortNames&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_SortNames(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SortNames> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortNames>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_SortName(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_SortNames(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortAbstraction$WithEOF</em> ::= <em>SortAbstraction</em> EOF . */
net.sf.crsx.Sink N_SortAbstraction$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortAbstraction(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortAbstraction production. */
TOKEN : {<MT_SortAbstraction : "#SortAbstraction" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortAbstraction production. */
TOKEN : {<IT_SortAbstraction : "%SortAbstraction">}

/**
 * <em>SortAbstraction</em> ::=  <font color="red">{SortAbstractionParam}</font><font color="red">:raw</font>   <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">^a</font>   <a href="#N_SortAbstraction">&lang;SortAbstraction&rang;</a> <font color="red">[a]</font>  <br>
 *  |  <font color="red">{SortAbstractionBody}</font><font color="red">:raw</font>   <a href="#N_SortAlternatives">&lang;SortAlternatives&rang;</a>  
 */
net.sf.crsx.Sink N_SortAbstraction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	String s_a = null;
	Token t = null;
	net.sf.crsx.Variable v_a = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_a = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs_a = null;
}
{
	t=<MT_SortAbstraction> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortAbstraction>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("SortAbstractionParam"), null)) ;
	}
	 ) 
	 ( 
	{
		bs_a = b_a.sink();
	}
	N_Variable(bs_a, env)
	{
		c0 = net.sf.crsx.util.Util.symbol(b_a.term(true));
		s_a = c0;
		v_a = sink.makeVariable(s_a,true);
	}
	 ) 
	 ( 
	{
		{
			net.sf.crsx.Variable[] bs1 = {v_a};
			sink = sink .binds(bs1) ;
		}
	}
	sink=N_SortAbstraction(sink, env.extend(s_a, v_a))
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("SortAbstractionBody"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortAlternatives(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortAlternatives$WithEOF</em> ::= <em>SortAlternatives</em> EOF . */
net.sf.crsx.Sink N_SortAlternatives$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortAlternatives(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortAlternatives production. */
TOKEN : {<MT_SortAlternatives : "#SortAlternatives" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortAlternatives production. */
TOKEN : {<IT_SortAlternatives : "%SortAlternatives">}

/**
 * <em>SortAlternatives</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SortAlternative">&lang;SortAlternative&rang;</a>    <a href="#N_SortAlternatives">&lang;SortAlternatives&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_SortAlternatives(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SortAlternatives> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortAlternatives>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_SortAlternative(sink, env)
	 ) 
	 ( 
	sink=N_SortAlternatives(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortAlternative$WithEOF</em> ::= <em>SortAlternative</em> EOF . */
net.sf.crsx.Sink N_SortAlternative$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortAlternative(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortAlternative production. */
TOKEN : {<MT_SortAlternative : "#SortAlternative" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortAlternative production. */
TOKEN : {<IT_SortAlternative : "%SortAlternative">}

/**
 * <em>SortAlternative</em> ::=   <a href="#T_BAR">BAR</a>   (   <a href="#T_SCHEME">SCHEME</a><font color="red">:raw</font>   <a href="#N_Form">&lang;Form&rang;</a>   |  <font color="red">{SynthesizedRef}</font><font color="red">:raw</font>    <a href="#T_UP">UP</a>   <a href="#N_AttributeName">&lang;AttributeName&rang;</a>   |   <a href="#T_SUGAR">SUGAR</a><font color="red">:raw</font>   <a href="#N_Form">&lang;Form&rang;</a>     <a href="#T_ARROW">ARROW</a>   <a href="#N_Term">&lang;Term&rang;</a>   |   <a href="#T_SYMBOL">SYMBOL</a><font color="red">:raw</font>   <a href="#N_Form">&lang;Form&rang;</a>   |   <a href="#T_STATIC">STATIC</a><font color="red">:raw</font>   (   <a href="#T_SYMBOL">SYMBOL</a>  )?   <a href="#N_Form">&lang;Form&rang;</a>   |  <font color="red">{data}</font><font color="red">:raw</font>   (   <a href="#T_DATA">DATA</a>  )?   <a href="#N_Form">&lang;Form&rang;</a>    <a href="#N_Tagging">&lang;Tagging&rang;</a>   ) 
 */
net.sf.crsx.Sink N_SortAlternative(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SortAlternative> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortAlternative>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	 <T_BAR>
	 ) 
	 ( 
		 ( 
		t=<T_SCHEME>
		{
			sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("SynthesizedRef"), null)) ;
		}
		 ) 
		 ( 
		 <T_UP>
		 ) 
		 ( 
		sink=N_AttributeName(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SUGAR>
		{
			sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		 ( 
		 <T_ARROW>
		 ) 
		 ( 
		sink=N_Term(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SYMBOL>
		{
			sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_STATIC>
		{
			sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_SYMBOL>
			 ) 
		 )? 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("data"), null)) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_DATA>
			 ) 
		 )? 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		 ( 
		sink=N_Tagging(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Form$WithEOF</em> ::= <em>Form</em> EOF . */
net.sf.crsx.Sink N_Form$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Form(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Form production. */
TOKEN : {<MT_Form : "#Form" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Form production. */
TOKEN : {<IT_Form : "%Form">}

/**
 * <em>Form</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a> <font color="red">:#C</font>   (  <font color="red">{FormParsedSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_FormPrec">&lang;FormPrec&rang;</a>    <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>   |  <font color="red">{FormConstruction}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_ScopeSorts">&lang;ScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>   )  <br>
 *  |  <font color="red">{FormParsedUnsorted}</font><font color="red">:raw</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_FormPrec">&lang;FormPrec&rang;</a>    <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>  
 */
net.sf.crsx.Sink N_Form(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
	Token t = null;
	net.sf.crsx.Sink bs__C = null;
}
{
	t=<MT_Form> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Form>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__C = b__C.sink();
	}
	N_Constructor(bs__C, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("FormParsedSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		 <T_CONCRETESTART>
		 ) 
		 ( 
		sink=N_ParsedForm(sink, env)
		 ) 
		 ( 
		 <T_CONCRETEEND>
		 ) 
		 ( 
		sink=N_FormPrec(sink, env)
		 ) 
		 ( 
		sink=N_InheritedRefs(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("FormConstruction"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_ScopeSorts(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_InheritedRefs(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("FormParsedUnsorted"), null)) ;
	}
	 ) 
	 ( 
	 <T_CONCRETESTART>
	 ) 
	 ( 
	sink=N_ParsedForm(sink, env)
	 ) 
	 ( 
	 <T_CONCRETEEND>
	 ) 
	 ( 
	sink=N_FormPrec(sink, env)
	 ) 
	 ( 
	sink=N_InheritedRefs(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>ScopeSorts$WithEOF</em> ::= <em>ScopeSorts</em> EOF . */
net.sf.crsx.Sink N_ScopeSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_ScopeSorts(sink, env) <EOF> {return sink;} }

/** Special meta-variable for ScopeSorts production. */
TOKEN : {<MT_ScopeSorts : "#ScopeSorts" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ScopeSorts production. */
TOKEN : {<IT_ScopeSorts : "%ScopeSorts">}

/**
 * <em>ScopeSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_ScopeSort">&lang;ScopeSort&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_ScopeSorts">&lang;ScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_ScopeSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_ScopeSorts> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ScopeSorts>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_ScopeSort(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_ScopeSorts(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>ScopeSort$WithEOF</em> ::= <em>ScopeSort</em> EOF . */
net.sf.crsx.Sink N_ScopeSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_ScopeSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for ScopeSort production. */
TOKEN : {<MT_ScopeSort : "#ScopeSort" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ScopeSort production. */
TOKEN : {<IT_ScopeSort : "%ScopeSort">}

/**
 * <em>ScopeSort</em> ::=  <font color="red">{ScopeSort}</font><font color="red">:raw</font>   <a href="#N_Sort">&lang;Sort&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_SubstituteSorts">&lang;SubstituteSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )  <br>
 *  |  <font color="red">{ScopeSortBinder}</font><font color="red">:raw</font>    <a href="#T_LBRACKET">LBRACKET</a>   <a href="#N_Variable">&lang;Variable&rang;</a>     <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RBRACKET">RBRACKET</a> 
 */
net.sf.crsx.Sink N_ScopeSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_ScopeSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ScopeSort>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ScopeSort"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	sink=N_Repeat(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_LBRACKET>
		 ) 
		 ( 
			 ( 
			sink=N_SubstituteSorts(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_RBRACKET>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ScopeSortBinder"), null)) ;
	}
	 ) 
	 ( 
	 <T_LBRACKET>
	 ) 
	 ( 
	sink=N_Variable(sink, env)
	 ) 
	 ( 
	 <T_COLON>
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	 <T_RBRACKET>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SubstituteSorts$WithEOF</em> ::= <em>SubstituteSorts</em> EOF . */
net.sf.crsx.Sink N_SubstituteSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SubstituteSorts(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SubstituteSorts production. */
TOKEN : {<MT_SubstituteSorts : "#SubstituteSorts" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SubstituteSorts production. */
TOKEN : {<IT_SubstituteSorts : "%SubstituteSorts">}

/**
 * <em>SubstituteSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SubstituteSort">&lang;SubstituteSort&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_SubstituteSorts">&lang;SubstituteSorts&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_SubstituteSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SubstituteSorts> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SubstituteSorts>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_SubstituteSort(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_SubstituteSorts(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SubstituteSort$WithEOF</em> ::= <em>SubstituteSort</em> EOF . */
net.sf.crsx.Sink N_SubstituteSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SubstituteSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SubstituteSort production. */
TOKEN : {<MT_SubstituteSort : "#SubstituteSort" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SubstituteSort production. */
TOKEN : {<IT_SubstituteSort : "%SubstituteSort">}

/**
 * <em>SubstituteSort</em> ::=  <font color="red">{SubstituteSort}</font><font color="red">:raw</font>   <a href="#N_Variable">&lang;Variable&rang;</a>     <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>  
 */
net.sf.crsx.Sink N_SubstituteSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SubstituteSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SubstituteSort>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("SubstituteSort"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Variable(sink, env)
	 ) 
	 ( 
	 <T_COLON>
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Sort$WithEOF</em> ::= <em>Sort</em> EOF . */
net.sf.crsx.Sink N_Sort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Sort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Sort production. */
TOKEN : {<MT_Sort : "#Sort" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Sort production. */
TOKEN : {<IT_Sort : "%Sort">}

/**
 * <em>Sort</em> ::=  <font color="red">{Sort}</font><font color="red">:raw</font>   <a href="#N_SimpleSort">&lang;SimpleSort&rang;</a>    <a href="#N_SimpleSorts">&lang;SimpleSorts&rang;</a>  
 */
net.sf.crsx.Sink N_Sort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Sort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Sort>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("Sort"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SimpleSort(sink, env)
	 ) 
	 ( 
	sink=N_SimpleSorts(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SimpleSorts$WithEOF</em> ::= <em>SimpleSorts</em> EOF . */
net.sf.crsx.Sink N_SimpleSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SimpleSorts(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SimpleSorts production. */
TOKEN : {<MT_SimpleSorts : "#SimpleSorts" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SimpleSorts production. */
TOKEN : {<IT_SimpleSorts : "%SimpleSorts">}

/**
 * <em>SimpleSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SimpleSort">&lang;SimpleSort&rang;</a>    <a href="#N_SimpleSorts">&lang;SimpleSorts&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_SimpleSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SimpleSorts> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SimpleSorts>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_SimpleSort(sink, env)
	 ) 
	 ( 
	sink=N_SimpleSorts(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SimpleSort$WithEOF</em> ::= <em>SimpleSort</em> EOF . */
net.sf.crsx.Sink N_SimpleSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SimpleSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SimpleSort production. */
TOKEN : {<MT_SimpleSort : "#SimpleSort" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SimpleSort production. */
TOKEN : {<IT_SimpleSort : "%SimpleSort">}

/**
 * <em>SimpleSort</em> ::=  <font color="red">{SortName}</font><font color="red">:raw</font>   <a href="#N_SortName">&lang;SortName&rang;</a>    <a href="#N_MetaVariables">&lang;MetaVariables&rang;</a>   <br>
 *  |  <font color="red">{SortParam}</font><font color="red">:raw</font>   <a href="#N_SortParam">&lang;SortParam&rang;</a>   <br>
 *  |   <a href="#T_LPAREN">LPAREN</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RPAREN">RPAREN</a> 
 */
net.sf.crsx.Sink N_SimpleSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SimpleSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SimpleSort>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("SortName"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortName(sink, env)
	 ) 
	 ( 
	sink=N_MetaVariables(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("SortParam"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortParam(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_LPAREN>
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	 <T_RPAREN>
	 ) 
	{return sink;}
}

/** <em>MetaVariables$WithEOF</em> ::= <em>MetaVariables</em> EOF . */
net.sf.crsx.Sink N_MetaVariables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_MetaVariables(sink, env) <EOF> {return sink;} }

/** Special meta-variable for MetaVariables production. */
TOKEN : {<MT_MetaVariables : "#MetaVariables" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token MetaVariables production. */
TOKEN : {<IT_MetaVariables : "%MetaVariables">}

/**
 * <em>MetaVariables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_MetaVariable">&lang;MetaVariable&rang;</a>    <font color="red">{$Nil}</font>  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_MetaVariables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_MetaVariables> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_MetaVariables>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_MetaVariable(sink, env)
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end().end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortParam$WithEOF</em> ::= <em>SortParam</em> EOF . */
net.sf.crsx.Sink N_SortParam$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortParam(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortParam production. */
TOKEN : {<MT_SortParam : "#SortParam" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortParam production. */
TOKEN : {<IT_SortParam : "%SortParam">}

/**
 * <em>SortParam</em> ::=  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!</font> 
 */
net.sf.crsx.Sink N_SortParam(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Variable v_Variable = null;
	String s_Variable = null;
	net.sf.crsx.Sink bs_Variable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_Variable = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_SortParam> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortParam>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs_Variable = b_Variable.sink();
	}
	N_Variable(bs_Variable, env)
	{
		c0 = net.sf.crsx.util.Util.symbol(b_Variable.term(true));
		s_Variable = c0;
		v_Variable = env.get(s_Variable);
		if (v_Variable == null) throw new ParseException("Variable "+s_Variable+" cannot be resolved?");
		sink = sink .use(v_Variable) ;
	}
	 ) 
	{return sink;}
}

/** <em>ParsedForm$WithEOF</em> ::= <em>ParsedForm</em> EOF . */
net.sf.crsx.Sink N_ParsedForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_ParsedForm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for ParsedForm production. */
TOKEN : {<MT_ParsedForm : "#ParsedForm" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ParsedForm production. */
TOKEN : {<IT_ParsedForm : "%ParsedForm">}

/**
 * <em>ParsedForm</em> ::=  <font color="red">{ParsedFormSpace}</font><font color="red">:raw</font>   <a href="#N_ConcreteSpace">&lang;ConcreteSpace&rang;</a>    <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormWord}</font><font color="red">:raw</font>   <a href="#N_ConcreteWord">&lang;ConcreteWord&rang;</a>    <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>   <br>
 *  |   <a href="#T_CONCRETEPUSH">CONCRETEPUSH</a>   <font color="red">{ParsedFormTerm}</font><font color="red">:raw</font>   <a href="#N_ScopeSort">&lang;ScopeSort&rang;</a>    <a href="#N_FormPrec">&lang;FormPrec&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>     <a href="#T_CONCRETEPOP">CONCRETEPOP</a>   <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormDone}</font><font color="red">:raw</font> 
 */
net.sf.crsx.Sink N_ParsedForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_ParsedForm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ParsedForm>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ParsedFormSpace"), null)) ;
	}
	 ) 
	 ( 
	sink=N_ConcreteSpace(sink, env)
	 ) 
	 ( 
	sink=N_ParsedForm(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ParsedFormWord"), null)) ;
	}
	 ) 
	 ( 
	sink=N_ConcreteWord(sink, env)
	 ) 
	 ( 
	sink=N_ParsedForm(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_CONCRETEPUSH>
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ParsedFormTerm"), null)) ;
	}
	 ) 
	 ( 
	sink=N_ScopeSort(sink, env)
	 ) 
	 ( 
	sink=N_FormPrec(sink, env)
	 ) 
	 ( 
	sink=N_Repeat(sink, env)
	 ) 
	 ( 
	 <T_CONCRETEPOP>
	 ) 
	 ( 
	sink=N_ParsedForm(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ParsedFormDone"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>FormPrec$WithEOF</em> ::= <em>FormPrec</em> EOF . */
net.sf.crsx.Sink N_FormPrec$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_FormPrec(sink, env) <EOF> {return sink;} }

/** Special meta-variable for FormPrec production. */
TOKEN : {<MT_FormPrec : "#FormPrec" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token FormPrec production. */
TOKEN : {<IT_FormPrec : "%FormPrec">}

/**
 * <em>FormPrec</em> ::=  (   <a href="#T_AT">AT</a>   <a href="#N_Natural">&lang;Natural&rang;</a>   |  <font color="red">{"0"}</font>  ) 
 */
net.sf.crsx.Sink N_FormPrec(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_FormPrec> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_FormPrec>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		 <T_AT>
		 ) 
		 ( 
		sink=N_Natural(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "0", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Tagging$WithEOF</em> ::= <em>Tagging</em> EOF . */
net.sf.crsx.Sink N_Tagging$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Tagging(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Tagging production. */
TOKEN : {<MT_Tagging : "#Tagging" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Tagging production. */
TOKEN : {<IT_Tagging : "%Tagging">}

/**
 * <em>Tagging</em> ::=  (  <font color="red">{$Cons}</font>    <a href="#T_TAG">TAG</a>   <a href="#N_Constructor">&lang;Constructor&rang;</a>    (  <font color="red">{$Nil}</font>  )  |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Tagging(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Tagging> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Tagging>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		 <T_TAG>
		 ) 
		 ( 
		sink=N_Constructor(sink, env)
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>InheritedRefs$WithEOF</em> ::= <em>InheritedRefs</em> EOF . */
net.sf.crsx.Sink N_InheritedRefs$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_InheritedRefs(sink, env) <EOF> {return sink;} }

/** Special meta-variable for InheritedRefs production. */
TOKEN : {<MT_InheritedRefs : "#InheritedRefs" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token InheritedRefs production. */
TOKEN : {<IT_InheritedRefs : "%InheritedRefs">}

/**
 * <em>InheritedRefs</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_InheritedRef">&lang;InheritedRef&rang;</a>    <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_InheritedRefs(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_InheritedRefs> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_InheritedRefs>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		sink=N_InheritedRef(sink, env)
		 ) 
		 ( 
		sink=N_InheritedRefs(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>InheritedRef$WithEOF</em> ::= <em>InheritedRef</em> EOF . */
net.sf.crsx.Sink N_InheritedRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_InheritedRef(sink, env) <EOF> {return sink;} }

/** Special meta-variable for InheritedRef production. */
TOKEN : {<MT_InheritedRef : "#InheritedRef" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token InheritedRef production. */
TOKEN : {<IT_InheritedRef : "%InheritedRef">}

/**
 * <em>InheritedRef</em> ::=  <font color="red">{InheritedRef}</font><font color="red">:raw</font>    <a href="#T_DOWN">DOWN</a>   <a href="#N_AttributeName">&lang;AttributeName&rang;</a>  
 */
net.sf.crsx.Sink N_InheritedRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_InheritedRef> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_InheritedRef>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("InheritedRef"), null)) ;
	}
	 ) 
	 ( 
	 <T_DOWN>
	 ) 
	 ( 
	sink=N_AttributeName(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Rule$WithEOF</em> ::= <em>Rule</em> EOF . */
net.sf.crsx.Sink N_Rule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Rule(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Rule production. */
TOKEN : {<MT_Rule : "#Rule" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Rule production. */
TOKEN : {<IT_Rule : "%Rule">}

/**
 * <em>Rule</em> ::=  <font color="red">{Rule}</font><font color="red">:raw</font>   <a href="#N_Priority">&lang;Priority&rang;</a>    <a href="#N_Construction">&lang;Construction&rang;</a> <font color="red">:#first</font>   (   <a href="#T_COLON">COLON</a>   <font color="red">{{#first}}</font>   <a href="#N_Construction">&lang;Construction&rang;</a>   |  <font color="red">{{OMITTED}}</font>   <font color="red">{{#first}}</font>  )   (   <a href="#T_ARROW">ARROW</a>   <a href="#N_Term">&lang;Term&rang;</a>   |  <font color="red">{{OMITTED}}</font>  ) 
 */
net.sf.crsx.Sink N_Rule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__first = new net.sf.crsx.util.Buffer(sink);
	Token t = null;
	net.sf.crsx.Sink bs__first = null;
}
{
	t=<MT_Rule> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Rule>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("Rule"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Priority(sink, env)
	 ) 
	 ( 
	{
		bs__first = b__first.sink();
	}
	N_Construction(bs__first, env)
	 ) 
	 ( 
		 ( 
		 <T_COLON>
		 ) 
		 ( 
		{
			sink = sink .copy(b__first, true) ;
		}
		 ) 
		 ( 
		sink=N_Construction(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(sink.makeConstructor("OMITTED")) .end() ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__first, true) ;
		}
		 ) 
	 ) 
	 ( 
		 ( 
		 <T_ARROW>
		 ) 
		 ( 
		sink=N_Term(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(sink.makeConstructor("OMITTED")) .end() ;
		}
		 ) 
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Priority$WithEOF</em> ::= <em>Priority</em> EOF . */
net.sf.crsx.Sink N_Priority$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Priority(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Priority production. */
TOKEN : {<MT_Priority : "#Priority" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Priority production. */
TOKEN : {<IT_Priority : "%Priority">}

/**
 * <em>Priority</em> ::=  (   <a href="#T_DEFAULT">DEFAULT</a><font color="red">:raw</font>  |   <a href="#T_PRIORITY">PRIORITY</a><font color="red">:raw</font>  |  <font color="red">{Normal}</font><font color="red">:raw</font>  ) 
 */
net.sf.crsx.Sink N_Priority(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Priority> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Priority>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_DEFAULT>
		{
			sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_PRIORITY>
		{
			sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("Normal"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Term$WithEOF</em> ::= <em>Term</em> EOF . */
net.sf.crsx.Sink N_Term$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Term(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Term production. */
TOKEN : {<MT_Term : "#Term" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Term production. */
TOKEN : {<IT_Term : "%Term">}

/**
 * <em>Term</em> ::=  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">:#v</font>   (  <font color="red">{Special}</font><font color="red">:raw</font>   <font color="red">{{#v}}</font>   <a href="#N_Term">&lang;Term&rang;</a>   |  <font color="red">{VariableUse}</font><font color="red">:raw</font>   <font color="red">{{#v}}</font>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   )  <br>
 *  |  <a href="#N_NotVariableTerm">&lang;NotVariableTerm&rang;</a>  
 */
net.sf.crsx.Sink N_Term(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__v = null;
}
{
	t=<MT_Term> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Term>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__v = b__v.sink();
	}
	N_Variable(bs__v, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("Special"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__v, true) ;
		}
		 ) 
		 ( 
		sink=N_Term(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("VariableUse"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__v, true) ;
		}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_NotVariableTerm(sink, env)
	 ) 
	{return sink;}
}

/** <em>NotVariableTerm$WithEOF</em> ::= <em>NotVariableTerm</em> EOF . */
net.sf.crsx.Sink N_NotVariableTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_NotVariableTerm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for NotVariableTerm production. */
TOKEN : {<MT_NotVariableTerm : "#NotVariableTerm" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token NotVariableTerm production. */
TOKEN : {<IT_NotVariableTerm : "%NotVariableTerm">}

/**
 * <em>NotVariableTerm</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a> <font color="red">:#C</font>   <a href="#N_Repeat">&lang;Repeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{ParsedSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{MetaApplicationSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_MetaVariable">&lang;MetaVariable&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Terms">&lang;Terms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Constructor">&lang;Constructor&rang;</a>    (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{VariableUseSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Variable">&lang;Variable&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:raw</font>   <a href="#N_Literal">&lang;Literal&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   <br>
 *  |  <font color="red">{Parsed}</font><font color="red">:raw</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   <br>
 *  |  <font color="red">{MetaApplication}</font><font color="red">:raw</font>   <a href="#N_MetaVariable">&lang;MetaVariable&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Terms">&lang;Terms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>  
 */
net.sf.crsx.Sink N_NotVariableTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
	Token t = null;
	net.sf.crsx.Sink bs__C = null;
	net.sf.crsx.Sink bs__R = null;
}
{
	t=<MT_NotVariableTerm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_NotVariableTerm>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__C = b__C.sink();
	}
	N_Constructor(bs__C, env)
	 ) 
	 ( 
	{
		bs__R = b__R.sink();
	}
	N_Repeat(bs__R, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("ParsedSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		 <T_CONCRETESTART>
		 ) 
		 ( 
		sink=N_Parsed(sink, env)
		 ) 
		 ( 
		 <T_CONCRETEEND>
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("MetaApplicationSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_MetaVariable(sink, env)
		 ) 
		 ( 
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Terms(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("ConstructionSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_Constructor(sink, env)
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("VariableUseSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_Variable(sink, env)
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("Construction"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("Literal"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Literal(sink, env)
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("Parsed"), null)) ;
	}
	 ) 
	 ( 
	 <T_CONCRETESTART>
	 ) 
	 ( 
	sink=N_Parsed(sink, env)
	 ) 
	 ( 
	 <T_CONCRETEEND>
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("MetaApplication"), null)) ;
	}
	 ) 
	 ( 
	sink=N_MetaVariable(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_LBRACKET>
		 ) 
		 ( 
			 ( 
			sink=N_Terms(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_RBRACKET>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for Construction production. */
TOKEN : {<MT_Construction : "#Construction" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Construction production. */
TOKEN : {<IT_Construction : "%Construction">}

/**
 * <em>Construction</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a> <font color="red">:#C</font>   <a href="#N_Repeat">&lang;Repeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{ParsedSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Constructor">&lang;Constructor&rang;</a>    (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:raw</font>   <a href="#N_Literal">&lang;Literal&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   <br>
 *  |  <font color="red">{Parsed}</font><font color="red">:raw</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_Attributes">&lang;Attributes&rang;</a>  
 */
net.sf.crsx.Sink N_Construction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
	Token t = null;
	net.sf.crsx.Sink bs__C = null;
	net.sf.crsx.Sink bs__R = null;
}
{
	t=<MT_Construction> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Construction>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__C = b__C.sink();
	}
	N_Constructor(bs__C, env)
	 ) 
	 ( 
	{
		bs__R = b__R.sink();
	}
	N_Repeat(bs__R, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("ParsedSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		 <T_CONCRETESTART>
		 ) 
		 ( 
		sink=N_Parsed(sink, env)
		 ) 
		 ( 
		 <T_CONCRETEEND>
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("ConstructionSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_Constructor(sink, env)
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("Construction"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("Literal"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Literal(sink, env)
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("Parsed"), null)) ;
	}
	 ) 
	 ( 
	 <T_CONCRETESTART>
	 ) 
	 ( 
	sink=N_Parsed(sink, env)
	 ) 
	 ( 
	 <T_CONCRETEEND>
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Scopes$WithEOF</em> ::= <em>Scopes</em> EOF . */
net.sf.crsx.Sink N_Scopes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Scopes(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Scopes production. */
TOKEN : {<MT_Scopes : "#Scopes" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Scopes production. */
TOKEN : {<IT_Scopes : "%Scopes">}

/**
 * <em>Scopes</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Scope">&lang;Scope&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Scopes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Scopes> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Scopes>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_Scope(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_Scopes(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Scope$WithEOF</em> ::= <em>Scope</em> EOF . */
net.sf.crsx.Sink N_Scope$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Scope(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Scope production. */
TOKEN : {<MT_Scope : "#Scope" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Scope production. */
TOKEN : {<IT_Scope : "%Scope">}

/**
 * <em>Scope</em> ::=  <font color="red">{Scope}</font><font color="red">:raw</font>   (  <font color="red">{$Nil}</font>  )   <a href="#N_NotVariableTerm">&lang;NotVariableTerm&rang;</a>   <br>
 *  |  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">:#v</font>   (  <font color="red">{Scope}</font><font color="red">:raw</font>   (  <font color="red">{$Cons}</font>   <font color="red">{{#v}}</font>   <a href="#N_Variables">&lang;Variables&rang;</a>   )    <a href="#T_DOT">DOT</a>   <a href="#N_Term">&lang;Term&rang;</a>   |  <font color="red">{Scope}</font><font color="red">:raw</font>   (  <font color="red">{$Nil}</font>  )   (  <font color="red">{VariableUse}</font><font color="red">:raw</font>   <font color="red">{{#v}}</font>  )  )  <br>
 *  |  <font color="red">{Scope}</font><font color="red">:raw</font>    <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_VariableList">&lang;VariableList&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>   <a href="#N_Term">&lang;Term&rang;</a>  
 */
net.sf.crsx.Sink N_Scope(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__v = null;
}
{
	t=<MT_Scope> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Scope>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("Scope"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_NotVariableTerm(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		bs__v = b__v.sink();
	}
	N_Variable(bs__v, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("Scope"), null)) ;
		}
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
			}
			 ) 
			 ( 
			{
				sink = sink .copy(b__v, true) ;
			}
			 ) 
			 ( 
			sink=N_Variables(sink, env)
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_DOT>
		 ) 
		 ( 
		sink=N_Term(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("Scope"), null)) ;
		}
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, raw("VariableUse"), null)) ;
			}
			 ) 
			 ( 
			{
				sink = sink .copy(b__v, true) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("Scope"), null)) ;
	}
	 ) 
	 ( 
	 <T_LBRACKET>
	 ) 
	 ( 
		 ( 
		sink=N_VariableList(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	 <T_RBRACKET>
	 ) 
	 ( 
	sink=N_Term(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Variables$WithEOF</em> ::= <em>Variables</em> EOF . */
net.sf.crsx.Sink N_Variables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Variables(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Variables production. */
TOKEN : {<MT_Variables : "#Variables" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Variables production. */
TOKEN : {<IT_Variables : "%Variables">}

/**
 * <em>Variables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Variable">&lang;Variable&rang;</a>    <a href="#N_Variables">&lang;Variables&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_Variables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Variables> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Variables>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_Variable(sink, env)
	 ) 
	 ( 
	sink=N_Variables(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for VariableList production. */
TOKEN : {<MT_VariableList : "#VariableList" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token VariableList production. */
TOKEN : {<IT_VariableList : "%VariableList">}

/**
 * <em>VariableList</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Variable">&lang;Variable&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_VariableList">&lang;VariableList&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_VariableList(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_VariableList> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_VariableList>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_Variable(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_VariableList(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Terms$WithEOF</em> ::= <em>Terms</em> EOF . */
net.sf.crsx.Sink N_Terms$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Terms(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Terms production. */
TOKEN : {<MT_Terms : "#Terms" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Terms production. */
TOKEN : {<IT_Terms : "%Terms">}

/**
 * <em>Terms</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Term">&lang;Term&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_Terms">&lang;Terms&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Terms(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Terms> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Terms>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_Term(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_Terms(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Parsed$WithEOF</em> ::= <em>Parsed</em> EOF . */
net.sf.crsx.Sink N_Parsed$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Parsed(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Parsed production. */
TOKEN : {<MT_Parsed : "#Parsed" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Parsed production. */
TOKEN : {<IT_Parsed : "%Parsed">}

/**
 * <em>Parsed</em> ::=   <a href="#T_CONCRETESPACE">CONCRETESPACE</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>   <br>
 *  |  <font color="red">{ParsedWord}</font><font color="red">:raw</font>   <a href="#N_ConcreteWord">&lang;ConcreteWord&rang;</a>    <a href="#N_Parsed">&lang;Parsed&rang;</a>   <br>
 *  |   <a href="#T_CONCRETEPUSH">CONCRETEPUSH</a>   <font color="red">{ParsedTerm}</font><font color="red">:raw</font>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_CONCRETEPOP">CONCRETEPOP</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>   <br>
 *  |  <font color="red">{ParsedDone}</font><font color="red">:raw</font> 
 */
net.sf.crsx.Sink N_Parsed(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Parsed> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Parsed>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	 <T_CONCRETESPACE>
	 ) 
	 ( 
	sink=N_Parsed(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ParsedWord"), null)) ;
	}
	 ) 
	 ( 
	sink=N_ConcreteWord(sink, env)
	 ) 
	 ( 
	sink=N_Parsed(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_CONCRETEPUSH>
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ParsedTerm"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Term(sink, env)
	 ) 
	 ( 
	 <T_CONCRETEPOP>
	 ) 
	 ( 
	sink=N_Parsed(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("ParsedDone"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Attributes$WithEOF</em> ::= <em>Attributes</em> EOF . */
net.sf.crsx.Sink N_Attributes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Attributes(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Attributes production. */
TOKEN : {<MT_Attributes : "#Attributes" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Attributes production. */
TOKEN : {<IT_Attributes : "%Attributes">}

/**
 * <em>Attributes</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_Attribute">&lang;Attribute&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Attributes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Attributes> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Attributes>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		sink=N_Attribute(sink, env)
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Attribute$WithEOF</em> ::= <em>Attribute</em> EOF . */
net.sf.crsx.Sink N_Attribute$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Attribute(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Attribute production. */
TOKEN : {<MT_Attribute : "#Attribute" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Attribute production. */
TOKEN : {<IT_Attribute : "%Attribute">}

/**
 * <em>Attribute</em> ::=  <font color="red">{Attribute}</font><font color="red">:raw</font>   <a href="#N_AttributeKind">&lang;AttributeKind&rang;</a>    <a href="#N_AttributeName">&lang;AttributeName&rang;</a>    <a href="#N_AttributeValue">&lang;AttributeValue&rang;</a>  
 */
net.sf.crsx.Sink N_Attribute(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Attribute> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Attribute>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("Attribute"), null)) ;
	}
	 ) 
	 ( 
	sink=N_AttributeKind(sink, env)
	 ) 
	 ( 
	sink=N_AttributeName(sink, env)
	 ) 
	 ( 
	sink=N_AttributeValue(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>AttributeKind$WithEOF</em> ::= <em>AttributeKind</em> EOF . */
net.sf.crsx.Sink N_AttributeKind$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeKind(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeKind production. */
TOKEN : {<MT_AttributeKind : "#AttributeKind" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeKind production. */
TOKEN : {<IT_AttributeKind : "%AttributeKind">}

/**
 * <em>AttributeKind</em> ::=  (  <font color="red">{AttributeKindUp}</font><font color="red">:raw</font>    <a href="#T_UP">UP</a>  |  <font color="red">{AttributeKindDown}</font><font color="red">:raw</font>    <a href="#T_DOWN">DOWN</a>  ) 
 */
net.sf.crsx.Sink N_AttributeKind(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_AttributeKind> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeKind>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("AttributeKindUp"), null)) ;
		}
		 ) 
		 ( 
		 <T_UP>
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("AttributeKindDown"), null)) ;
		}
		 ) 
		 ( 
		 <T_DOWN>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>AttributeValue$WithEOF</em> ::= <em>AttributeValue</em> EOF . */
net.sf.crsx.Sink N_AttributeValue$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeValue(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeValue production. */
TOKEN : {<MT_AttributeValue : "#AttributeValue" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeValue production. */
TOKEN : {<IT_AttributeValue : "%AttributeValue">}

/**
 * <em>AttributeValue</em> ::=  <font color="red">{AttributeValue}</font><font color="red">:raw</font>    <a href="#T_LPAREN">LPAREN</a>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_RPAREN">RPAREN</a>  <br>
 *  |   <a href="#T_LBRACE">LBRACE</a>   (  <a href="#N_Term">&lang;Term&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeKeyValue}</font><font color="red">:raw</font>   <font color="red">{{#}}</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  |  <font color="red">{AttributeKey}</font><font color="red">:raw</font>   <font color="red">{{#}}</font>    <a href="#T_RBRACE">RBRACE</a>  )  |  <font color="red">{AttributeNotKey}</font><font color="red">:raw</font>    <a href="#T_NOT">NOT</a>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  ) 
 */
net.sf.crsx.Sink N_AttributeValue(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink bs__ = null;
	net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_AttributeValue> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeValue>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("AttributeValue"), null)) ;
	}
	 ) 
	 ( 
	 <T_LPAREN>
	 ) 
	 ( 
	sink=N_Term(sink, env)
	 ) 
	 ( 
	 <T_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_LBRACE>
	 ) 
	 ( 
		 ( 
		{
			bs__ = b__.sink();
		}
		N_Term(bs__, env)
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, raw("AttributeKeyValue"), null)) ;
			}
			 ) 
			 ( 
			{
				sink = sink .copy(b__, true) ;
			}
			 ) 
			 ( 
			 <T_COLON>
			 ) 
			 ( 
			sink=N_Term(sink, env)
			 ) 
			 ( 
			 <T_RBRACE>
			 ) 
			{
				sink = sink .end() ;
			}
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, raw("AttributeKey"), null)) ;
			}
			 ) 
			 ( 
			{
				sink = sink .copy(b__, true) ;
			}
			 ) 
			 ( 
			 <T_RBRACE>
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("AttributeNotKey"), null)) ;
		}
		 ) 
		 ( 
		 <T_NOT>
		 ) 
		 ( 
		sink=N_Term(sink, env)
		 ) 
		 ( 
		 <T_RBRACE>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** Special meta-variable for ConcreteSpace production. */
TOKEN : {<MT_ConcreteSpace : "#ConcreteSpace" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ConcreteSpace production. */
TOKEN : {<IT_ConcreteSpace : "%ConcreteSpace">}

/**
 * <em>ConcreteSpace</em> ::=   <a href="#T_CONCRETESPACE">CONCRETESPACE</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_ConcreteSpace(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_ConcreteSpace> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ConcreteSpace>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_CONCRETESPACE>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for ConcreteWord production. */
TOKEN : {<MT_ConcreteWord : "#ConcreteWord" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ConcreteWord production. */
TOKEN : {<IT_ConcreteWord : "%ConcreteWord">}

/**
 * <em>ConcreteWord</em> ::=   <a href="#T_CONCRETEWORD">CONCRETEWORD</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_ConcreteWord(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_ConcreteWord> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ConcreteWord>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_CONCRETEWORD>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

// Nested comments JavaCC hack...
TOKEN_MGR_DECLS : { int commentNesting ; int commentState; }
<DEFAULT,RE> SKIP : { "/*" { commentNesting = 1; commentState = curLexState; } : NESTED_COMMENT }
<NESTED_COMMENT> SKIP : { "/*" { commentNesting += 1; } }
<NESTED_COMMENT> SKIP : { "*/" { commentNesting -= 1; if (commentNesting<=0) SwitchTo(commentState); } }
<NESTED_COMMENT> SKIP : { < ~[] > }


/** <em>ModuleName$WithEOF</em> ::= <em>ModuleName</em> EOF . */
net.sf.crsx.Sink N_ModuleName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_ModuleName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for ModuleName production. */
TOKEN : {<MT_ModuleName : "#ModuleName" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ModuleName production. */
TOKEN : {<IT_ModuleName : "%ModuleName">}

/**
 * <em>ModuleName</em> ::=  <a href="#N_String">&lang;String&rang;</a>   <br>
 *  |  <a href="#N_Variable">&lang;Variable&rang;</a>   <br>
 *  |  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_ModuleName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_ModuleName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ModuleName>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_String(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_Variable(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{return sink;}
}

/** <em>SortName$WithEOF</em> ::= <em>SortName</em> EOF . */
net.sf.crsx.Sink N_SortName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_SortName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortName production. */
<DEFAULT, RE> TOKEN : {<MT_SortName : "#SortName" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortName production. */
<DEFAULT, RE> TOKEN : {<IT_SortName : "%SortName">}

/**
 * <em>SortName</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_SortName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SortName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortName>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{return sink;}
}

/** <em>FragmentName$WithEOF</em> ::= <em>FragmentName</em> EOF . */
net.sf.crsx.Sink N_FragmentName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_FragmentName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for FragmentName production. */
<RE> TOKEN : {<MT_FragmentName : "#FragmentName" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token FragmentName production. */
<RE> TOKEN : {<IT_FragmentName : "%FragmentName">}

/**
 * <em>FragmentName</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_FragmentName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_FragmentName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_FragmentName>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{return sink;}
}

/** <em>FragmentRef$WithEOF</em> ::= <em>FragmentRef</em> EOF . */
net.sf.crsx.Sink N_FragmentRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_FragmentRef(sink, env) <EOF> {return sink;} }

/** Special meta-variable for FragmentRef production. */
<DEFAULT, RE> TOKEN : {<MT_FragmentRef : "#FragmentRef" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token FragmentRef production. */
<DEFAULT, RE> TOKEN : {<IT_FragmentRef : "%FragmentRef">}

/**
 * <em>FragmentRef</em> ::=   <a href="#T_FRAGMENT_REF">FRAGMENT_REF</a><font color="red">$:unembed</font> 
 */
net.sf.crsx.Sink N_FragmentRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_FragmentRef> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_FragmentRef>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_FRAGMENT_REF>
	{
		sink = sink .start(makeTConstructor(sink, t, unembed(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>AttributeName$WithEOF</em> ::= <em>AttributeName</em> EOF . */
net.sf.crsx.Sink N_AttributeName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeName production. */
TOKEN : {<MT_AttributeName : "#AttributeName" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeName production. */
TOKEN : {<IT_AttributeName : "%AttributeName">}

/**
 * <em>AttributeName</em> ::=  <a href="#N_Literal">&lang;Literal&rang;</a>   <br>
 *  |  <a href="#N_Variable">&lang;Variable&rang;</a>   <br>
 *  |  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_AttributeName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_AttributeName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeName>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_Literal(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_Variable(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{return sink;}
}

/** <em>Constructor$WithEOF</em> ::= <em>Constructor</em> EOF . */
net.sf.crsx.Sink N_Constructor$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Constructor(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Constructor production. */
TOKEN : {<MT_Constructor : "#Constructor" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Constructor production. */
TOKEN : {<IT_Constructor : "%Constructor">}

/**
 * <em>Constructor</em> ::=  (   <a href="#T_UPPER">UPPER</a><font color="red">$</font>  |   <a href="#T_DASH">DASH</a><font color="red">$</font>  |   <a href="#T_CON">CON</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_Constructor(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Constructor> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Constructor>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_UPPER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CON>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Variable$WithEOF</em> ::= <em>Variable</em> EOF . */
net.sf.crsx.Sink N_Variable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Variable(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Variable production. */
TOKEN : {<MT_Variable : "#Variable" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Variable production. */
TOKEN : {<IT_Variable : "%Variable">}

/**
 * <em>Variable</em> ::=  (   <a href="#T_LOWER">LOWER</a><font color="red">$</font>  |   <a href="#T_VAR">VAR</a><font color="red">$</font>  |   <a href="#T_MODULE">MODULE</a><font color="red">$</font>  |   <a href="#T_SORT">SORT</a><font color="red">$</font>  |   <a href="#T_DATA">DATA</a><font color="red">$</font>  |   <a href="#T_STATIC">STATIC</a><font color="red">$</font>  |   <a href="#T_SYMBOL">SYMBOL</a><font color="red">$</font>  |   <a href="#T_SCHEME">SCHEME</a><font color="red">$</font>  |   <a href="#T_AUTOMATIC">AUTOMATIC</a><font color="red">$</font>  |   <a href="#T_ATTRIBUTE">ATTRIBUTE</a><font color="red">$</font>  |   <a href="#T_COMPOSE">COMPOSE</a><font color="red">$</font>  |   <a href="#T_SUGAR">SUGAR</a><font color="red">$</font>  |   <a href="#T_RULE">RULE</a><font color="red">$</font>  |   <a href="#T_PRIORITY">PRIORITY</a><font color="red">$</font>  |   <a href="#T_DEFAULT">DEFAULT</a><font color="red">$</font>  |   <a href="#T_SPACE">SPACE</a><font color="red">$</font>  |   <a href="#T_IMPORT">IMPORT</a><font color="red">$</font>  |   <a href="#T_TOKEN">TOKEN</a><font color="red">$</font>  |   <a href="#T_LEXER">LEXER</a><font color="red">$</font>  |   <a href="#T_FRAGMENT">FRAGMENT</a><font color="red">$</font>  |   <a href="#T_NESTED">NESTED</a><font color="red">$</font>  |   <a href="#T_TAG">TAG</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_Variable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Variable> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Variable>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_LOWER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_VAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_MODULE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SORT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DATA>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_STATIC>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SYMBOL>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SCHEME>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_AUTOMATIC>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_ATTRIBUTE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_COMPOSE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SUGAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_RULE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_PRIORITY>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DEFAULT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SPACE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_IMPORT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_TOKEN>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_LEXER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_FRAGMENT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_NESTED>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_TAG>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>MetaVariable$WithEOF</em> ::= <em>MetaVariable</em> EOF . */
net.sf.crsx.Sink N_MetaVariable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_MetaVariable(sink, env) <EOF> {return sink;} }

/** Special meta-variable for MetaVariable production. */
TOKEN : {<MT_MetaVariable : "#MetaVariable" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token MetaVariable production. */
TOKEN : {<IT_MetaVariable : "%MetaVariable">}

/**
 * <em>MetaVariable</em> ::=  (   <a href="#T_META">META</a><font color="red">$</font>  |   <a href="#T_HASH">HASH</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_MetaVariable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_MetaVariable> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_MetaVariable>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_META>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** Special meta-variable for Separator production. */
TOKEN : {<MT_Separator : "#Separator" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Separator production. */
TOKEN : {<IT_Separator : "%Separator">}

/**
 * <em>Separator</em> ::=  (   <a href="#T_BAR">BAR</a><font color="red">$</font>  |   <a href="#T_SEMI">SEMI</a><font color="red">$</font>  |   <a href="#T_COMMA">COMMA</a><font color="red">$</font>  |   <a href="#T_COLON">COLON</a><font color="red">$</font>  |   <a href="#T_STAR">STAR</a><font color="red">$</font>  |   <a href="#T_DOT">DOT</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_Separator(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Separator> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Separator>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_BAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SEMI>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_COMMA>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_COLON>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_STAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DOT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Literal$WithEOF</em> ::= <em>Literal</em> EOF . */
net.sf.crsx.Sink N_Literal$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Literal(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Literal production. */
TOKEN : {<MT_Literal : "#Literal" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Literal production. */
TOKEN : {<IT_Literal : "%Literal">}

/**
 * <em>Literal</em> ::=  <a href="#N_String">&lang;String&rang;</a>   <br>
 *  |  <a href="#N_Number">&lang;Number&rang;</a>  
 */
net.sf.crsx.Sink N_Literal(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Literal> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Literal>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_String(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_Number(sink, env)
	 ) 
	{return sink;}
}

/** Special meta-variable for Number production. */
TOKEN : {<MT_Number : "#Number" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Number production. */
TOKEN : {<IT_Number : "%Number">}

/**
 * <em>Number</em> ::=  <a href="#N_Natural">&lang;Natural&rang;</a>   <br>
 *  |   <a href="#T_UNNATURAL">UNNATURAL</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_Number(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Number> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Number>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_Natural(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	t=<T_UNNATURAL>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for Natural production. */
TOKEN : {<MT_Natural : "#Natural" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Natural production. */
TOKEN : {<IT_Natural : "%Natural">}

/**
 * <em>Natural</em> ::=   <a href="#T_DIGIT">DIGIT</a><font color="red">$</font>  <br>
 *  |   <a href="#T_NATURAL">NATURAL</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_Natural(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Natural> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Natural>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_DIGIT>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_NATURAL>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for String production. */
<DEFAULT, RE> TOKEN : {<MT_String : "#String" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token String production. */
<DEFAULT, RE> TOKEN : {<IT_String : "%String">}

/**
 * <em>String</em> ::=   <a href="#T_STRING">STRING</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_String(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_String> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_String>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_STRING>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Word$WithEOF</em> ::= <em>Word</em> EOF . */
net.sf.crsx.Sink N_Word$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_Word(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Word production. */
<DEFAULT, RE> TOKEN : {<MT_Word : "#Word" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Word production. */
<DEFAULT, RE> TOKEN : {<IT_Word : "%Word">}

/**
 * <em>Word</em> ::=  (   <a href="#T_UPPER">UPPER</a><font color="red">$</font>  |   <a href="#T_DASH">DASH</a><font color="red">$</font>  |   <a href="#T_CON">CON</a><font color="red">$</font>  |   <a href="#T_WORD">WORD</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_Word(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Word> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Word>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_UPPER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CON>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_WORD>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>RegExpClass$WithEOF</em> ::= <em>RegExpClass</em> EOF . */
net.sf.crsx.Sink N_RegExpClass$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpClass(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpClass production. */
<RE> TOKEN : {<MT_RegExpClass : "#RegExpClass" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpClass production. */
<RE> TOKEN : {<IT_RegExpClass : "%RegExpClass">}

/**
 * <em>RegExpClass</em> ::=   <a href="#T_CHAR_CLASS">CHAR_CLASS</a><font color="red">$$:unembed:{rawCC}</font> 
 */
net.sf.crsx.Sink N_RegExpClass(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpClass> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpClass>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_CHAR_CLASS>
	{
		try {sink = factory.parser(factory).parse(sink, "rawCC", new java.io.StringReader(unembed(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

/** <em>CC$WithEOF</em> ::= <em>CC</em> EOF . */
net.sf.crsx.Sink N_CC$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC production. */
<CC> TOKEN : {<MT_CC : "#CC" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC production. */
<CC> TOKEN : {<IT_CC : "%CC">}

/**
 * <em>CC</em> ::=  <a href="#N_CC_RangesTop">&lang;CC_RangesTop&rang;</a>  
 */
net.sf.crsx.Sink N_CC(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_CC> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_CC_RangesTop(sink, env)
	 ) 
	{return sink;}
}

/** <em>CC_RangesTop$WithEOF</em> ::= <em>CC_RangesTop</em> EOF . */
net.sf.crsx.Sink N_CC_RangesTop$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_RangesTop(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_RangesTop production. */
<CC> TOKEN : {<MT_CC_RangesTop : "#CC_RangesTop" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_RangesTop production. */
<CC> TOKEN : {<IT_CC_RangesTop : "%CC_RangesTop">}

/**
 * <em>CC_RangesTop</em> ::=  <font color="red">{RegExpClassNot}</font><font color="red">:raw</font>    <a href="#T_CC_NOT">CC_NOT</a>   <a href="#N_CC_FirstRangeStartChar">&lang;CC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>   <br>
 *  |  <a href="#N_CC_FirstRangeStartChar">&lang;CC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>  
 */
net.sf.crsx.Sink N_CC_RangesTop(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink s1 = null;
	net.sf.crsx.Sink bs__lo = null;
	net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_CC_RangesTop> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_RangesTop>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassNot"), null)) ;
	}
	 ) 
	 ( 
	 <T_CC_NOT>
	 ) 
	 ( 
	{
		bs__lo = b__lo.sink();
	}
	N_CC_FirstRangeStartChar(bs__lo, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, true) ;
	}
	sink=N_CC_RangeTail(sink, env, b1)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		bs__lo = b__lo.sink();
	}
	N_CC_FirstRangeStartChar(bs__lo, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, true) ;
	}
	sink=N_CC_RangeTail(sink, env, b1)
	 ) 
	{return sink;}
}

/** <em>CC_Ranges$WithEOF</em> ::= <em>CC_Ranges</em> EOF . */
net.sf.crsx.Sink N_CC_Ranges$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_Ranges(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_Ranges production. */
<CC> TOKEN : {<MT_CC_Ranges : "#CC_Ranges" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_Ranges production. */
<CC> TOKEN : {<IT_CC_Ranges : "%CC_Ranges">}

/**
 * <em>CC_Ranges</em> ::=  <a href="#N_CC_RangeChar">&lang;CC_RangeChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassDone}</font><font color="red">:raw</font> 
 */
net.sf.crsx.Sink N_CC_Ranges(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink s1 = null;
	net.sf.crsx.Sink bs__lo = null;
	net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_CC_Ranges> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_Ranges>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__lo = b__lo.sink();
	}
	N_CC_RangeChar(bs__lo, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, true) ;
	}
	sink=N_CC_RangeTail(sink, env, b1)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassDone"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for CC_RangeTail production. */
<CC> TOKEN : {<MT_CC_RangeTail : "#CC_RangeTail" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_RangeTail production. */
<CC> TOKEN : {<IT_CC_RangeTail : "%CC_RangeTail">}

/**
 * <em>CC_RangeTail</em> ::=   <a href="#T_CC_DASH">CC_DASH</a>   (  <font color="red">{RegExpClassRange}</font><font color="red">:raw</font>   <font color="red">{{#lo}}</font>   <a href="#N_CC_RangeChar">&lang;CC_RangeChar&rang;</a>    <a href="#N_CC_Ranges">&lang;CC_Ranges&rang;</a>   |  <font color="red">{RegExpClassChar}</font><font color="red">:raw</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:raw</font>  )  <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:raw</font>   <font color="red">{{#lo}}</font>   <a href="#N_CC_NonDashRangeStartChar">&lang;CC_NonDashRangeStartChar&rang;</a> <font color="red">:#lo2</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo2&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:raw</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:raw</font> 
 */
net.sf.crsx.Sink N_CC_RangeTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__lo) :
{
	Token t = null;
	net.sf.crsx.Sink s1 = null;
	net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__lo2 = null;
	net.sf.crsx.util.Buffer b__lo2 = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_CC_RangeTail> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_RangeTail>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	 <T_CC_DASH>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassRange"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__lo, false) ;
		}
		 ) 
		 ( 
		sink=N_CC_RangeChar(sink, env)
		 ) 
		 ( 
		sink=N_CC_Ranges(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassChar"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__lo, false) ;
		}
		 ) 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassDone"), null)) ;
		}
		 ) 
		{
			sink = sink .end().end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassChar"), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .copy(b__lo, false) ;
	}
	 ) 
	 ( 
	{
		bs__lo2 = b__lo2.sink();
	}
	N_CC_NonDashRangeStartChar(bs__lo2, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo2, true) ;
	}
	sink=N_CC_RangeTail(sink, env, b1)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassChar"), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .copy(b__lo, false) ;
	}
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassDone"), null)) ;
	}
	 ) 
	{
		return sink .end().end() ;
	}
}

/** <em>CC_FirstRangeStartChar$WithEOF</em> ::= <em>CC_FirstRangeStartChar</em> EOF . */
net.sf.crsx.Sink N_CC_FirstRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_FirstRangeStartChar(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_FirstRangeStartChar production. */
<CC> TOKEN : {<MT_CC_FirstRangeStartChar : "#CC_FirstRangeStartChar" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_FirstRangeStartChar production. */
<CC> TOKEN : {<IT_CC_FirstRangeStartChar : "%CC_FirstRangeStartChar">}

/**
 * <em>CC_FirstRangeStartChar</em> ::=  (   <a href="#T_CC_RBRACKET">CC_RBRACKET</a><font color="red">$</font>  |   <a href="#T_CC_DASH">CC_DASH</a><font color="red">$</font>  |   <a href="#T_CC_OTHER">CC_OTHER</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_CC_FirstRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_CC_FirstRangeStartChar> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_FirstRangeStartChar>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_CC_RBRACKET>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_OTHER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>CC_NonDashRangeStartChar$WithEOF</em> ::= <em>CC_NonDashRangeStartChar</em> EOF . */
net.sf.crsx.Sink N_CC_NonDashRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_NonDashRangeStartChar(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_NonDashRangeStartChar production. */
<CC> TOKEN : {<MT_CC_NonDashRangeStartChar : "#CC_NonDashRangeStartChar" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_NonDashRangeStartChar production. */
<CC> TOKEN : {<IT_CC_NonDashRangeStartChar : "%CC_NonDashRangeStartChar">}

/**
 * <em>CC_NonDashRangeStartChar</em> ::=  (   <a href="#T_CC_NOT">CC_NOT</a><font color="red">$</font>  |   <a href="#T_CC_OTHER">CC_OTHER</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_CC_NonDashRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_CC_NonDashRangeStartChar> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_NonDashRangeStartChar>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_CC_NOT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_OTHER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>CC_RangeChar$WithEOF</em> ::= <em>CC_RangeChar</em> EOF . */
net.sf.crsx.Sink N_CC_RangeChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_RangeChar(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_RangeChar production. */
<CC> TOKEN : {<MT_CC_RangeChar : "#CC_RangeChar" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_RangeChar production. */
<CC> TOKEN : {<IT_CC_RangeChar : "%CC_RangeChar">}

/**
 * <em>CC_RangeChar</em> ::=  (   <a href="#T_CC_NOT">CC_NOT</a><font color="red">$</font>  |   <a href="#T_CC_DASH">CC_DASH</a><font color="red">$</font>  |   <a href="#T_CC_OTHER">CC_OTHER</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_CC_RangeChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_CC_RangeChar> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_RangeChar>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_CC_NOT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_OTHER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/**
 * Embedded ::= ( "<code></code>" (&not;["<code></code>","<code></code>"])*  "<code></code>")
 */
<*> TOKEN : {<T_Embedded : ("\253" (~["\253","\273"])* "\273") >}

/**
 * CONCRETESTART ::=  "<code>&#92;u27e6</code>"
 */
<DEFAULT> TOKEN : {<T_CONCRETESTART : "\u27e6" >: CONCRETE}

/**
 * CONCRETEEND ::=  "<code>&#92;u27e7</code>"
 */
<CONCRETE> TOKEN : {<T_CONCRETEEND : "\u27e7" >: DEFAULT}

/**
 * CONCRETEPUSH ::=  "<code>&#92;u27e8</code>"
 */
<CONCRETE> TOKEN : {<T_CONCRETEPUSH : "\u27e8" >: DEFAULT}

/**
 * CONCRETEPOP ::=  "<code>&#92;u27e9</code>"
 */
<DEFAULT> TOKEN : {<T_CONCRETEPOP : "\u27e9" >: CONCRETE}

/**
 * CONCRETESPACE ::= ["<code> </code>",<code>&#92;t</code><code>&#92;r</code><code>&#92;n</code>,<code>&#92;ub6</code>]+
 */
<CONCRETE> TOKEN : {<T_CONCRETESPACE : ([" ","\t","\r","\n","\266"])+ >}

/**
 * CONCRETEWORD ::= &not;["<code> </code>",<code>&#92;t</code><code>&#92;r</code><code>&#92;n</code><code>&#92;ub6</code><code>&#92;u27e6</code><code>&#92;u27e7</code><code>&#92;u27e8</code><code>&#92;u27e9</code>]+
 */
<CONCRETE> TOKEN : {<T_CONCRETEWORD : (~[" ","\t","\r","\n","\266","\u27e6","\u27e7","\u27e8","\u27e9"])+ >}

/**
 * <b>skip</b><font color="red"> (DEFAULT, RE)</font> ::=  "<code> </code>" | <code>&#92;r</code> | <code>&#92;t</code> | <code>&#92;n</code> |  "<code>//</code>" &not;[<code>&#92;n</code><code>&#92;r</code>]*
 */
<DEFAULT, RE> SKIP : { <" " | "\r" | "\t" | "\n" | "//" (~["\n","\r"])*> }

/**
 * SEMI ::=  "<code>;</code>"
 */
<DEFAULT, RE> TOKEN : {<T_SEMI : ";" >: DEFAULT}

/**
 * BAR ::=  "<code>|</code>"
 */
<DEFAULT, RE> TOKEN : {<T_BAR : "|" >}

/**
 * LPAREN ::=  "<code>(</code>"
 */
<DEFAULT, RE> TOKEN : {<T_LPAREN : "(" >}

/**
 * RPAREN ::=  "<code>)</code>"
 */
<DEFAULT, RE> TOKEN : {<T_RPAREN : ")" >}

/**
 * STAR ::=  "<code>*</code>"
 */
<DEFAULT, RE> TOKEN : {<T_STAR : "*" >}

/**
 * PLUS ::=  "<code>+</code>"
 */
<DEFAULT, RE> TOKEN : {<T_PLUS : "+" >}

/**
 * QUEST ::=  "<code>?</code>"
 */
<DEFAULT, RE> TOKEN : {<T_QUEST : "?" >}

/**
 * SUB ::=  "<code>_</code>"
 */
<DEFAULT, RE> TOKEN : {<T_SUB : "_" >}

/**
 * DOT ::=  "<code>.</code>"
 */
<DEFAULT, RE> TOKEN : {<T_DOT : "." >}

/**
 * COLON ::=  "<code>:</code>"
 */
<DEFAULT, RE> TOKEN : {<T_COLON : ":" >}

/**
 * LBRACE ::=  "<code>{</code>"
 */
TOKEN : {<T_LBRACE : "{" >}

/**
 * RBRACE ::=  "<code>}</code>"
 */
TOKEN : {<T_RBRACE : "}" >}

/**
 * HASH ::=  "<code>#</code>"
 */
TOKEN : {<T_HASH : "#" >}

/**
 * LBRACKET ::=  "<code>[</code>"
 */
TOKEN : {<T_LBRACKET : "[" >}

/**
 * RBRACKET ::=  "<code>]</code>"
 */
TOKEN : {<T_RBRACKET : "]" >}

/**
 * COMMA ::=  "<code>,</code>"
 */
TOKEN : {<T_COMMA : "," >}

/**
 * FORALL ::= <code>&#92;u2200</code>
 */
TOKEN : {<T_FORALL : "\u2200" >}

/**
 * ARROW ::= <code>&#92;u2192</code>
 */
<DEFAULT, RE> TOKEN : {<T_ARROW : "\u2192" >: DEFAULT}

/**
 * UP ::= <code>&#92;u2191</code>
 */
TOKEN : {<T_UP : "\u2191" >}

/**
 * DOWN ::= <code>&#92;u2193</code>
 */
TOKEN : {<T_DOWN : "\u2193" >}

/**
 * NOT ::= <code>&#92;u00ac</code>
 */
TOKEN : {<T_NOT : "\254" >}

/**
 * AT ::=  "<code>@</code>"
 */
TOKEN : {<T_AT : "@" >}

/**
 * DASH ::=  "<code>-</code>"
 */
TOKEN : {<T_DASH : "-" >}

/**
 * DIGIT ::= [<code>0</code>&ndash;<code>9</code>]
 */
TOKEN : {<T_DIGIT : ["0"-"9"] >}

/**
 * LOWER ::= [<code>a-z</code>]
 */
TOKEN : {<T_LOWER : ["a"-"z"] >}

/**
 * UPPER ::= [<code>A-Z</code>]
 */
<DEFAULT, RE> TOKEN : {<T_UPPER : ["A"-"Z"] >}

/**
 * MODULE ::=  "<code>module</code>"
 */
TOKEN : {<T_MODULE : "module" >}

/**
 * SORT ::=  "<code>sort</code>"
 */
TOKEN : {<T_SORT : "sort" >}

/**
 * DATA ::=  "<code>data</code>"
 */
TOKEN : {<T_DATA : "data" >}

/**
 * SCHEME ::=  "<code>scheme</code>"
 */
TOKEN : {<T_SCHEME : "scheme" >}

/**
 * AUTOMATIC ::=  "<code>automatic</code>"
 */
TOKEN : {<T_AUTOMATIC : "automatic" >}

/**
 * SYMBOL ::=  "<code>symbol</code>"
 */
TOKEN : {<T_SYMBOL : "symbol" >}

/**
 * STATIC ::=  "<code>static</code>"
 */
TOKEN : {<T_STATIC : "static" >}

/**
 * ATTRIBUTE ::=  "<code>attribute</code>"
 */
TOKEN : {<T_ATTRIBUTE : "attribute" >}

/**
 * COMPOSE ::=  "<code>compose</code>"
 */
TOKEN : {<T_COMPOSE : "compose" >}

/**
 * SUGAR ::=  "<code>sugar</code>"
 */
TOKEN : {<T_SUGAR : "sugar" >}

/**
 * RULE ::=  "<code>rule</code>"
 */
TOKEN : {<T_RULE : "rule" >}

/**
 * PRIORITY ::=  "<code>priority</code>"
 */
TOKEN : {<T_PRIORITY : "priority" >}

/**
 * DEFAULT ::=  "<code>default</code>"
 */
TOKEN : {<T_DEFAULT : "default" >}

/**
 * IMPORT ::=  "<code>import</code>"
 */
TOKEN : {<T_IMPORT : "import" >}

/**
 * TAG ::=  "<code>tag</code>"
 */
TOKEN : {<T_TAG : "tag" >}

/**
 * LEXER ::=  "<code>lexer</code>"
 */
TOKEN : {<T_LEXER : "lexer" >}

/**
 * SPACE ::=  "<code>space</code>"
 */
<DEFAULT> TOKEN : {<T_SPACE : "space" >: RE}

/**
 * TOKEN ::=  "<code>token</code>"
 */
<DEFAULT> TOKEN : {<T_TOKEN : "token" >: RE}

/**
 * FRAGMENT ::=  "<code>fragment</code>"
 */
<DEFAULT, RE> TOKEN : {<T_FRAGMENT : "fragment" >: RE}

/**
 * NESTED ::=  "<code>nested</code>"
 */
<RE> TOKEN : {<T_NESTED : "nested" >}

/**
 * META ::= HASH (NAME | STRING)? (HASH NAME)* SUFFIX*
 */
TOKEN : {<T_META : <T_HASH> (<T_NAME> | <T_STRING>)? (<T_HASH> <T_NAME>)* (<T_SUFFIX>)* >}

/**
 * VAR ::= LOWER NAME? SUFFIX* |  "<code>v</code>" STRING SUFFIX*
 */
TOKEN : {<T_VAR : <T_LOWER> (<T_NAME>)? (<T_SUFFIX>)* | "v" <T_STRING> (<T_SUFFIX>)* >}

/**
 * CON ::= (UPPER | [<code>$</code>]) NAME? SUFFIX* |  "<code>C</code>" STRING SUFFIX*
 */
<DEFAULT, RE> TOKEN : {<T_CON : (<T_UPPER> | ["$"]) (<T_NAME>)? (<T_SUFFIX>)* | "C" <T_STRING> (<T_SUFFIX>)* >}

/**
 * SUFFIX ::=  "<code>_</code>" NAME? |  "<code>_</code>"? NATURAL
 */
TOKEN : {<#T_SUFFIX : "_" (<T_NAME>)? | ("_")? <T_NATURAL> >}

/**
 * NAME ::= (LOWER | UPPER | [<code>$</code>])+
 */
TOKEN : {<#T_NAME : (<T_LOWER> | <T_UPPER> | ["$"])+ >}

/**
 * FRAGMENT_REF ::= <code>&#92;u27e8</code> (UPPER | DASH | CON) <code>&#92;u27e9</code>
 */
<RE> TOKEN : {<T_FRAGMENT_REF : "\u27e8" (<T_UPPER> | <T_DASH> | <T_CON>) "\u27e9" >}

/**
 * NATURAL ::= DIGIT+
 */
TOKEN : {<T_NATURAL : (<T_DIGIT>)+ >}

/**
 * INTEGER ::= [&ndash;<code>+</code>]* NATURAL
 */
TOKEN : {<#T_INTEGER : (["-","+"])* <T_NATURAL> >}

/**
 * UNNATURAL ::= (INTEGER?  "<code>.</code>" NATURAL) ([<code>Ee</code>] INTEGER)? | INTEGER [<code>Ee</code>] INTEGER
 */
TOKEN : {<T_UNNATURAL : ((<T_INTEGER>)? "." <T_NATURAL>) (["E","e"] <T_INTEGER>)? | <T_INTEGER> ["E","e"] <T_INTEGER> >}

/**
 * STRING ::=  "<code>'</code>" STRING1CHAR*  "<code>'</code>" |  "<code>"</code>" STRING2CHAR*  "<code>"</code>"
 */
<DEFAULT, RE> TOKEN : {<T_STRING : "\'" (<T_STRING1CHAR>)* "\'" | "\"" (<T_STRING2CHAR>)* "\"" >}

/**
 * STRING1CHAR ::= &not;[<code>&#92;&#92;</code><code>'</code><code>&#92;n</code>] | ESCAPEDCHAR
 */
TOKEN : {<#T_STRING1CHAR : ~["\\","\'","\n"] | <T_ESCAPEDCHAR> >}

/**
 * STRING2CHAR ::= &not;[<code>&#92;&#92;</code><code>"</code><code>&#92;n</code>] | ESCAPEDCHAR
 */
TOKEN : {<#T_STRING2CHAR : ~["\\","\"","\n"] | <T_ESCAPEDCHAR> >}

/**
 * ESCAPEDCHAR ::= [<code>&#92;&#92;</code>] &not;[<code>0</code>&ndash;<code>9</code><code>uUx</code>] | [<code>&#92;&#92;</code>] [<code>0</code>&ndash;<code>3</code>]? [<code>0</code>&ndash;<code>7</code>]? [<code>0</code>&ndash;<code>7</code>] | [<code>&#92;&#92;</code>] [<code>u</code>] HEX? HEX? HEX? HEX | [<code>&#92;&#92;</code>] [<code>U</code>] HEX? HEX? HEX? HEX? HEX? HEX? HEX? HEX | [<code>&#92;&#92;</code>] [<code>x</code>] (HEX HEX |  "<code>{</code>" HEX+  "<code>}</code>")
 */
<DEFAULT, RE> TOKEN : {<T_ESCAPEDCHAR : ["\\"] ~["0"-"9","u","U","x"] | ["\\"] (["0"-"3"])? (["0"-"7"])? ["0"-"7"] | ["\\"] ["u"] (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? <T_HEX> | ["\\"] ["U"] (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? <T_HEX> | ["\\"] ["x"] (<T_HEX> <T_HEX> | "{" (<T_HEX>)+ "}") >}

/**
 * HEX ::= [<code>0</code>&ndash;<code>9</code><code>A-Fa-f</code>]
 */
TOKEN : {<#T_HEX : ["0"-"9","A"-"F","a"-"f"] >}

/**
 * OTHERCHAR ::= &not;[]
 */
TOKEN : {<T_OTHERCHAR : ~[] >}

/**
 * WORD ::= &not;["<code></code>","<code></code>","<code></code>","<code></code>","<code>(</code>","<code>)</code>","<code>[</code>","<code>]</code>","<code>.</code>","<code>*</code>","<code>+</code>","<code>?</code>","<code>;</code>","<code>"</code>","<code>'</code>","<code>,</code>","<code>:</code>","<code></code>","<code></code>","<code> </code>",<code>&#92;t</code>,<code>&#92;&#92;</code>,<code>&#92;n</code>]+
 */
<RE> TOKEN : {<T_WORD : (~["\u27e8","\u27e9","\u27e6","\u27e7","(",")","[","]",".","*","+","?",";","\"","\'",",",":","\253","\273"," ","\t","\\","\n"])+ >}

/**
 * CHAR_CLASS ::=  "<code>[</code>" ( "<code>^</code>")? ( "<code>]</code>")? (&not;["<code>]</code>",<code>&#92;&#92;</code>,<code>&#92;n</code>] | ESCAPEDCHAR)*  "<code>]</code>"
 */
<RE> TOKEN : {<T_CHAR_CLASS : "[" ("^")? ("]")? (~["]","\\","\n"] | <T_ESCAPEDCHAR>)* "]" >}

/**
 * CC_NOT ::=  "<code>^</code>"
 */
<CC> TOKEN : {<T_CC_NOT : "^" >}

/**
 * CC_RBRACKET ::=  "<code>]</code>"
 */
<CC> TOKEN : {<T_CC_RBRACKET : "]" >}

/**
 * CC_DASH ::=  "<code>-</code>"
 */
<CC> TOKEN : {<T_CC_DASH : "-" >}

/**
 * CC_OTHER ::= &not;["<code>^</code>","<code>]</code>","<code>-</code>",<code>&#92;&#92;</code>,<code>&#92;n</code>] | ESCAPEDCHAR
 */
<CC> TOKEN : {<T_CC_OTHER : ~["^","]","-","\\","\n"] | <T_ESCAPEDCHAR> >}

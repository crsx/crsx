// $Id: CookCRS.crs,v 1.43 2014/01/06 03:11:34 krisrose Exp $
// CRSX3 RULES FOR CONVERTING RAW HACS FORMAT TO CRS FORMAT.
//
CookCRS[(

// Base library.
$Use["net/sf/crsx/hoacs/bootstrap/CookBase.crs"];

// Normalization and normalized structure.
$Use["net/sf/crsx/hoacs/bootstrap/CookN.crs"];

// Insert options automatically.
$Lax;


/////////////////////////////////////////////////////////////////////
// TOP LEVEL
//
// Module morph'd to function that normalizes and emits as CRS.

CRS[RawModule] :: Text;
CRS[%rawModule⟦ module #ModuleName# { #Declarations# } ⟧]
→
CRS1[#ModuleName#, N-resolve[#Declarations#]]
;

CRS1[$String, RawDeclarations] :: Text;
CRS1[#ModuleName, #Declarations]
→
CRS2[{} N-Declarations[#Declarations, #ModuleName], #ModuleName, ParsePrefix[#ModuleName], $[:,$[Replace,#ModuleName,"\"",""],"Parser"]]
;

CRS2[NormalizedSortMap, $String, $String, $String] :: Text;
-[Data[#ModuleName]]:
CRS2[{#ND}NSM[#Names], #ModuleName, #ParsePrefix, #ParserName]
→
{#ND}
CRS-Module[#Names, #ModuleName, BaseClassOf[#ModuleName], #ParsePrefix, {#ND} DerivedSorts[#Names], #ParserName]
/// →
/// Hd[$[Script, (
///   $AddGrammar[#ParserName];
///   $Send[CRS3[{#ND}NSM[#Names], #ModuleName, #ParsePrefix, #ParserName, {#ND} CRS-FormHeadIndex[#ParsePrefix]]];
/// )]]
/// ;
/// 
/// -[Data[#InheritedMapNames,#FormHeadIndex]]:
/// CRS3[{#ND}NSM[#Names], #ModuleName, #ParsePrefix, #ParserName, #FormHeadIndex]
/// →
/// {#ND; "$AllFormHeads" : FORM_HEADS[#FormHeadIndex]}
/// CRS-Module[#Names, #ModuleName, BaseClassOf[#ModuleName], #ParsePrefix, {#ND} DerivedSorts[#Names], #ParserName]
;

///SortEntry ::=( NAMES[NameSet]; FORM_HEADS[FormHeadIndex]; );
SortEntry ::=( NAMES[NameSet]; );


/////////////////////////////////////////////////////////////////////
// TEXT OF CRS RULES.
//
// Main entry point for generating CRSX3 CRS rules specification for normalized HACS specification.

{$String : SortEntry}CRS-Module[NameSet<!--AllNames-->, $String<!--ModuleName-->, $String<!--Class-->, $String<!--ParsePrefix-->, $List[DERIVED_SORT], $String<!--ParserName-->] :: Text ;

{#ND; "$AllInheritedNames" : NAMES[#InheritedNames]; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]; "$AllSynthesizedNames" : NAMES[#SynthesizedNames]; "$AllSynthesizedMapNames" : NAMES[#SynthesizedMapNames]}
CRS-Module[#Names, #ModuleName, #Class, #ParsePrefix, #Derived, #ParserName]
→
%n⟪<!-- CRS Rules for HACS module †«#ModuleName».
@version $Id: CookCRS.crs,v 1.43 2014/01/06 03:11:34 krisrose Exp $
-->
†« #Class »[(

<!-- Our syntax. -->
$CheckGrammar["†«#ParserName»"];

<!-- Syntax and sorts of text (for printing). -->
$CheckGrammar["net.sf.crsx.text.Text"];
$Use["net/sf/crsx/text/Text.crs"];

<!-- Allow inference of options. -->
$Lax;

<!-- User's variable names are safe. -->
$Set["trust-generated-variable-names"];

<!-- Some utility functions. -->
$Use["net/sf/crsx/hacs/Prelude.crs"];

∀ a . LineNumber[a] :: $String ;
LineNumber[{#L}#] → UnSTRING[$[{#L}Get[$String], "$LineNumber", STRING["0"]]] ;

$StringEntrySort ::=( STRING[$String]; );
UnSTRING[$StringEntrySort] :: $String ;
UnSTRING[STRING[#]] → # ;

$Meta[(
<!-- "Blast" inherited attributes onto all function symbols in subterm. -->
-[Data[###]]: {###Inherited}_SprayInherited[###] → $[{###Inherited}Inherit, ###] ;

<!-- Create variant of construction. -->
_Alternate[###Extra, {###Env}$[C, ###C, ###Args]] → {###Env}$[C, $[:,###C,###Extra], ###Args] ;

<!-- Add free variables in a term as extra arguments to a construction. -->
{###Inherited}_FreeVariableArguments[###term, $[C, ###C, ###Args]] → {###Inherited}_FreeVariableArguments1[###Args, ###C, $[FreeVariables,###term], rest.rest]; 
{###Inherited}_FreeVariableArguments1[(), ###C, ###FreeVars, rest.###[rest]] → {###Inherited}_FreeVariableArguments2[$[C, ###C, ###[###FreeVars]]]; 
{###Inherited}_FreeVariableArguments1[(###Arg1; ###Args), ###C, ###FreeVars, rest.###[rest]] → {###Inherited}_FreeVariableArguments1[###Args, ###C, ###FreeVars, rest.###[(###Arg1; rest)]]; 
{###Inherited}_FreeVariableArguments2[###] → {###Inherited}### ;

<!-- Initialize containers for all inherited map attributes. --> 
_InitInheritedMaps[###] → « WrappedTextFold[Map[a.%n⟨"†‹a›" : ‹InheritedName[a]›⟩, NameSetList[#InheritedMapNames]], %n⟨{⟩, %n⟨; ⟩, %n⟨}⟩] »### ;

<!-- Sort-specific macros. -->
« {#ND}CRS-MetaDeclarations[#Names, #ParsePrefix] »
« TextFoldMap[JoinMappedTextMaps[d.CRS-MetaDeclarations-Derived[d, #ParsePrefix], #Derived], %n⟨⟩] »
)];


<!-- DECLARATIONS -->

« {#ND}CRS-Declarations[#Names, #ParsePrefix] »

<!-- Shared derived repeating declarations. -->
« TextFoldMap[JoinMappedTextMaps[d.{#ND}CRS-Declarations-Derived[d, #ParsePrefix], #Derived], %n⟨
⟩] »

<!-- Inherited attribute propagation declarations. -->
« TextFold[MapWhen[ok a.{#ND}CRS-Declarations-Inherited[ok, a, #ParsePrefix, #InheritedMapNames], NameSetList[#InheritedNames]], %n⟨
⟩] »

<!-- Synthesized attribute propagation declarations. -->
« TextFold[MapWhen[ok a.{#ND}CRS-Declarations-Synthesized[ok, a, #ParsePrefix, #SynthesizedMapNames], NameSetList[#SynthesizedNames]], %n⟨
⟩] »


<!-- RULES -->

« {#ND}CRS-Rules[#Names, #ParsePrefix] »

<!-- Shared derived repeating rules. -->
« TextFoldMap[JoinMappedTextMaps[d.{#ND}CRS-Rules-Derived[d, #ParsePrefix], #Derived], %n⟨
⟩] »

<!-- Inherited attribute propagation rules. -->
« TextFold[MapWhen[ok a.{#ND}CRS-Rules-Inherited[ok, a, #ParsePrefix, #InheritedMapNames], NameSetList[#InheritedNames]], %n⟨
⟩] »

<!-- Synthesized attribute propagation rules. -->
« TextFold[MapWhen[ok a.{#ND}CRS-Rules-Synthesized[ok, a, #ParsePrefix, #SynthesizedMapNames], NameSetList[#SynthesizedNames]], %n⟨
⟩] »

)]
⟫
;


/////////////////////////////////////////////////////////////////////
// TEXT OF META DECLARATIONS BY ATTRIBUTE/SORT/TOKEN NAME.

{$String : SortEntry}CRS-MetaDeclarations[NameSet, $String] :: Text;
{#ND}CRS-MetaDeclarations[#Names, #ParsePrefix] → {#ND}CRS-MetaDeclarations1[HasNames[#Names], #Names, #ParsePrefix] ;

{$String : SortEntry}CRS-MetaDeclarations1[Boolean, NameSet, $String] :: Text;
{#ND}CRS-MetaDeclarations1[B_FALSE, #Names, #ParsePrefix] → %n⟪⟫ ;

{#ND}CRS-MetaDeclarations1[B_TRUE , #Names, #ParsePrefix]
→
%n⟪« {#ND}CRS-MetaDeclaration[FirstName[#Names], #ParsePrefix] »
« {#ND}CRS-MetaDeclarations[RemoveFirstName[#Names], #ParsePrefix] »⟫
;

{$String : SortEntry}CRS-MetaDeclaration[$String, $String] :: Text;
-[Data[#Name]]:
{#ND}CRS-MetaDeclaration[#Name,#ParsePrefix] 
→
CRS-MetaDeclaration1[$[{#ND}Get[SortEntry], #Name, SE_NONE], #ParsePrefix]
;

CRS-MetaDeclaration1[SortEntry, $String] :: Text;

CRS-MetaDeclaration1[SE_NONE, #ParsePrefix] → %n⟪⟫ ;

// Token declaration.

CRS-MetaDeclaration1[SE_TOKEN[#Name], #ParsePrefix] → %n⟪⟫;

// Attribute declaration.

CRS-MetaDeclaration1[SE_ATTRIBUTE[#Kind, #Name, #Form, #Options], #ParsePrefix]
→
CRS-MetaDeclarations-AttributeOptions[#Kind, #Name, #Options, NoNames]
;

CRS-MetaDeclarations-AttributeOptions[RawAttributeKind, $String, $List[RawAttributeOption], NameSet] :: Text;

CRS-MetaDeclarations-AttributeOptions[#Kind, #Name, (%rawAttributeOption⟪ #Variable# #Constructor# ⟫; #AttributeOptions), #names]
→
%n⟪⟫
;
///
///%n⟪«
///  If[SameString[#Variable#, "unit"],
///    %n⟨Unit-†‹#Name› → †‹#Constructor#›;
///⟩,If[SameString[#Variable#, "join"],
///    %n⟨Join-†‹#Name›[#1,#2] → †‹#Constructor#›[#1,#2];
///⟩,If[SameString[#Variable#, "error"],
///    %n⟨Error-†‹#Name› → †‹#Constructor#›;
///⟩, %n⟨⟩]]]
///»« CRS-MetaDeclarations-AttributeOptions[#Kind, #Name, #AttributeOptions, AddName[#names, #Variable#]] »⟫

CRS-MetaDeclarations-AttributeOptions[#Kind, #Name, (), #names]
→
%n⟪⟫
;
///%n⟪« If[ContainsName[#names, "join"], %n⟨⟩, %n⟨Join-†‹#Name›[#1,#2] → CookError["Missing 'join' definition for †‹#Name› attribute"];
///⟩] »« If[ContainsName[#names, "unit"], %n⟨⟩, %n⟨Unit-†‹#Name› → CookError["Missing 'unit' definition for †‹#Name› attribute"];
///⟩] »« If[ContainsName[#names, "error"], %n⟨⟩, %n⟨Error-†‹#Name› → CookError["Missing 'error' definition for †‹#Name› attribute"];
///⟩] »⟫
///;

// Sort declaration.

CRS-MetaDeclaration1[SE_SORT[#Defines, #Name, #Precs, #Wrapper], #ParsePrefix]
→
CRS-MetaDeclarations-PrecWrapper[#Name, #ParsePrefix, #Wrapper]
;

CRS-MetaDeclarations-PrecWrapper[$String, $String, Wrapper] :: Text;

CRS-MetaDeclarations-PrecWrapper[#Name, #ParsePrefix, NoWrapper]
→ %n⟪$PrecWrap-†«#Name»[#Prec, #InnerPrec, #] → # ;
⟫;

CRS-MetaDeclarations-PrecWrapper[#Name, #ParsePrefix, Wrapper[#ParsedForm]] → %n⟪⟫;


/////////////////////////////////////////////////////////////////////
// TEXT OF DECLARATIONS BY ATTRIBUTE/SORT/TOKEN NAME.

{$String : SortEntry} CRS-Declarations[NameSet, $String] :: Text;
{#ND}CRS-Declarations[#Names, #ParsePrefix] → {#ND}CRS-Declarations1[HasNames[#Names], #Names, #ParsePrefix] ;

{$String : SortEntry} CRS-Declarations1[Boolean, NameSet, $String] :: Text;

{#ND}CRS-Declarations1[B_FALSE, #Names, #ParsePrefix] → %n⟪⟫ ;

{#ND}CRS-Declarations1[B_TRUE , #Names, #ParsePrefix]
→
%n⟪« {#ND}CRS-Declaration[FirstName[#Names], #ParsePrefix] »
« {#ND}CRS-Declarations[RemoveFirstName[#Names], #ParsePrefix] »⟫
;

{$String : SortEntry} CRS-Declaration[$String, $String] :: Text;
-[Data[#Name]]:
{#ND}CRS-Declaration[#Name,#ParsePrefix] 
→
{#ND}CRS-Declaration1[$[{#ND}Get[SortEntry], #Name, SE_NONE], #ParsePrefix]
;

{$String : SortEntry} CRS-Declaration1[SortEntry, $String] :: Text;

{#ND}CRS-Declaration1[SE_NONE, #ParsePrefix] → %n⟪⟫ ;

// Token declaration.

{#ND}CRS-Declaration1[SE_TOKEN[#Name], #ParsePrefix] → %n⟪
<!-- All declarations for †«#Name» token sort. -->
$Drop-†«#Name»[†«#Name»] :: Text ;
$Print-†«#Name»[†«#Name»] :: Text ;
$PrintP-†«#Name»[†«#Name», $Numeric] :: Text ;
⟫;

// Attribute declaration.

{#ND}CRS-Declaration1[SE_ATTRIBUTE[%rawAttributeKind⟪ ↓ ⟫, #Name, #Form, #Options], #ParsePrefix] → %n⟪
<!-- Inherited attribute †«#Name». -->
$StringEntrySort ::=( « CRS-Forms-AttributeForm[%rawAttributeKind⟪ ↓ ⟫, #Name, #Form] » );
⟫;

{#ND}CRS-Declaration1[SE_ATTRIBUTE[%rawAttributeKind⟪ ↑ ⟫, #Name, #Form, #Options], #ParsePrefix] → %n⟪
<!-- Synthesized attribute †«#Name». -->
$StringEntrySort ::=( « CRS-Forms-AttributeForm[%rawAttributeKind⟪ ↑ ⟫, #Name, #Form] » );
⟫;

// Helpers.

CRS-Forms-AttributeForm[RawAttributeKind, $String, RawAttributeForm] :: Text ;

// - regular value attributes 'a' have 'Inherited_a/Synthesized_a'+'NoInherited_a/NoSynthesized_a' constructors.

CRS-Forms-AttributeForm[%rawAttributeKind⟪ ↓ ⟫, #Name, %rawAttributeForm⟪ ( #Sort# ) ⟫] → %n⟪ « InheritedName[#Name] »[†« SortName[#Sort#] »]; No« InheritedName[#Name] »; ⟫ ;
CRS-Forms-AttributeForm[%rawAttributeKind⟪ ↑ ⟫, #Name, %rawAttributeForm⟪ ( #Sort# ) ⟫] → %n⟪ « SynthesizedName[#Name] »[†« SortName[#Sort#] »]; No« SynthesizedName[#Name] »; ⟫ ;

// - set attributes 'a' have 'Inherited_a/Synthesized_a' constructor.

CRS-Forms-AttributeForm[%rawAttributeKind⟪ ↓ ⟫, #Name, %rawAttributeForm⟪ { #Sort# } ⟫] → %n⟪ {†« SortName[#Sort#] » : Ok}« InheritedName[#Name] »; ⟫ ;
CRS-Forms-AttributeForm[%rawAttributeKind⟪ ↑ ⟫, #Name, %rawAttributeForm⟪ { #Sort# } ⟫] → %n⟪ {†« SortName[#Sort#] » : Ok}« SynthesizedName[#Name] »; ⟫ ;

// - map attributes 'a' have 'Inherited_a/Synthesized_a' constructor.

CRS-Forms-AttributeForm[%rawAttributeKind⟪ ↓ ⟫, #Name, %rawAttributeForm⟪ { #Sort1# : #Sort2# } ⟫] → %n⟪ {†« SortName[#Sort1#] » : †« SortName[#Sort2#] »}« InheritedName[#Name] »; ⟫ ;
CRS-Forms-AttributeForm[%rawAttributeKind⟪ ↑ ⟫, #Name, %rawAttributeForm⟪ { #Sort1# : #Sort2# } ⟫] → %n⟪ {†« SortName[#Sort1#] » : †« SortName[#Sort2#] »}« SynthesizedName[#Name] »; ⟫ ;

// Sort declaration.

-[Data[#Synthesizes]]:
{#ND}
CRS-Declaration1[SE_SORT[#Defines, #Name, #Precs, #Wrapper], #ParsePrefix]
→
%n⟪
<!-- All declarations for †«#Name» sort. -->
$Drop-†«#Name»[†«#Name»] :: Text ;
« CRS-Declarations-PrecWrapper[#Name, #ParsePrefix, #Wrapper] »
$Print-†«#Name»[†«#Name»] :: Text ;
$PrintP-†«#Name»[†«#Name», $Numeric] :: Text ; <!--per data form-->
« TextFold[MapWhen[ok a.{#ND}CRS-Declarations-DefineSynth[ok, a, ProductionName[#Name]], NameSetList[DefinesSynthesize[#Defines, NoNames]]], %n⟨⟩] »
« {#ND}CRS-Declarations-Defines[#Defines, #Name, #ParsePrefix, #Wrapper] »
⟫;

{$String : SortEntry} CRS-Declarations-DefineSynth[Ok, $String<!--attribute-->, Text] :: Text;
{#ND; "$AllSynthesizedMapNames" : NAMES[#SynthesizedMapNames]}
CRS-Declarations-DefineSynth[OK, #attribute, #ProductionName]
→
%n⟪«NeedsSynthesizedName[#attribute]»[«#ProductionName»] :: «#ProductionName» ;
«CollectSynthesizedName[#attribute]»[«#ProductionName»] :: «#ProductionName» ;
⟫;

CRS-Declarations-PrecWrapper[$String, $String, Wrapper] :: Text;
CRS-Declarations-PrecWrapper[#Name, #ParsePrefix, NoWrapper]
→ %n⟪⟫
;
CRS-Declarations-PrecWrapper[#Name, #ParsePrefix, Wrapper[#ParsedForm]]
→ %n⟪$PrecWrap-†«#Name»[$Numeric, $Numeric, Text] :: Text ;
⟫;

{$String : SortEntry} CRS-Declarations-Defines[$List[Define], $String, $String, Wrapper] :: Text;
{#ND}CRS-Declarations-Defines[(), #Name, #ParsePrefix, #Wrapper] → %n⟪⟫ ;
{#ND}CRS-Declarations-Defines[(#Define; #Defines), #Name, #ParsePrefix, #Wrapper]
→
%n⟪« {#ND}CRS-Declarations-Define[#Define, #Name, #ParsePrefix, #Wrapper, ()] »« {#ND}CRS-Declarations-Defines[#Defines, #Name, #ParsePrefix, #Wrapper] »⟫
;

{$String : SortEntry} CRS-Declarations-Define[Define, $String, $String, Wrapper, $List[RawSortParam]] :: Text;

// Abstractions recorded (for sort declarations).
-[Fresh[param::RawSortParam]]:
{#ND}CRS-Declarations-Define[D_ABSTRACTION[a.#Define[a]], #Name, #ParsePrefix, #Wrapper, #params]
→
{#ND}CRS-Declarations-Define[#Define[param], #Name, #ParsePrefix, #Wrapper, Append[#params, (param;)]]
;

{#ND}CRS-Declarations-Define[D_FORM[#Form, FK_DATA[#Tagging]], #Name, #ParsePrefix, #Wrapper, #params] → %n⟪⟫ ;

{#ND}CRS-Declarations-Define[D_FORM[#Form, FK_SYMBOL[#IsStatic]], #Name, #ParsePrefix, #Wrapper, #params] → %n⟪⟫ ;

{#ND}CRS-Declarations-Define[D_FORM[#Form, FK_SCHEME[#Inh]], #Name, #ParsePrefix, #Wrapper, #params]
→
%n⟪« CRS-ParamPrefix[#params] »{$String : $StringEntrySort}« {#ND}CRS-Term-Form[#Form, #Name, #ParsePrefix, $True<!--Sorted-->, $True<!--Form-->, $False<!--NoInherit-->, ok s p q r.q] » :: †« #Name » ;
« CRS-ParamPrefix[#params] »_Alternate["-Needy", {$String : $StringEntrySort}« {#ND}CRS-Term-Form[#Form, #Name, #ParsePrefix, $True<!--Sorted-->, $True<!--Form-->, $False<!--NoInherit-->, ok s p q r.q] »] :: †« #Name » ;
« MapWrapperConstruction[#Form, c ss ihs . %n⟨$SortFor-Action-†‹c› :: Text ;
$Print-Action-†‹c›‹ {#ND}CRS-FormScopeSorts[(ss;), #Name, $False, ok s p q r . StringToText[SortNameWithRepeat[s, r]], %n⟨[⟩, %n⟨⟩, 1] › :: Text ;
⟩] »⟫
;

{#ND}CRS-Declarations-Define[D_SYNTHESIZES[#AttributeName], #Name, #ParsePrefix, #Wrapper, #params] → %n⟪⟫ ;

// Helper: insert _Alternate wrapper when appropriate.
Make_Alternate[$String, Text] :: Text;
-[Data[#variant]]:
Make_Alternate[#variant, #text]
→
$[IfEmpty, #variant, #text, %n⟪_Alternate["†«#variant»", « #text »]⟫]
;

// Helper: extract precedence from form.
FormPrec[RawForm] :: $Numeric;
FormPrec[RAW-FormParsedSorted[#Sort, #ParsedForm, #Prec, #InheritedRefs]] → #Prec ;
FormPrec[RAW-FormParsedUnsorted[#ParsedForm, #Prec, #InheritedRefs]] → #Prec ;
FormPrec[RAW-FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs]] → 0 ;

// Helper: special text for constructions.
MapWrapperConstruction[RawForm, c::$String ss:RawScopeSort ihs::$List[RawInheritedRef] . Text] :: Text;
MapWrapperConstruction[RAW-FormParsedSorted[#Sort, #ParsedForm, #Prec, #InheritedRefs], c ss ihs.#[c,ss,ihs]] → %n⟪⟫ ;
MapWrapperConstruction[RAW-FormParsedUnsorted[#ParsedForm, #Prec, #InheritedRefs], c ss ihs.#[c,ss,ihs]] → %n⟪⟫ ;
MapWrapperConstruction[RAW-FormConstruction[#Constructor, (), #InheritedRefs], c ss ihs.#[c,ss,ihs]] → %n⟪⟫ ;
MapWrapperConstruction[RAW-FormConstruction[#Constructor, (#ScopeSort;), #InheritedRefs], c ss ihs.#[c,ss,ihs]] → #[#Constructor, #ScopeSort, #InheritedRefs] ;
MapWrapperConstruction[RAW-FormConstruction[#Constructor, (#ScopeSort1; #ScopeSort2; #ScopeSorts), #InheritedRefs], c ss ihs.#[c,ss,ihs]] → %n⟪⟫ ;

// Aliases are eliminated by parser.
{#ND}CRS-Declarations-Define[D_FORM[#Form, FK_ALIAS], #Name, #ParsePrefix, #Wrapper, #params] → %n⟪⟫ ;

// A sugar form declaration generates a meta-rule to eliminate the sugar.
{#ND}CRS-Declarations-Define[D_FORM[{#L}#Form, FK_SUGAR[#Term]], #Name, #ParsePrefix, #Wrapper, #params]
→
%n⟪{$String : $StringEntrySort}« {#ND}CRS-Term-Form[#Form, #Name, #ParsePrefix, $True<!--Sorted-->, $True<!--Form-->, $False<!--NoInherit-->, ok s p q r.q] » :: †« #Name » ;
⟫
;

// Rules already declared.
{#ND}CRS-Declarations-Define[D_RULE[#Rule, #SortName, #IsData], #Name, #ParsePrefix, #Wrapper, #params] → %n⟪⟫ ;

// Helper to insert 'forall-prefix' into CRS declaration.
CRS-ParamPrefix[$List[RawSortParam]] :: Text;
CRS-ParamPrefix[()] → %n⟪⟫ ;
CRS-ParamPrefix[(#1;#s)] → %n⟪∀ «AsText[#1]»« CRS-ParamSequence[#s] » . ⟫ ;

CRS-ParamSequence[$List[RawSortParam]] :: Text;
CRS-ParamSequence[()] → %n⟪⟫ ;
-[Data[#1]]: CRS-ParamSequence[(#1;#s)] → %n⟪ « AsText[#1] »« CRS-ParamSequence[#s] »⟫ ;

// Helper: generate sort form or rule pattern Form.
{$String : SortEntry} CRS-Term-Form[RawForm, $String, $String, $Boolean, $Boolean, $Boolean, ok::Ok s::RawSort p::$Numeric q::Text r::RawRepeat.Text] :: Text;

{#ND}CRS-Term-Form[RAW-FormParsedSorted[#Sort, #ParsedForm, #Prec, #InheritedRefs], #Name, #ParsePrefix, #Sorted, #makeForm, #topinherit, ok s p q r.#Wrap[ok,s,p,q,r]]
→
%n⟪«
  $[If, #topinherit, {#ND}CRS-Form-PatternEnv[#InheritedRefs, #ParsePrefix], %n⟨⟩]
»«
  $[If, #Sorted,
   CRS-User[#ParsePrefix, %n⟨†‹ #Sort ›⟩, {#ND}CRS-ParsedForm-ParsedForm[#ParsedForm, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], 1]],
   CRS-User[#ParsePrefix, %n⟨⟩, {#ND}CRS-ParsedForm-ParsedForm[#ParsedForm, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], 1]]]
»⟫;

{#ND}CRS-Term-Form[RAW-FormParsedUnsorted[#ParsedForm, #Prec, #InheritedRefs], #Name, #ParsePrefix, #Sorted, #makeForm, #topinherit, ok s p q r.#Wrap[ok,s,p,q,r]]
→
%n⟪«
  $[If, #topinherit, {#ND}CRS-Form-PatternEnv[#InheritedRefs, #ParsePrefix], %n⟨⟩]
»«
  $[If, #Sorted,
   CRS-User[#ParsePrefix, %n⟨†‹ #Name ›⟩, {#ND}CRS-ParsedForm-ParsedForm[#ParsedForm, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], 1]],
   CRS-User[#ParsePrefix, %n⟨⟩, {#ND}CRS-ParsedForm-ParsedForm[#ParsedForm, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], 1]]]
»⟫;

{#ND}CRS-Term-Form[RAW-FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Name, #ParsePrefix, #Sorted, #makeForm, #topinherit, ok s p q r.#Wrap[ok,s,p,q,r]]
→
%n⟪«
  $[If, #topinherit, {#ND}CRS-Form-PatternEnv[#InheritedRefs, #ParsePrefix], %n⟨⟩]
»†«#Constructor» « {#ND}CRS-FormScopeSorts[#ScopeSorts, #Name, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], %n⟨[⟩, %n⟨⟩, 1] »⟫
;

{$String : SortEntry} CRS-Form-PatternEnv[$List[RawInheritedRef], $String] :: Text;
{#ND; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
CRS-Form-PatternEnv[#InheritedRefs, #ParsePrefix] → %n⟪{#Inherited« {#ND}CRS-Form-PatternEnv1[#InheritedRefs, #ParsePrefix, #InheritedMapNames] »}⟫ ; 

{$String : SortEntry} CRS-Form-PatternEnv1[$List[RawInheritedRef], $String, NameSet] :: Text;

{#ND}CRS-Form-PatternEnv1[(), #ParsePrefix, #UnhandledInherited]
→
TextFold[Map[a.%n⟪; "†«a»" : {#InheritedMap_†«a»}«InheritedName[a]»⟫, NameSetList[#UnhandledInherited]], %n⟪⟫]
; 

{#ND}CRS-Form-PatternEnv1[(%rawInheritedRef⟪ ↓ #AttributeName# ⟫ ; #as), #ParsePrefix, #UnhandledInherited]
→
{#ND}CRS-Form-PatternEnv2[$[{#ND}Get,#AttributeName#, SE_NONE], #AttributeName#, #as, #ParsePrefix, #UnhandledInherited]
;

{$String : SortEntry} CRS-Form-PatternEnv2[SortEntry, $String, $List[RawInheritedRef], $String, NameSet] :: Text;

{#ND}CRS-Form-PatternEnv2[SE_ATTRIBUTE[#kind, #name, %rawAttributeForm⟪ ( #Sort# ) ⟫, #AttributeOptions], #AttributeName, #as, #ParsePrefix, #UnhandledInherited]
→
{#ND}CRS-Form-PatternEnv1[#as, #ParsePrefix, RemoveName[#UnhandledInherited, #AttributeName]]
;
{#ND}CRS-Form-PatternEnv2[SE_ATTRIBUTE[%rawAttributeKind⟪ ↓ ⟫, #name, %rawAttributeForm⟪ { #Sort# } ⟫, #AttributeOptions], #AttributeName, #as, #ParsePrefix, #UnhandledInherited]
→
%n⟪; "†«#AttributeName»" : {#InheritedMap_†«#AttributeName»}«InheritedName[#AttributeName]»« {#ND}CRS-Form-PatternEnv1[#as, #ParsePrefix, RemoveName[#UnhandledInherited, #AttributeName]] »⟫
;
{#ND}CRS-Form-PatternEnv2[SE_ATTRIBUTE[%rawAttributeKind⟪ ↑ ⟫, #name, %rawAttributeForm⟪ { #Sort# } ⟫, #AttributeOptions], #AttributeName, #as, #ParsePrefix, #UnhandledInherited]
→
{#ND}CRS-Form-PatternEnv1[#as, #ParsePrefix, RemoveName[#UnhandledInherited, #AttributeName]]
;
{#ND}CRS-Form-PatternEnv2[SE_ATTRIBUTE[%rawAttributeKind⟪ ↓ ⟫, #name, %rawAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #AttributeOptions], #AttributeName, #as, #ParsePrefix, #UnhandledInherited]
→
%n⟪; "†«#AttributeName»" : {#InheritedMap_†«#AttributeName»}«InheritedName[#AttributeName]»« {#ND}CRS-Form-PatternEnv1[#as, #ParsePrefix, RemoveName[#UnhandledInherited, #AttributeName]] »⟫
;
{#ND}CRS-Form-PatternEnv2[SE_ATTRIBUTE[%rawAttributeKind⟪ ↑ ⟫, #name, %rawAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #AttributeOptions], #AttributeName, #as, #ParsePrefix, #UnhandledInherited]
→
{#ND}CRS-Form-PatternEnv1[#as, #ParsePrefix, RemoveName[#UnhandledInherited, #AttributeName]]
;

{$String : SortEntry} CRS-FormScopeSorts[$List[RawScopeSort], $String, $Boolean, ok::Ok s::RawSort p::$Numeric q::Text r::RawRepeat.Text, Text, Text, $Numeric] :: Text;
{#ND}CRS-FormScopeSorts[(), #Name, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #pre, #post, #n] → #post ;
-[Data[#makeForm]]:
{#ND}CRS-FormScopeSorts[(%rawScopeSort⟪ #Sort1# [ #SubstituteSorts1# ] ⟫; #ScopeSorts), #Name, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #pre, #post, #n]
→
%n⟪«#pre»«
  {#ND}CRS-Binders-SubstituteSorts[#SubstituteSorts1#, 1, %n⟨⟩, #makeForm]
» «
  $[If, #makeForm, %n⟨†‹ SortName1[#Name] ›⟩, #Wrap[OK, #Sort1#, 0, CRS-FormScopeMetaApplication[CRS-SortMetaVar[#Sort1#, #n], #SubstituteSorts1#, $True<!--vN-->], %rawRepeat⟪ ⟫]]
»«
  {#ND}CRS-FormScopeSorts[#ScopeSorts, #Name, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], %n⟨,⟩, %n⟨]⟩, $[Plus,#n,1]]
»⟫
;

// Helper for form or pattern binders. 
{$String : SortEntry} CRS-Binders-SubstituteSorts[$List[RawSubstituteSort], $Numeric, Text, $Boolean] :: Text;
{#ND}CRS-Binders-SubstituteSorts[(), #n, #post, #makeForm] → #post ;
{#ND; #Variable1# : #Sort1#}
CRS-Binders-SubstituteSorts[(%rawSubstituteSort⟪ #Variable1# : #Sort2# ⟫; #SubstituteSorts), #n, #post, #makeForm]
→
%n⟪«
  $[If, #makeForm, %n⟨ v†‹$[FormatNumber,#n]›::†‹ SortName[#Sort1#] ›⟩, %n⟨ v†‹$[FormatNumber,#n]›⟩]
»«
  {#ND}CRS-Binders-SubstituteSorts[#SubstituteSorts, $[Plus,#n,1], %n⟨ .⟩, #makeForm]
»⟫
;

// Helper for pattern meta-application arguments.
CRS-FormScopeMetaApplication[Text, $List[RawSubstituteSort], $Boolean] :: Text;
CRS-FormScopeMetaApplication[#mv, #SubstituteSorts, #Dummy] → %n⟪«#mv»« CRS-FormScopeMetaApplication2[#SubstituteSorts, #Dummy, 1, %n⟨[⟩, %n⟨⟩] »⟫ ;

CRS-FormScopeMetaApplication2[$List[RawSubstituteSort], $Boolean, $Numeric, Text, Text] :: Text;
CRS-FormScopeMetaApplication2[(), #Dummy, #n, #pre, #post] → #post ;
CRS-FormScopeMetaApplication2[(%rawSubstituteSort⟪ #Variable1# : #Sort2# ⟫; #SubstituteSorts), #Dummy, #n, #pre, #post]
→
%n⟪« #pre »« $[If, #Dummy, %n⟨v†‹$[FormatNumber,#n]›⟩, %n⟨†‹ #Variable1# ›⟩] »« CRS-FormScopeMetaApplication2[#SubstituteSorts, #Dummy, $[Plus,#n,1], %n⟨, ⟩, %n⟨]⟩] »⟫
;

{$String : SortEntry} CRS-ParsedForm-ParsedForm[RawParsedForm, $Boolean, $Boolean, ok::Ok s::RawSort p::$Numeric q::Text r::RawRepeat.Text, $Numeric] :: Text;

{#ND}CRS-ParsedForm-ParsedForm[RAW-ParsedFormDone, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n] → %n⟪⟫ ;

-[Data[#Space1]]:
{#ND}CRS-ParsedForm-ParsedForm[RAW-ParsedFormSpace[#Space1, #ParsedForm1], #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n]
→
$[If, #Sorted,
 %n⟪ « {#ND}CRS-ParsedForm-ParsedForm[#ParsedForm1, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n] »⟫,
 %n⟪« $[If,$[Contains,#Space1,"¶"], CRS-Embed["", %n⟨NewLine⟩], %n⟨ ⟩] »« {#ND}CRS-ParsedForm-ParsedForm[#ParsedForm1, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n] »⟫]
;
riable1# : 
{#ND}CRS-ParsedForm-ParsedForm[RAW-ParsedFormWord[#Word1, #ParsedForm1], #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n]
→
%n⟪†« #Word1 »« {#ND}CRS-ParsedForm-ParsedForm[#ParsedForm1, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n] »⟫
;

{#ND}CRS-ParsedForm-ParsedForm[RAW-ParsedFormTerm[%rawScopeSort⟪ [ #Variable1# : #Sort1# ] ⟫, #Prec1, #Repeat1, #ParsedForm1], #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n]
→
$[If, #Sorted,
 %n⟪†«"\u27e8"»†«SortName[#Sort1#]»"†« #Variable1# »"†«"\u27e9"» « {#ND; #Variable1# : #Sort1#}CRS-ParsedForm-ParsedForm[#ParsedForm1, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n] »⟫,
 %n⟪†«"\u27e8"»†«#Variable1#»†«"\u27e9"» « {#ND; #Variable1# : #Sort1#}CRS-ParsedForm-ParsedForm[#ParsedForm1, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n] »⟫]
;
// NOTE: the above is a real CRSX hack to achieve the strange CRSX3 variable sorting notation: the internal variable name is created as a string.

{#ND}CRS-ParsedForm-ParsedForm[RAW-ParsedFormTerm[%rawScopeSort⟪ #Sort1# #Repeat1# [ #SubstituteSorts1# ] ⟫, #Prec1, #Repeat1, #ParsedForm1], #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], #n]
→
%n⟪†«"\u27e8"»†«
 $[If, #Sorted, SortRepeatString[SortName[#Sort1#], NestedRepeat[#Repeat1#, #Repeat1]], ""]
»«
 $[If, #makeForm,
     {#ND}CRS-ScopeBinderSort1[#SubstituteSorts1#, #Sort1#, NestedRepeat[#Repeat1#, #Repeat1]],
     #Wrap[OK, #Sort1#, #Prec1, CRS-FormScopeMetaApplication[CRS-SortMetaVar[#Sort1#, #n], #SubstituteSorts1#, $False<!--bound-->], NestedRepeat[#Repeat1#, #Repeat1]]]
»†«"\u27e9"» «
 {#ND}CRS-ParsedForm-ParsedForm[#ParsedForm1, #Sorted, #makeForm, ok s p q r.#Wrap[ok,s,p,q,r], $[Plus,#n,1]]
»⟫
;


/////////////////////////////////////////////////////////////////////
// TEXT OF RULES BY ATTRIBUTE/SORT/TOKEN NAME.

{$String : SortEntry} CRS-Rules[NameSet, $String] :: Text;
{#ND}CRS-Rules[#Names, #ParsePrefix] → {#ND}CRS-Rules1[HasNames[#Names], #Names, #ParsePrefix] ;

{$String : SortEntry} CRS-Rules1[Boolean, NameSet, $String] :: Text;

{#ND}CRS-Rules1[B_FALSE, #Names, #ParsePrefix] → %n⟪⟫ ;

{#ND}CRS-Rules1[B_TRUE , #Names, #ParsePrefix]
→
%n⟪« {#ND}CRS-Rule[FirstName[#Names], #ParsePrefix] »
« {#ND}CRS-Rules[RemoveFirstName[#Names], #ParsePrefix] »⟫
;

{$String : SortEntry} CRS-Rule[$String, $String] :: Text;
-[Data[#Name]]:
{#ND}CRS-Rule[#Name,#ParsePrefix] 
→
{#ND}CRS-Rule1[$[{#ND}Get[SortEntry], #Name, SE_NONE], #ParsePrefix]
;

{$String : SortEntry} CRS-Rule1[SortEntry, $String] :: Text;

{#ND}CRS-Rule1[SE_NONE, #ParsePrefix] → %n⟪⟫ ;

// Token declaration.

{#ND}
CRS-Rule1[SE_TOKEN[#Name], #ParsePrefix] → %n⟪
<!-- All declarations for †«#Name» token sort. -->
$Drop-†«#Name»[†«#Name»] :: Text ;
$Drop-†«#Name»[#] → $TextCons[$TextChars[#], $TextNil] ;

$Print-†«#Name»[†«#Name»] :: Text ;
-[Data[#]]: $Print-†«#Name»[#] → $PrintP-†«#Name»[#, 0] ;

$PrintP-†«#Name»[†«#Name», $Numeric] :: Text ;
$PrintP-†«#Name»[#, #Prec] → $TextCons[$TextChars[#], $TextNil] ;
⟫;

// TODO: Allow text read/show actions for tokens.

{#ND}CRS-Rule1[SE_ATTRIBUTE[#Kind, #Name, %rawAttributeForm⟪ ( #Sort# ) ⟫, #Options], #ParsePrefix]
→
%n⟪⟫
;
{#ND}CRS-Rule1[SE_ATTRIBUTE[#Kind, #Name, %rawAttributeForm⟪ { #Sort#  } ⟫, #Options], #ParsePrefix]
→
%n⟪⟫
;
{#ND}CRS-Rule1[SE_ATTRIBUTE[#Kind, #Name, %rawAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #Options], #ParsePrefix]
→
%n⟪⟫
;

// Sort declaration:
//
// Define top level $Print and $Drop functions.

{#ND}
CRS-Rule1[SE_SORT[#Defines, #Name, #Precs, #Wrapper], #ParsePrefix]
→
%n⟪
<!-- All rules for †«#Name» sort. -->
$Drop-†«#Name»[#] → $TextCons[$TextChars["OK"], $TextNil] ;
-[Data[#]]: $Print-†«#Name»[#] → $PrintP-†«#Name»[#, 0] ;
$PrintP-†«#Name»[v, #Prec] → $TextCons[$TextEmbed[v], $TextNil] ;

<!--Precedence wrappers.-->
« CRS-Rules-PrecWrapper[#Name, #ParsePrefix, #Wrapper] »
<!--Defined synthetic.-->
« TextFold[MapWhen[ok a.{#ND}CRS-Rules-DefineSynth[ok, a, ProductionName[#Name]], NameSetList[DefinesSynthesize[#Defines, NoNames]]], %n⟨<!--AND-->⟩] »
<!--Contained Rules.-->
« {#ND}CRS-Rules-Defines[#Defines, DefinesSynthesize[#Defines, NoNames], #Name, #ParsePrefix, #Wrapper] »
⟫;

CRS-Rules-PrecWrapper[$String, $String, Wrapper] :: Text;

CRS-Rules-PrecWrapper[#Name, #ParsePrefix, NoWrapper]
→ %n⟪⟫;

CRS-Rules-PrecWrapper[#Name, #ParsePrefix, Wrapper[#ParsedForm]]
→ %n⟪-[Data[#Prec,#InnerPrec]]: $PrecWrap-†«#Name»[#Prec, #InnerPrec, #] → $[If, $[LessThanOrEqual, #Prec, #InnerPrec], #, ⟦«
  CRS-Text[{} CRS-ParsedForm-ParsedForm[#ParsedForm, $False<!--Unsorted-->, $False<!--NotForm-->, ok s p q r.%n⟨#⟩, 1]]
»⟧] ;
⟫;

{$String : SortEntry} CRS-Rules-DefineSynth[Ok, $String<!--attribute-->, Text] :: Text;
{#ND; "$AllSynthesizedMapNames" : NAMES[#SynthesizedMapNames]}
CRS-Rules-DefineSynth[OK, #attribute, #ProductionName]
→
%n⟪-[Priority]: «NeedsSynthesizedName[#attribute]»[{"†«#attribute»" : #a}#] → # ;
⟫
;

{$String : SortEntry} CRS-Rules-Defines[$List[Define], NameSet, $String, $String, Wrapper] :: Text;
{#ND}CRS-Rules-Defines[(), #Synthesizes, #Name, #ParsePrefix, #Wrapper] → %n⟪⟫ ;
{#ND}CRS-Rules-Defines[(#Define; #Defines), #Synthesizes, #Name, #ParsePrefix, #Wrapper]
→
%n⟪« {#ND}CRS-Rules-Define[#Define, #Synthesizes, #Name, #ParsePrefix, #Wrapper, ()] »« {#ND}CRS-Rules-Defines[#Defines, #Synthesizes, #Name, #ParsePrefix, #Wrapper] »⟫
;

// Abstractions recorded (for sort declarations).

{$String : SortEntry} CRS-Rules-Define[Define, NameSet, $String, $String, Wrapper, $List[RawSortParam]] :: Text;

-[Fresh[param::RawSortParam]]:
{#ND}CRS-Rules-Define[D_ABSTRACTION[a.#Define[a]], #Synthesizes, #Name, #ParsePrefix, #Wrapper, #params]
→
{#ND}CRS-Rules-Define[#Define[param], #Synthesizes, #Name, #ParsePrefix, #Wrapper, Append[#params, (param;)]]
;

{#ND}
CRS-Rules-Define[D_FORM[#Form, FK_DATA[#Tagging]], #Synthesizes, #Name, #ParsePrefix, #Wrapper, #params]
→
%n⟪$PrintP-†« #Name »[«
  {#ND}CRS-Term-Form[#Form, #Name, #ParsePrefix, $True<!--Sorted-->, $False<!--Pattern-->, $False<!--NoInherit-->, ok s p q r.q]
», #Prec] → «
  {#ND}CRS-DefineDataPrint[#Form, FormPrec[#Form], #Name, #ParsePrefix, #params]
»;

« TextFold[MapWhen[ok a.{#ND}CRS-Rules-DataSynth[ok, a, #Name, ProductionName[#Name], #Form, #ParsePrefix], NameSetList[#Synthesizes]], %n⟨⟩] »
⟫
;

{$String : SortEntry} CRS-DefineDataPrint[RawForm, $Numeric, $String, $String, $List[RawSortParam]] :: Text;
-[Data[#Prec]]:
{#ND}CRS-DefineDataPrint[#Form, #Prec, #Name, #ParsePrefix, #params]
→
$[If, $[LessThan, 0, #Prec],
  %n⟪$PrecWrap-†«#Name»[#Prec, « NumberToText[FormPrec[#Form]] », «
    {#ND}CRS-Term-Form[#Form, #Name, "n", $False<!--UnSorted-->, $False<!--Pattern-->, $False<!--NoInherit-->, ok s p q r.CRS-then-PrintP[ok, SortName[s], p, q, r]] »]⟫,
  {#ND}CRS-Term-Form[#Form, #Name, "n", $False<!--UnSorted-->, $False<!--Pattern-->, $False<!--NoInherit-->, ok s p q r.CRS-then-PrintP[ok, SortName[s], p, q, r]]]
;

CRS-then-PrintP[Ok, $String, $Numeric, Text, RawRepeat] :: Text;
-[Data[#Name,#Prec,#Quoted,#Repeat]]:
CRS-then-PrintP[OK, #Name, #Prec, #Quoted, #Repeat]
→
%n⟪ $PrintP-« ProductionNameWithPrecRepeat[#Name, 0, #Repeat] »[« #Quoted », «NumberToText[#Prec]»] ⟫ 
;

{$String : SortEntry}CRS-Rules-DataSynth[Ok, $String, $String, Text, RawForm, $String] :: Text;
{#ND}CRS-Rules-DataSynth[OK, #AttributeName, #SortName, #ProductionName, #Form, #ParsePrefix]
→
%n⟪«NeedsSynthesizedName[#AttributeName]»[{#Synthesized}«
   {#ND}CRS-Term-Form[#Form, #SortName, #ParsePrefix, $True<!--Sorted-->, $False<!--Pattern-->, $False<!--NoInherit-->, ok s p q r.q]
  »] →  «CollectSynthesizedName[#AttributeName]»[{#Synthesized}«
   {#ND}CRS-Term-Form[#Form, #SortName, #ParsePrefix, $True<!--Sorted-->, $False<!--Pattern-->, $False<!--NoInherit-->, ok s p q r.{#ND}CRS-then-Rules-DataSynth-Need[ok, SortName[s], r, #AttributeName, q]]
  »] ;
⟫
;

// Reenable again when Fallback works.
///-[Fallback]:
///«CollectSynthesizedName[#ProductionName, #AttributeName]»[{#Synthesized}«
///   {#ND}CRS-Term-Form[#Form, #SortName, #ParsePrefix, $True<!--Sorted-->, $False<!--Pattern-->, $False<!--NoInherit-->, ok s p q r.{#ND}CRS-then-Rules-DataSynth-Got[ok, SortName[s], r, #AttributeName, q]]
///  »]
/// →  {#Synthesized}« CRS-then-Rules-DataSynth-Fold[OK, #ProductionName, #AttributeName, {#ND}CRS-ArgList-Form[#Form, #SortName, ok s p q r.{#ND}CRS-then-Rules-DataSynth-It[ok, SortName[s], r, #AttributeName, q]],
///                      {#ND}CRS-Term-Form[#Form, #SortName, #ParsePrefix, $True<!--Sorted-->, $False<!--Pattern-->, $False<!--NoInherit-->, ok s p q r.q]] » ;

{$String : SortEntry} CRS-then-Rules-DataSynth-Need[Ok, $String, RawRepeat, $String, Text] :: Text;
{#ND} CRS-then-Rules-DataSynth-Need[OK, #Name, #Repeat, #AttributeName, #Body]
→
{#ND} IfSortSynthesizes[#Name, #AttributeName, %n⟪ «NeedsSynthesizedName[#AttributeName]»[«#Body»]⟫, #Body]
;
{$String : SortEntry} CRS-then-Rules-DataSynth-Got[Ok, $String, RawRepeat, $String, Text] :: Text;
{#ND} CRS-then-Rules-DataSynth-Got[OK, #Name, #Repeat, #AttributeName, #Body]
→
{#ND} IfSortSynthesizes[#Name, #AttributeName, %n⟪ {"†«#AttributeName»" : «SynthesizedName[#AttributeName]»[«#Body»†«#AttributeName»]}«#Body»⟫, #Body]
;
{$String : SortEntry} CRS-then-Rules-DataSynth-It[Ok, $String, RawRepeat, $String, Text] :: Text;
{#ND} CRS-then-Rules-DataSynth-It[OK, #Name, #Repeat, #AttributeName, #Body]
→
{#ND} IfSortSynthesizes[#Name, #AttributeName, %n⟪ «#Body»†«#AttributeName»⟫, %n⟪ Unit-†«#AttributeName»⟫]
;

CRS-then-Rules-DataSynth-Fold[Ok, Text, $String, $List[Text], Text] :: Text;
CRS-then-Rules-DataSynth-Fold[OK, #ProductionName, #AttributeName, #List, #Body]
→
%n⟪«SetSynthesizedName[#AttributeName]»[« CRS-Rules-DataSynth-Fold2[#AttributeName, #List] », « #Body »] ;
⟫;

CRS-Rules-DataSynth-Fold2[$String, $List[Text]] :: Text;
CRS-Rules-DataSynth-Fold2[#AttributeName, ()] → %n⟪Unit-†‹#AttributeName›⟫ ;
CRS-Rules-DataSynth-Fold2[#AttributeName, (#AV1;)] → #AV1 ;
-[Data[#AttributeName]]:
CRS-Rules-DataSynth-Fold2[#AttributeName, (#AV1; #AV2; #AVs)]
→
If[SameString[Trim[TextToString[#AV1]], $[Trim,$[:,"Unit-",#AttributeName]]], CRS-Rules-DataSynth-Fold2[#AttributeName, (#AV2; #AVs)],
  %n⟪Join-†«#AttributeName»[«#AV1», « CRS-Rules-DataSynth-Fold2[#AttributeName, (#AV2; #AVs)] »]⟫
];

{$String : SortEntry} IfSortSynthesizes[$String, $String, Text, Text] :: Text;
{#ND} IfSortSynthesizes[#Name, #AttributeName, #Yes, #No] → If[ContainsName[{#ND} SortSynthesizes[#Name], #AttributeName], #Yes, #No] ;

{$String : SortEntry} SortSynthesizes[$String] :: NameSet;
-[Data[#Name]]:
{#ND} SortSynthesizes[#Name] → SortSynthesizes2[$[{#ND}Get[SortEntry], #Name, SE_NONE]] ;

SortSynthesizes2[SortEntry] :: NameSet;
SortSynthesizes2[SE_SORT[#Defines, #Name, #Precs, #Wrapper]] → DefinesSynthesize[#Defines, NoNames] ;
SortSynthesizes2[SE_TOKEN[#Name]] → NoNames ;
-[Data[#_]]: SortSynthesizes2[$[NotMatch,SE_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], $[NotMatch,SE_TOKEN[#Name2],#_]]] → NoNames ;

DefinesSynthesize[$List[Define], NameSet] :: NameSet ;
-[Fresh[dummy::RawSortParam]]:
DefinesSynthesize[(D_ABSTRACTION[a.#Define[a]]; #Defines), #NameSet] → DefinesSynthesize[(#Define[dummy]; #Defines), #NameSet] ;
DefinesSynthesize[(D_SYNTHESIZES[#AttributeName]; #Defines), #NameSet] → DefinesSynthesize[#Defines, AddName[#NameSet, #AttributeName]] ;
DefinesSynthesize[(D_FORM[#Form, #fk]; #Defines), #NameSet] → DefinesSynthesize[#Defines, #NameSet] ;
DefinesSynthesize[(D_RULE[#RawRule, #sort, #IsDataEquivalence]; #Defines), #NameSet] → DefinesSynthesize[#Defines, #NameSet] ;
DefinesSynthesize[(D_NONE; #Defines), #NameSet] → DefinesSynthesize[#Defines, #NameSet] ;
DefinesSynthesize[(), #NameSet] → #NameSet ;

{#ND}CRS-Rules-Define[D_FORM[#Form, FK_SYMBOL[#IsStatic]], #Synthesizes, #Name, #ParsePrefix, #Wrapper, #params] → %n⟪⟫ ;

{#ND}CRS-Rules-Define[D_FORM[#Form, FK_SCHEME[#Inh]], #Synthesizes, #Name, #ParsePrefix, #Wrapper, #params]
→
MapWrapperConstruction[#Form, c ss ihs.%n⟪$SortFor-Action-†«c» → « CRS-Text[%n⟨†‹ ScopeSortName[ss] ›⟩] » ;
$Print-Action-†«c»« {#ND}CRS-FormScopeSorts[(ss;), #Name, $False<!--Pattern-->, ok s p q r.q, %n⟨[⟩, %n⟨⟩, 1]
» → $Print-†«#Name»[_InitInheritedMaps[†«c»« {#ND}CRS-FormScopeSorts[(ss;), #Name, $False<!--Pattern-->, ok s p q r.q, %n⟨[⟩, %n⟨⟩, 1] »]];
⟫]
;

// Aliases are eliminated by parser.
{#ND}CRS-Rules-Define[D_FORM[#Form, FK_ALIAS], #Synthesizes, #Name, #ParsePrefix, #Wrapper, #params] → %n⟪⟫ ;

// A sugar form declaration generates a meta-rule to eliminate the sugar.
{#ND}CRS-Rules-Define[{#L}D_FORM[#Form, FK_SUGAR[#Term]], #Synthesizes, #Name, #ParsePrefix, #Wrapper, #params]
→
%n⟪<!--#L †« {#L}MakeLocation »-->« {#ND}CRS-Term-Form[#Form, #Name, #ParsePrefix, $True<!--Sorted-->, $False<!--Pattern-->, $True<!--TopInherit-->, ok s p q r.q]
» → « {#ND}CRS-Term[#Term, #Name, #ParsePrefix, RM_ONLY_TOP, $False<!--NoPattern-->, $True<!--SprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]] » ;
$Meta[({#Inherited}« {#ND}CRS-Term-Form[#Form, #Name, #ParsePrefix, $True<!--Sorted-->, $False<!--Pattern-->, $False<!--NoTopInherit-->, ok s p q r.q] »†«""
» → « {#ND}CRS-Term[#Term, #Name, #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $True<!--SprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]] » ;)];
⟫
;

// Synthesized attribute...
{#ND}CRS-Rules-Define[D_SYNTHESIZES[#AttributeName], #Synthesizes, #Name, #ParsePrefix, #Wrapper, #params] → %n⟪⟫ ;

// A rule (already supposed declared by the scheme declaration).
{#ND}CRS-Rules-Define[D_RULE[#Rule, #SortName, #IsData], #Synthesizes, #Name, #ParsePrefix, #Wrapper, #params] → {#ND}CRS-Rules-Rule[#Rule, #SortName, #IsData, #ParsePrefix] ;


/////////////////////////////////////////////////////////////////////
// TEXT OF INDIVIDUAL DECLARATIONS.

// Helpers for list sorts.
{$String : SortEntry} CRS-ScopeBinderSort1[$List[RawSubstituteSort], RawSort, RawRepeat] :: Text;
{#ND}CRS-ScopeBinderSort1[(), #Sort, #Repeat] → IfSingletonRepeat[#Repeat, %n⟪⟫, %n⟪ $List[†« SortName[#Sort] »]⟫] ;
{#ND}CRS-ScopeBinderSort1[(%rawSubstituteSort⟪ #Variable1# : #Sort2# ⟫; #SubstituteSorts), #Sort, #Repeat] →  %n⟪{†« #Variable1# » : †« SortName[#Sort2#] »« {#ND}CRS-ScopeBinderSort2[#SubstituteSorts] »}« CRS-RepeatSort[#Repeat, #Sort] »⟫ ;

{$String : SortEntry} CRS-ScopeBinderSort2[$List[RawSubstituteSort]] :: Text;
{#ND}CRS-ScopeBinderSort2[()] → %n⟪⟫ ;
{#ND; #Variable1# : #Sort1#}CRS-ScopeBinderSort2[(%rawSubstituteSort⟪ #Variable1# : #Sort2# ⟫; #SubstituteSorts)] →  %n⟪, †« SortVar[#Sort1#] » : †« SortName[#Sort2#] »« {#ND}CRS-ScopeBinderSort2[#SubstituteSorts] »⟫ ;

CRS-RepeatSort[RawRepeat, RawSort] :: Text;
CRS-RepeatSort[#Repeat, #Sort] → IfSingletonRepeat[#Repeat, %n⟪†« SortName[#Sort] »⟫, %n⟪$List[†« SortName[#Sort] »]⟫] ;

CRS-SortMetaVar[RawSort, $Numeric] :: Text;
CRS-SortMetaVar[#Sort, #n] → %n⟨†‹SortMetaVar[#Sort, #n]›⟩ ;

/// // Helper: generate list of the arguments in a form, each generated by wrapper.
/// 
/// {$String : SortEntry} CRS-ArgList-Form[RawForm, $String, ok::Ok s::RawSort p::$Numeric q::Text r::RawRepeat.Text] :: $List[Text];
/// 
/// {#ND}CRS-ArgList-Form[RAW-FormParsedSorted[#Sort, #ParsedForm, #Prec, #InheritedRefs], #Name, ok s p q r.#Wrap[ok,s,p,q,r]]
/// →
/// {#ND}CRS-ArgList-ParsedForm[#ParsedForm, ok s p q r.#Wrap[ok,s,p,q,r], 1]
/// ;
/// 
/// {#ND}CRS-ArgList-Form[RAW-FormParsedUnsorted[#ParsedForm, #Prec, #InheritedRefs], #Name, ok s p q r.#Wrap[ok,s,p,q,r]]
/// →
/// {#ND}CRS-ArgList-ParsedForm[#ParsedForm, ok s p q r.#Wrap[ok,s,p,q,r], 1]
/// ;
/// 
/// {#ND}CRS-ArgList-Form[RAW-FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Name, ok s p q r.#Wrap[ok,s,p,q,r]]
/// →
/// {#ND}CRS-ArgList-ScopeSorts[#ScopeSorts, #Name, ok s p q r.#Wrap[ok,s,p,q,r], 1]
/// ;
/// 
/// {$String : SortEntry} CRS-ArgList-ScopeSorts[$List[RawScopeSort], $String, ok::Ok s::RawSort p::$Numeric q::Text r::RawRepeat.Text, $Numeric] :: $List[Text];
/// 
/// {#ND}CRS-ArgList-ScopeSorts[(), #Name, ok s p q r.#Wrap[ok,s,p,q,r], #n] → ();
/// 
/// {#ND}CRS-ArgList-ScopeSorts[(%rawScopeSort⟪ #Sort1# [ #SubstituteSorts1# ] ⟫; #ScopeSorts), #Name, ok s p q r.#Wrap[ok,s,p,q,r], #n]
/// →
/// ( %n⟪«
///     {#ND}CRS-Binders-SubstituteSorts[#SubstituteSorts1#, 1, %n⟨⟩, $False]
///   »«
///     #Wrap[OK, #Sort1#, 0, CRS-FormScopeMetaApplication[CRS-SortMetaVar[#Sort1#, #n], #SubstituteSorts1#, $True<!--vN-->], %rawRepeat⟪ ⟫]
///   »⟫ ;
///   {#ND}CRS-ArgList-ScopeSorts[#ScopeSorts, #Name, ok s p q r.#Wrap[ok,s,p,q,r], $[Plus,#n,1]] )
/// ;
/// 
/// {$String : SortEntry} CRS-ArgList-ParsedForm[RawParsedForm, ok::Ok s::RawSort p::$Numeric q::Text r::RawRepeat.Text, $Numeric] :: $List[Text];
/// 
/// {#ND}CRS-ArgList-ParsedForm[RAW-ParsedFormDone, ok s p q r.#Wrap[ok,s,p,q,r], #n] → () ;
/// 
/// {#ND}CRS-ArgList-ParsedForm[RAW-ParsedFormSpace[#Space1, #ParsedForm1], ok s p q r.#Wrap[ok,s,p,q,r], #n]
/// →
/// {#ND}CRS-ArgList-ParsedForm[#ParsedForm1, ok s p q r.#Wrap[ok,s,p,q,r], #n]
/// ;
/// 
/// {#ND}CRS-ArgList-ParsedForm[RAW-ParsedFormWord[#Word1, #ParsedForm1], ok s p q r.#Wrap[ok,s,p,q,r], #n]
/// →
/// {#ND}CRS-ArgList-ParsedForm[#ParsedForm1, ok s p q r.#Wrap[ok,s,p,q,r], #n]
/// ;
/// 
/// {#ND}CRS-ArgList-ParsedForm[RAW-ParsedFormTerm[%rawScopeSort⟪ [ #Variable1# : #Sort1# ] ⟫, #Prec1, #Repeat1, #ParsedForm1], ok s p q r.#Wrap[ok,s,p,q,r], #n]
/// →
/// {#ND}CRS-ArgList-ParsedForm[#ParsedForm1, ok s p q r.#Wrap[ok,s,p,q,r], #n]
/// ;
/// 
/// {#ND}CRS-ArgList-ParsedForm[RAW-ParsedFormTerm[%rawScopeSort⟪ #Sort1# #Repeat1# [ #SubstituteSorts1# ] ⟫, #Prec1, #Repeat1, #ParsedForm1], ok s p q r.#Wrap[ok,s,p,q,r], #n]
/// →
/// ( %n⟪«
///     {#ND}CRS-Binders-SubstituteSorts[#SubstituteSorts1#, 1, %n⟨⟩, $False]
///   »«
///     #Wrap[OK, #Sort1#, #Prec1, CRS-FormScopeMetaApplication[CRS-SortMetaVar[#Sort1#, #n], #SubstituteSorts1#, $False<!--bound-->], NestedRepeat[#Repeat1#, #Repeat1]]
///   »⟫ ;
///   {#ND}CRS-ArgList-ParsedForm[#ParsedForm1, ok s p q r.#Wrap[ok,s,p,q,r], $[Plus,#n,1]] )
/// ;

{$String : SortEntry} CRS-Rules-Rule[RawRule, $String, Boolean, $String] :: Text;
{#ND}CRS-Rules-Rule[%rawRule⟪ #Priority# #Construction1# : #Construction2# → %Term«OMITTED» ⟫, #SortName, #IsData, #ParsePrefix] 
→
{#ND}CRS-SynthesizeRule[#Construction1#, #Construction2#, #Priority#, #SortName, #ParsePrefix]
;
{#ND}CRS-Rules-Rule[%rawRule⟪ #Priority# #Construction1# : #Construction2# → %Term«$[NotMatch,OMITTED,#Term#]» ⟫, #SortName, #IsData, #ParsePrefix] 
→
{#ND}CRS-RewriteRule[#Construction1#, #Construction2#, #Term#, #SortName, #Priority#, #IsData, #ParsePrefix]
;

// Scheme rule.
//
// The rule already has the right shape for CRSX.

{$String : SortEntry} CRS-RewriteRule[RawTerm<!--Name+Options-->, RawTerm<!--Pattern-->, RawTerm<!--Contraction-->, $String<!--SortName-->, RawPriority, Boolean<!--IsData-->, $String<!--ParsePrefix-->] :: Text;
-[Data[#Pattern]]:
{#ND}CRS-RewriteRule[#NameOptions#, #Pattern#, #Contraction#, #SortName, #Priority, #IsData, #ParsePrefix]
→
%n⟪« {#ND}CRS-NameOptions[#NameOptions#, "", #Priority, #ParsePrefix] »
« {#ND}CRS-Term[#Pattern#, #SortName, #ParsePrefix, RM_ONLY_TOP, $True<!--Pattern-->, $False<!--NoSprayInherited-->, "", ok s t as . t] »
→
« {#ND}CRS-Term[#Pattern#, #SortName, #ParsePrefix, RM_ONLY_TOP, $False<!--NoPattern-->, $True<!--SprayInherited-->, "-Needy", ok s t as . CRS-AddSynthesisNeeds[ok, t, as, s, #ParsePrefix]] »
;
« {#ND}CRS-NameOptions[#NameOptions#, "-Needy", #Priority, #ParsePrefix] »
« {#ND}CRS-Term[#Pattern#, #SortName, #ParsePrefix, RM_ONLY_TOP, $True<!--Pattern-->, $False<!--NoSprayInherited-->, "-Needy", ok s t as . {#ND}CRS-MatchSynthesisNeeds[ok, t, as, s, #ParsePrefix]] »
→
« {#ND}CRS-Term[#Contraction#, #SortName, #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $True<!--SprayInherited-->, "", ok s t as . {#ND}CRS-AddAttributes[ok, t, as, s, #ParsePrefix]] »
;
⟫;


/// %n⟪« {#ND}CRS-NameOptions[#NameOptions#, #Priority, #ParsePrefix] »
/// « {#ND}CRS-Term[#Pattern#, #Name, #ParsePrefix, RM_ONLY_TOP, $False<!--NoCapturePattern-->, $False<!--NoSprayInherited-->, $False<!--DonotIncludeSynthesized-->] »
/// →
/// {#Inherited}InitInheritedMaps[ok._FreeVariableArguments[«
///      {#ND}CRS-Term[#Pattern#, #Name, #ParsePrefix, RM_NONE, $False<!--NoCapturePattern-->, $False<!--NoSprayInherited-->, $False<!--DonotIncludeSynthesized-->]
///   », T«emp»[ok« WrappedTextFold[Append[
///     {#ND}CRS-ArgList-Attributes[CRS-Term-Attributes[#Pattern#], #ParsePrefix, $True, ok s t as . CRS-AddSynthesisNeeds[ok, t, as, s, #ParsePrefix]],
///     {#ND}CRS-ArgList-Term[#Pattern#, #SortName, #ParsePrefix, $True<!--includesynthesized-->, ok s t as . CRS-AddSynthesisNeeds[ok, t, as, s, #ParsePrefix], ()]],
///   %n⟨, ⟩, %n⟨, ⟩, %n⟨⟩] »]]]
/// ;
/// {#Inherited« {#ND}N-CaptureOtherMaps[()] »}
/// _FreeVariableArguments[«
///      {#ND}CRS-Term[#Pattern#, #Name, #ParsePrefix, RM_NONE, $False<!--NoCapturePattern-->, $False<!--NoSprayInherited-->, $False<!--DonotIncludeSynthesized-->]
///   », T«emp»[OK« WrappedTextFold[Append[
///     {#ND}CRS-ArgList-Attributes[CRS-Term-Attributes[#Pattern#], #ParsePrefix, $True, ok s t as . {#ND}CRS-MatchSynthesisNeeds[ok, t, as, s, #ParsePrefix]],
///     {#ND}CRS-ArgList-Term[#Pattern#, #SortName, #ParsePrefix, $True<!--includesynthesized-->, ok s t as . {#ND}CRS-MatchSynthesisNeeds[ok, t, as, s, #ParsePrefix], ()]],
///   %n⟨, ⟩, %n⟨, ⟩, %n⟨⟩] »]]
/// →
/// « {#ND}CRS-Term[#Contraction#, #SortName, #ParsePrefix, RM_ALL, $False<!--NoCapturePattern-->, $True<!--SprayInherited-->, $True<!--IncludeSynthesized-->] »
/// ;
/// ⟫;

{$String : SortEntry} CRS-TermAttributes[Ok, Text, $List[RawAttribute],  $String, $String] :: Text;
{#ND} CRS-TermAttributes[OK, #Term, #Attributes, #Name, #ParsePrefix]
→
%n⟪« {#ND}CRS-Attributes1[#Attributes, #ParsePrefix, $False, ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]] »« #Term »⟫
;

CRS-AddSynthesisNeeds[Ok, Text, $List[RawAttribute],  $String<!--Sort-->, $String] :: Text;
CRS-AddSynthesisNeeds[OK, #Term, (%rawAttribute⟪ ↑ #AttributeName# #AttributeValue# ⟫; #Attributes), #Name, #ParsePrefix]
→
%n⟪« NeedsSynthesizedName[#AttributeName#] »[« CRS-AddSynthesisNeeds[OK, #Term, #Attributes, #Name, #ParsePrefix] »]⟫
;
CRS-AddSynthesisNeeds[OK, #Term, (%rawAttribute⟪ ↓ #AttributeName# #AttributeValue# ⟫; #Attributes), #Name, #ParsePrefix]
→
CRS-AddSynthesisNeeds[OK, #Term, #Attributes, #Name, #ParsePrefix]
;
CRS-AddSynthesisNeeds[OK, #Term, (), #Name, #ParsePrefix]
→
#Term
;

{$String : SortEntry} CRS-MatchSynthesisNeeds[Ok, Text, $List[RawAttribute],  $String, $String] :: Text;
{#ND}CRS-MatchSynthesisNeeds[OK, #Term, #Attributes, #Name, #ParsePrefix]
→
%n⟪« {#ND}CRS-Attributes1[#Attributes, #ParsePrefix, $False, ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]] »« #Term »⟫
;

{$String : SortEntry} CRS-AddAttributes[Ok, Text, $List[RawAttribute],  $String, $String] :: Text;

{#ND}CRS-AddAttributes[OK, #Term, (), #Name, #ParsePrefix]
→
#Term
;

{#ND}CRS-AddAttributes[OK, #Term, ( %rawAttribute⟪ ↓ #AttributeName# ( #Term# ) ⟫ ; #Attributes), #Name, #ParsePrefix]
→
%n⟪«SetInheritedName[#AttributeName#] »[« {#ND}CRS-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $True<!--SprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]] », «
  {#ND}CRS-AddAttributes[OK, #Term, #Attributes, #Name, #ParsePrefix] »]⟫
;
{#ND}CRS-AddAttributes[OK, #Term, ( %rawAttribute⟪ ↑ #AttributeName# ( #Term# ) ⟫ ; #Attributes), #Name, #ParsePrefix]
→
%n⟪«SetSynthesizedName[#AttributeName#] »[« {#ND}CRS-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $True<!--SprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]] », «
  {#ND}CRS-AddAttributes[OK, #Term, #Attributes, #Name, #ParsePrefix] »]⟫
;

{#ND}CRS-AddAttributes[OK, #Term, ( %rawAttribute⟪ ↓ #AttributeName# { #Term# } ⟫ ; #Attributes), #Name, #ParsePrefix]
→
%n⟪«AddInheritedName[#AttributeName#] »[« {#ND}CRS-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $True<!--SprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]] », OK, «
  {#ND}CRS-AddAttributes[OK, #Term, #Attributes, #Name, #ParsePrefix] »]⟫
;
{#ND}CRS-AddAttributes[OK, #Term, ( %rawAttribute⟪ ↑ #AttributeName# { #Term# } ⟫ ; #Attributes), #Name, #ParsePrefix]
→
%n⟪«AddSynthesizedName[#AttributeName#] »[« {#ND}CRS-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $True<!--SprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]] », OK, «
  {#ND}CRS-AddAttributes[OK, #Term, #Attributes, #Name, #ParsePrefix] »]⟫
;

{#ND}CRS-AddAttributes[OK, #Term, ( %rawAttribute⟪ ↓ #AttributeName# { #Term1# : #Term2# } ⟫ ; #Attributes), #Name, #ParsePrefix]
→
%n⟪«AddInheritedName[#AttributeName#] »[«
  {#ND}CRS-Term[#Term1#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $False<!--NoSprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]]
», «
  {#ND}CRS-Term[#Term2#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $True<!--SprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]]
», «
  {#ND}CRS-AddAttributes[OK, #Term, #Attributes, #Name, #ParsePrefix]
»]⟫
;
{#ND}CRS-AddAttributes[OK, #Term, ( %rawAttribute⟪ ↑ #AttributeName# { #Term1# : #Term2# } ⟫ ; #Attributes), #Name, #ParsePrefix]
→
%n⟪«AddSynthesizedName[#AttributeName#] »[«
  {#ND}CRS-Term[#Term1#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $False<!--NoSprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]]
», «
  {#ND}CRS-Term[#Term2#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_ALL, $False<!--NoPattern-->, $True<!--SprayInherited-->, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]]
», «
  {#ND}CRS-AddAttributes[OK, #Term, #Attributes, #Name, #ParsePrefix]
»]⟫
;

{#ND}CRS-AddAttributes[OK, #Term, ( %rawAttribute⟪ #AttributeKind# #AttributeName# { ¬ #Term# } ⟫ ; #Attributes), #Name, #ParsePrefix]
→
{#ND}CRS-AddAttributes[OK, #Term, #Attributes, #Name, #ParsePrefix]
;

{$String : SortEntry} CRS-NameOptions[RawTerm, $String, RawPriority, $String] :: Text;
{#ND}CRS-NameOptions[{#L}%rawTerm⟪ #Constructor# ( #Scopes# ) #Attributes# ⟫, #Extra, #Priority, #ParsePrefix]
→
%n⟪<!--#L †«{#L}MakeLocation»-->†«#Constructor#»†«#Extra»« {#ND}CRS-Priority[#Priority, #Scopes#, #ParsePrefix] » : ⟫
;
{#ND}CRS-NameOptions[OMITTED, #Extra, #Priority, #ParsePrefix]
→
%n⟪-« {#ND}CRS-Priority[#Priority, (), #ParsePrefix] » : ⟫
;
{$String : SortEntry} CRS-Priority[RawPriority, $List[RawScope], $String] :: Text;
{#ND}CRS-Priority[%rawPriority⟪ priority ⟫, #Scopes#, #ParsePrefix]
→
%n⟪[Priority« WrappedTextFold[Map[t.{#ND}CRS-Scope[t, BOTTOM, #ParsePrefix, RM_NONE, ok s t as.t], #Scopes#], %n⟨,⟩, %n⟨,⟩, %n⟨⟩] »]⟫
;
{#ND}CRS-Priority[%rawPriority⟪ ⟫, #Scopes#, #ParsePrefix]
→
WrappedTextFold[Map[t.{#ND}CRS-Scope[t, BOTTOM, #ParsePrefix, RM_NONE, ok s t as.t], #Scopes#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩]
;
{#ND}CRS-Priority[%rawPriority⟪ default⟫, #Scopes#, #ParsePrefix]
→
%n⟪[Fallback« WrappedTextFold[Map[t.{#ND}CRS-Scope[t, BOTTOM, #ParsePrefix, RM_NONE, ok s t as.t], #Scopes#], %n⟨,⟩, %n⟨,⟩, %n⟨⟩] »]⟫
;

// Synthesized attribute rule.
//
// Pattern must have the shape  DataTerm (↑ Name AttributeValue )*
//
// This corresponds to a rule like
//
//   CollectSynthSort[ $[Match,{#old}###,DataTerm] →  {#old; (Name:AttributeValue)* } ###

{$String : SortEntry} CRS-SynthesizeRule[RawTerm, RawTerm, RawPriority, $String, $String] :: Text;
{#ND}CRS-SynthesizeRule[#NameOptions#, #Pattern#, #Priority, #Name, #ParsePrefix]
→
{#ND}CRS-SynthesizeRule1[#NameOptions#, #Pattern#, #Priority, #Name, #ParsePrefix, CRS-Term-Attributes[#Pattern#]]
;

{$String : SortEntry} CRS-SynthesizeRule1[RawTerm, RawTerm, RawPriority, $String, $String, $List[RawAttribute]] :: Text;
{#ND}CRS-SynthesizeRule1[#NameOptions#, #Pattern#, #Priority, #Name, #ParsePrefix, ()]
→
%n⟪<!--WARNING: Bogus empty synthesize rule for †«#Name» skipped.-->⟫
;
{#ND}CRS-SynthesizeRule1[#NameOptions#, #Pattern#, #Priority, #Name, #ParsePrefix, (#Attribute;)]
→
{#ND}CRS-SynthesizeRule2[#NameOptions#, #Pattern#, #Priority, #Name, #ParsePrefix, #Attribute]
;
{#ND}CRS-SynthesizeRule1[#NameOptions#, #Pattern#, #Priority, #Name, #ParsePrefix, (#Attribute1; #Attribute2; #Attributes)]
→
%n⟪<!--WARNING: Bogus multiple synthesize rule for †«#Name» skipped.-->⟫
;

{$String : SortEntry} CRS-SynthesizeRule2[RawTerm, RawTerm, RawPriority, $String, $String, RawAttribute] :: Text;

{#ND}CRS-SynthesizeRule2[#NameOptions#, #Pattern#, #Priority, #Name, #ParsePrefix, %rawAttribute⟪ #AttributeKind# #AttributeName# ( #Term# ) ⟫]
→
%n⟪« {#ND}CRS-NameOptions[#NameOptions#, "", #Priority, #ParsePrefix] »
« CollectSynthesizedName[#AttributeName#] »[$[Match, {#Synthesized}« {#ND}CRS-Term-Core[#Pattern#, #Name, #ParsePrefix, RM_NONE, $False, $False, ok s t as.CRS-TermAttributes[ok, t, as, #Name, #ParsePrefix]] », #_]] → «
  SetSynthesizedName[#AttributeName#] »[« {#ND}CRS-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.t] », #_] ; 
⟫
;

{#ND}CRS-SynthesizeRule2[#NameOptions#, #Pattern#, #Priority, #Name, #ParsePrefix, %rawAttribute⟪ #AttributeKind# #AttributeName# { #Term# } ⟫]
→
%n⟪« {#ND}CRS-NameOptions[#NameOptions#, "", #Priority, #ParsePrefix] »
« CollectSynthesizedName[#AttributeName#] »[$[Match, {#Synthesized}« {#ND}CRS-Term-Core[#Pattern#, #Name, #ParsePrefix, RM_NONE, $False, $False, ok s t as.CRS-TermAttributes[ok, t, as, #Name, #ParsePrefix]] », #_]] → «
  AddSynthesizedName[#AttributeName#] »[«
    {#ND}CRS-Term[#Term#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.t]
  », OK, #_] ; 
⟫
;

{#ND}CRS-SynthesizeRule2[#NameOptions#, #Pattern#, #Priority, #Name, #ParsePrefix, %rawAttribute⟪ #AttributeKind# #AttributeName# { #Term1# : #Term2# } ⟫]
→
%n⟪« {#ND}CRS-NameOptions[#NameOptions#, "", #Priority, #ParsePrefix] »
« CollectSynthesizedName[#AttributeName#] »[$[Match, {#Synthesized}« {#ND}CRS-Term-Core[#Pattern#, #Name, #ParsePrefix, RM_NONE, $False, $False, ok s t as.CRS-TermAttributes[ok, t, as, #Name, #ParsePrefix]] », #_]] → «
  AddSynthesizedName[#AttributeName#] »[«
    {#ND}CRS-Term[#Term1#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.t] »,  «
    {#ND}CRS-Term[#Term2#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.t]
  », #_] ; 
⟫
;

// Variant of CRS-Term that strips top attributes.
{$String : SortEntry} CRS-Term-Core[RawTerm, $String, $String, RefMode, $Boolean, $Boolean, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-Term-Core[RAW-Parsed[#Parsed, #Attributes], #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[RAW-Parsed[#Parsed, ()], #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;
{#ND}CRS-Term-Core[RAW-ParsedSorted[#Sort, #Repeat, #Parsed, #Attributes], #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[RAW-ParsedSorted[#Sort, #Repeat, #Parsed, ()], #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;
{#ND}CRS-Term-Core[%rawTerm⟪ #Constructor# ( #Scopes# ) #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[%rawTerm⟪ #Constructor# ( #Scopes# ) %Attributes«()» ⟫, #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;
{#ND}CRS-Term-Core[%rawTerm⟪ #Constructor_Sort# #Repeat# #Constructor# ( #Scopes# ) #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[%rawTerm⟪ #Constructor_Sort# #Repeat# #Constructor# ( #Scopes# ) %Attributes«()» ⟫, #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;
{#ND}CRS-Term-Core[%rawTerm⟪ #MetaVariable# [ #Terms# ] #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[%rawTerm⟪ #MetaVariable# [ #Terms# ] %Attributes«()» ⟫, #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;
{#ND}CRS-Term-Core[%rawTerm⟪ #Constructor_Sort# #Repeat# #MetaVariable# [ #Terms# ] #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[%rawTerm⟪ #Constructor_Sort# #Repeat# #MetaVariable# [ #Terms# ] %Attributes«()» ⟫, #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;
{#ND}CRS-Term-Core[%rawTerm⟪ #Variable# #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[%rawTerm⟪ #Variable# %Attributes«()» ⟫, #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;
{#ND}CRS-Term-Core[%rawTerm⟪ #Constructor_Sort# #Repeat# #Variable# #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[%rawTerm⟪ #Constructor_Sort# #Repeat# #Variable# %Attributes«()» ⟫, #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;
{#ND}CRS-Term-Core[%rawTerm⟪ #Variable# #Term# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[%rawTerm⟪ #Variable# #Term# ⟫, #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;
{#ND}CRS-Term-Core[%rawTerm⟪ #Literal# #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Term[%rawTerm⟪ #Literal# %Attributes«()» ⟫, #Name, #ParsePrefix, #refmode, $False, #sprayinherited, "", ok s t as.#[ok,s,t,as]]
;

// Extract top attributes.
CRS-Term-Attributes[RawTerm] :: $List[RawAttribute] ;
CRS-Term-Attributes[RAW-Parsed[#Parsed, #Attributes]] → #Attributes ;
CRS-Term-Attributes[RAW-ParsedSorted[#Sort, #Repeat, #Parsed, #Attributes]] → #Attributes ;
CRS-Term-Attributes[%rawTerm⟪ #Constructor# ( #Scopes# ) #Attributes# ⟫] → #Attributes# ;
CRS-Term-Attributes[%rawTerm⟪ #Constructor_Sort# #Repeat# #Constructor# ( #Scopes# ) #Attributes# ⟫] → #Attributes# ;
CRS-Term-Attributes[%rawTerm⟪ #MetaVariable# [ #Terms# ] #Attributes# ⟫] → #Attributes# ;
CRS-Term-Attributes[%rawTerm⟪ #Constructor_Sort# #Repeat# #MetaVariable# [ #Terms# ] #Attributes# ⟫] → #Attributes# ;
CRS-Term-Attributes[%rawTerm⟪ #Variable# #Attributes# ⟫] → #Attributes# ;
CRS-Term-Attributes[%rawTerm⟪ #Constructor_Sort# #Repeat# #Variable# #Attributes# ⟫] → #Attributes# ;
CRS-Term-Attributes[%rawTerm⟪ #Literal# #Attributes# ⟫] → #Attributes# ;
CRS-Term-Attributes[%rawTerm⟪ #Variable# #Term# ⟫] → () ;

/// // Extract list of arguments.
/// 
/// {$String : SortEntry} CRS-ArgList-Term[RawTerm, $String, $String, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $List[Text]] :: $List[Text];
/// 
/// {#ND}CRS-ArgList-Term[RAW-Parsed[#Parsed, #Attributes], #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// {#ND}CRS-ArgList-Parsed[#Parsed, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail] //TODO: Attributes?
/// ;
/// {#ND}CRS-ArgList-Term[RAW-ParsedSorted[#Sort, #Repeat, #Parsed, #Attributes], #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// {#ND}CRS-ArgList-Parsed[#Parsed, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail] //TODO: Attributes?
/// ;
/// {#ND}CRS-ArgList-Term[%rawTerm⟪ #Constructor# ( #Scopes# ) #Attributes# ⟫, #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// {#ND}CRS-ArgList-RawConstruction[ConstructorScopeSorts[#TopSort, #Constructor#], #Scopes#, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// ;
/// {#ND}CRS-ArgList-Term[%rawTerm⟪ #Constructor_Sort# #Repeat# #Constructor# ( #Scopes# ) #Attributes# ⟫, #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail] //TODO: Attributes?
/// →
/// {#ND}CRS-ArgList-RawConstruction[ConstructorScopeSorts[#Constructor_Sort#, #Constructor#], #Scopes#, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// ;
/// {#ND}CRS-ArgList-Term[%rawTerm⟪ #MetaVariable# [ #Terms# ] #Attributes# ⟫, #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// ( %n⟪«
///     WrappedTextFold[Map[t.{#ND}CRS-Term[t, "", #ParsePrefix, RM_ALL, $False<!--NoCapturePattern-->, $False<!--NotSprayInherited-->, ok s t as.#[ok,s,t,as]], #Terms#], %n⟨⟩, %n⟨ ⟩, %n⟨.⟩]
///   »«
///     #[OK, #TopSort, {#ND}CRS-Term[%rawTerm⟨ #MetaVariable# [ #Terms# ] ⟩, "", #ParsePrefix, RM_ALL, $False<!--NoCapturePattern-->, $False<!--NotSprayInherited-->, ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]], #Attributes#]
///   »⟫ ; #tail)
/// ;
/// {#ND}CRS-ArgList-Term[%rawTerm⟪ #Constructor_Sort# #Repeat# #MetaVariable# [ #Terms# ] #Attributes# ⟫, #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// ( %n⟪«
///     WrappedTextFold[Map[t.{#ND}CRS-Term[t, "", #ParsePrefix, RM_ALL, $False<!--NoCapturePattern-->, $False<!--NotSprayInherited-->, ok s t as.#[ok,s,t,as]], #Terms#], %n⟨⟩, %n⟨ ⟩, %n⟨.⟩]
///   »«
///     #[OK, SortRepeatString[#Constructor_Sort#, #Repeat#], {#ND}CRS-Term[%rawTerm⟨ #Constructor_Sort# #Repeat# #MetaVariable# [ #Terms# ] ⟩, #Constructor_Sort#, #ParsePrefix, RM_ALL, $False<!--NoCapturePattern-->, $False<!--NotSprayInherited-->, ok s t as.#[ok,s,t,as]], #Attributes#]
///   »⟫ ; #tail)
/// ;
/// {#ND}CRS-ArgList-Term[%rawTerm⟪ #Variable# #Attributes# ⟫, #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// ///(#[OK, "", %n⟪†«#Variable#»⟫, #Attributes#]; #tail) /// Variables now captured at top
/// #tail //TODO: Attributes?
/// ;
/// {#ND}CRS-ArgList-Term[%rawTerm⟪ #Constructor_Sort# #Repeat# #Variable# #Attributes# ⟫, #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// ///(#[OK, SortRepeatString[#Constructor_Sort#, #Repeat#], %n⟪†«#Variable#»⟫, #Attributes#]; #tail) /// Variables now captured at top
/// #tail //TODO: Attributes?
/// ;
/// {#ND}CRS-ArgList-Term[%rawTerm⟪ #Variable# #Term# ⟫, #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// {#ND}CRS-ArgList-Term[#Term#, #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// ;
/// {#ND}CRS-ArgList-Term[%rawTerm⟪ #Literal# #Attributes# ⟫, #TopSort, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// #tail //TODO: Attributes?
/// ;
/// 
/// {$String : SortEntry} CRS-ArgList-Parsed[RawParsed, $String, $Boolean, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $List[Text]] :: $List[Text];
/// {#ND}CRS-ArgList-Parsed[RAW-ParsedWord[#Word, #Parsed], #ParsePrefix, ok s t as.#[ok,s,t,as], #tail] → {#ND}CRS-ArgList-Parsed[#Parsed, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail] ;
/// {#ND}CRS-ArgList-Parsed[RAW-ParsedTerm[#Term, #Parsed], #ParsePrefix, ok s t as.#[ok,s,t,as], #tail] → {#ND}CRS-ArgList-Term[#Term, "", #ParsePrefix, ok s t as.#[ok,s,t,as], {#ND}CRS-ArgList-Parsed[#Parsed, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]] ;
/// {#ND}CRS-ArgList-Parsed[RAW-ParsedDone, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail] → #tail;
/// 
/// {$String : SortEntry} CRS-ArgList-Scope[RawScope, RawScopeSort, $String, $Boolean, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $List[Text]] :: $List[Text];
/// {#ND}CRS-ArgList-Scope[%rawScope⟪ [#VariableList#] #Term# ⟫, %rawScopeSort⟪ #Sort# #Repeat# [ #SubstituteSorts# ] ⟫, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// Append[
///   Map[t.%n⟪« WrappedTextFold[MapWhen[ok v.ThenAsText[ok, v], #VariableList#], %n⟨ ⟩, %n⟨ ⟩, %n⟨.⟩] »« t »⟫, {#ND}CRS-ArgList-Term[#Term#, SortNameWithRepeat[#Sort#, #Repeat#], #ParsePrefix, ok s t as.#[ok,s,t,as], ()]],
///   #tail]
/// ;
/// 
/// {$String : SortEntry} CRS-ArgList-Attributes[$List[RawAttribute], $String, $Boolean, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: $List[Text];
/// {#ND}CRS-ArgList-Attributes[(), #ParsePrefix, ok s t as.#[ok,s,t,as]] → () ;
/// {#ND}CRS-ArgList-Attributes[(%rawAttribute⟪ #AttributeKind# #AttributeName# ( #Term# ) ⟫; #Attributes), #ParsePrefix, ok s t as.#[ok,s,t,as]]
/// →
/// {#ND}CRS-ArgList-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, ok s t as.#[ok,s,t,as], {#ND}CRS-ArgList-Attributes[#Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as]]]
/// ;
/// {#ND}CRS-ArgList-Attributes[(%rawAttribute⟪ #AttributeKind# #AttributeName# { #Term# } ⟫; #Attributes), #ParsePrefix, ok s t as.#[ok,s,t,as]]
/// →
/// {#ND}CRS-ArgList-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, ok s t as.#[ok,s,t,as], {#ND}CRS-ArgList-Attributes[#Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as]]]
/// ;
/// {#ND}CRS-ArgList-Attributes[(%rawAttribute⟪ #AttributeKind# #AttributeName# { #Term1# : #Term2# } ⟫; #Attributes), #ParsePrefix, ok s t as.#[ok,s,t,as]]
/// →
/// {#ND}CRS-ArgList-Term[#Term1#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, ok s t as.#[ok,s,t,as],
///  {#ND}CRS-ArgList-Term[#Term2#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, ok s t as.#[ok,s,t,as],
///   {#ND}CRS-ArgList-Attributes[#Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as]]]]
/// ;
/// {#ND}CRS-ArgList-Attributes[(%rawAttribute⟪ #AttributeKind# #AttributeName# { ¬ #Term# } ⟫; #Attributes), #ParsePrefix, ok s t as.#[ok,s,t,as]]
/// →
/// {#ND}CRS-ArgList-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, ok s t as.#[ok,s,t,as], {#ND}CRS-ArgList-Attributes[#Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as]]]
/// ;
/// 
/// {$String : SortEntry} CRS-ArgList-RawConstruction[Lifted[$List[RawScopeSort]], $List[RawScope], $String, $Boolean, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $List[Text]] :: $List[Text];
/// {#ND}CRS-ArgList-RawConstruction[LIFTED[#ScopeSorts], #Scopes, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// Fold2[s ss ts.{#ND}CRS-ArgList-Scope[s, ss, #ParsePrefix, ok s t as.#[ok,s,t,as], ts], #Scopes, #ScopeSorts, #tail]
/// ;
/// {#ND}CRS-ArgList-RawConstruction[BOTTOM, #Scopes, #ParsePrefix, ok s t as.#[ok,s,t,as], #tail]
/// →
/// Fold[s ts.{#ND}CRS-ArgList-Scope[s, %rawScopeSort⟪ Ok ⟫, #ParsePrefix, ok s t as.#[ok,s,t,as], ts], #Scopes, #tail]
/// ;

/////////////////////////////////////////////////////////////////////
// DERIVED RULES.

// Derived meta-rules.

CRS-MetaDeclarations-Derived[DERIVED_SORT, $String] :: TextMapSort;
CRS-MetaDeclarations-Derived[DERIVED[#Name, #Prec, #Repeat], #ParsePrefix]
→
SingletonTextMap[SortNameWithRepeat1[#Name, #Repeat],
  CRS-MetaDeclarations-Derived2[#Name, #Prec, #Repeat, #ParsePrefix, ProductionNameWithPrecRepeat[#Name, #Prec, #Repeat]]]
;

CRS-MetaDeclarations-Derived2[$String, $Numeric, RawRepeat, $String, Text] :: Text;
CRS-MetaDeclarations-Derived2[#SortName, #Prec, #Repeat, #ParsePrefix, #ProductionName]
→
%n⟪$PrecWrap-«#ProductionName»[#Prec, #InnerPrec, #] → # ;
⟫;

// Derived Declarations.

{$String : SortEntry} CRS-Declarations-Derived[DERIVED_SORT, $String] :: TextMapSort;
{#ND} CRS-Declarations-Derived[DERIVED[#Name, #Prec, #Repeat], #ParsePrefix]
→
SingletonTextMap[SortNameWithRepeat1[#Name, #Repeat],
  {#ND}CRS-Declarations-Derived2[#Name, #Prec, #Repeat, #ParsePrefix, ProductionNameWithPrecRepeat[#Name, #Prec, #Repeat], NameSetList[{#ND}SortSynthesizes[#Name]]]]
;

{$String : SortEntry} CRS-Declarations-Derived2[$String, $Numeric, RawRepeat, $String, Text, $List[$String]] :: Text;
{#ND}CRS-Declarations-Derived2[#SortName, #Prec, #Repeat, #ParsePrefix, #ProductionName, #SynthesizesList] → %n⟪
<!-- Declarations for derived «#ProductionName». -->
$Drop-«#ProductionName»[«#ProductionName»] :: Text ;
$Print-«#ProductionName»[«#ProductionName»] :: Text ;
$PrintP-«#ProductionName»[«#ProductionName», $Numeric] :: Text ;
« TextFold[MapWhen[ok a.{#ND} CRS-Declarations-DefineSynth[ok, a, #ProductionName], #SynthesizesList], %n⟨⟩] »
⟫;

// Derived rules...

{$String : SortEntry} CRS-Rules-Derived[DERIVED_SORT, $String] :: TextMapSort;
{#ND} CRS-Rules-Derived[DERIVED[#Name, #Prec, #Repeat], #ParsePrefix]
→
SingletonTextMap[SortNameWithRepeat1[#Name, #Repeat],
  {#ND} CRS-Rules-Derived2[#Name, #Prec, #Repeat, #ParsePrefix, %n⟪†«SortRepeatString[#Name, #Repeat]»⟫, ProductionNameWithPrecRepeat[#Name, #Prec, #Repeat], ProductionNameWithPrec[#Name, #Prec], NameSetList[{#ND}SortSynthesizes[#Name]]]]
;

{$String : SortEntry} CRS-Rules-Derived2[$String, $Numeric, RawRepeat, $String, Text, Text, Text, $List[$String]] :: Text;
{#ND} CRS-Rules-Derived2[#SortName, #Prec, #Repeat, #ParsePrefix, #NameText, #ProductionName, #InnerProductionName, #SynthesizesList]
→
%n⟪
<!-- Rules for derived «#ProductionName». -->
$Drop-«#ProductionName»[#] → $TextCons[$TextChars["OK"], $TextNil] ;
-[Data[#]]: $Print-«#ProductionName»[#] → $PrintP-«#ProductionName»[#, 0] ;
$PrintP-«#ProductionName»[v, #Prec] → $TextCons[$TextEmbed[v], $TextNil] ;
« CRS-then-RepeatRules[OK, #SortName, #Prec, #Repeat, #ParsePrefix, "n", %n⟨⟩, #NameText, #ProductionName, #InnerProductionName, p q.%n⟨$PrintP-‹p›[‹q›, #Prec]⟩, q.q, u p q.%n⟨ $PrintP-‹p›[‹q›, #Prec]⟩, p q qs.q] »
« TextFold[MapWhen[ok a.{#ND} CRS-then-RepeatRulesSynth[ok, a, #SortName, #Prec, #Repeat, #ParsePrefix, #ProductionName, #NameText, #ProductionName, #InnerProductionName], #SynthesizesList], %n⟨⟩] »
⟫;

{$String : SortEntry} CRS-then-RepeatRulesSynth[Ok, $String, $String, $Numeric, RawRepeat, $String, Text, Text, Text, Text] :: Text;
{#ND}CRS-then-RepeatRulesSynth[OK, #a, #SortName, #Prec, #Repeat, #ParsePrefix, #ProductionName, #NameText, #ProductionName, #InnerProductionName]
→
%n⟪«
  {#ND}CRS-Rules-DefineSynth[OK, #a, #ProductionName]
»«
  CRS-then-RepeatRules[OK, #SortName, #Prec, #Repeat, #ParsePrefix, #ParsePrefix, #ProductionName, #NameText, #ProductionName, #InnerProductionName,
    p q.%n⟨‹NeedsSynthesizedName[#a]›[‹q›]⟩, q.q, u p q.%n⟨‹u› ‹NeedsSynthesizedName[#a]›[‹q›]⟩, p q qs.%n⟨‹CollectSynthesizedName[#a]›[‹q›]⟩]
»«
  CRS-then-RepeatRules[OK, #SortName, #Prec, #Repeat, #ParsePrefix, #ParsePrefix, #ProductionName, #NameText, #ProductionName, #InnerProductionName,
    p q.%n⟨{#Inherited}‹CollectSynthesizedName[#a]›[‹q›]⟩, q.%n⟨ {†‹#a›:‹q›†‹#a›}‹q›⟩, u p q.%n⟨‹u›‹q›⟩, p q qs.%n⟨{#Inherited}‹ CRS-then-Rules-DataSynth-Fold[OK, #ProductionName, #a, qs, q] ›⟩]
»⟫;

// The helper for repeat rules takes four templates: TopPattern, InPattern, InContraction, TopContraction.

_Hash :: Text;
_Hash → %n⟨#⟩;
_Hashs :: Text;
_Hashs → %n⟨#s⟩;

CRS-then-RepeatRules[Ok, $String, $Numeric, RawRepeat, $String, $String, Text, Text, Text, Text, p::Text q::Text.Text<!--TopPattern-->, q::Text.Text<!--InPattern-->, u::Text p::Text q::Text.Text<!--InContraction-->, p::Text q::Text qs::$List[Text].Text<!--TopContraction-->] :: Text;

CRS-then-RepeatRules[OK, #SortName, #Prec, %rawRepeat⟪ ? ⟫, #ParsePrefix, #OutParsePrefix, #TopText, #NameText, #ProductionName, #InnerProductionName, p q.#tp[p,q], q.#ip[q], u p q.#ic[u,p,q], p q qs.#tc[p,q,qs]]
→
%n⟪
« #tp[#ProductionName, CRS-User[#ParsePrefix, #ProductionName, %n⟨⟩]] » → « #tc[#ProductionName, CRS-Text[%n⟨ ⟩], ()] » ;
« #tp[#ProductionName, CRS-User[#ParsePrefix, #ProductionName, CRS-Embed[#SortName, #ip[_Hash]]]] » → « #tc[#ProductionName, #ic[#InnerProductionName, #InnerProductionName, _Hash], (_Hash;)] » ;
⟫;

CRS-then-RepeatRules[OK, #SortName, #Prec, %rawRepeat⟪ * ⟫, #ParsePrefix, #OutParsePrefix, #TopText, #NameText, #ProductionName, #InnerProductionName, p q.#tp[p,q], q.#ip[q], u p q.#ic[u,p,q], p q qs.#tc[p,q,qs]]
→
%n⟪
« #tp[#ProductionName, CRS-User[#ParsePrefix, #ProductionName, %n⟨⟩]] » → « #tc[#ProductionName, CRS-Text[%n⟨ ⟩], ()] » ;
« #tp[#ProductionName, CRS-User[#ParsePrefix, #ProductionName, %n⟨‹CRS-Embed[#SortName, #ip[_Hash]]›‹CRS-Embed[$[:,#SortName,"*"], #ip[_Hashs]]›⟩]] »
 → ⟦« #tc[#ProductionName, CRS-User[#OutParsePrefix, #TopText, %n⟨†‹"\u27e8"›‹#ic[#InnerProductionName, #InnerProductionName, _Hash]›†‹"\u27e9"› †‹"\u27e8"›‹#ic[#NameText, #ProductionName, _Hashs]›†‹"\u27e9"›⟩], (_Hash; _Hashs;)] »⟧ ;
⟫;

CRS-then-RepeatRules[OK, #SortName, #Prec, %rawRepeat⟪ + ⟫, #ParsePrefix, #OutParsePrefix, #TopText, #NameText, #ProductionName, #InnerProductionName, p q.#tp[p,q], q.#ip[q], u p q.#ic[u,p,q], p q qs.#tc[p,q,qs]]
→
%n⟪
« #tp[#ProductionName, CRS-User[#ParsePrefix, #ProductionName, CRS-Embed[#SortName, #ip[_Hash]]]] » → « #tc[#ProductionName, #ic[#InnerProductionName, #InnerProductionName, _Hash], (_Hash;)] » ;
« #tp[#ProductionName, CRS-User[#ParsePrefix, #ProductionName, %n⟨‹CRS-Embed[#SortName, #ip[_Hash]]›‹CRS-Embed[$[:,#SortName,"+"], #ip[_Hashs]]›⟩]] »
 → ⟦« #tc[#ProductionName, CRS-User[#OutParsePrefix, #TopText, %n⟨†‹"\u27e8"›‹#ic[#InnerProductionName, #InnerProductionName, _Hash]›†‹"\u27e9"› †‹"\u27e8"›‹#ic[#NameText, #ProductionName, _Hashs]›†‹"\u27e9"›⟩], (_Hash; _Hashs;)] »⟧ ;
⟫;

CRS-then-RepeatRules[OK, #SortName, #Prec, %rawRepeat⟪ + _ #RegExpLeaf# ⟫, #ParsePrefix, #OutParsePrefix, #TopText, #NameText, #ProductionName, #InnerProductionName, p q.#tp[p,q], q.#ip[q], u p q.#ic[u,p,q], p q qs.#tc[p,q,qs]]
→
%n⟪
« #tp[#ProductionName, CRS-User[#ParsePrefix, #ProductionName, CRS-Embed[#SortName, #ip[_Hash]]]] » → « #tc[#ProductionName, #ic[#InnerProductionName, #InnerProductionName, _Hash], (_Hash;)] » ;
« #tp[#ProductionName, CRS-User[#ParsePrefix, #ProductionName, %n⟨‹CRS-Embed[#SortName, #ip[_Hash]]› †‹RegExpLeafWord[#RegExpLeaf#]›‹CRS-Embed[RegExpLeafSuffix[#RegExpLeaf#, $[:,#SortName,"+_"]], #ip[_Hashs]]›⟩]] »
 → ⟦« #tc[#ProductionName, CRS-User[#OutParsePrefix, #TopText, %n⟨†‹"\u27e8"›‹#ic[#InnerProductionName, #InnerProductionName, _Hash]›†‹"\u27e9"› †‹ RegExpLeafWord[#RegExpLeaf#] › †‹"\u27e8"›‹#ic[#NameText, #ProductionName, _Hashs]›†‹"\u27e9"›⟩], (_Hash; _Hashs;)] »⟧ ;
⟫;

/////////////////////////////////////////////////////////////////////
// ATTRIBUTE MANIPULATION

{$String : SortEntry} CRS-Declarations-Inherited[Ok, $String<!--AttributeName-->, $String<!--ParsePrefix-->, NameSet<!--MapNames-->] :: Text;
-[Data[#AttributeName,#MapNames]]:
{#ND} CRS-Declarations-Inherited[OK, #AttributeName, #ParsePrefix, #MapNames]
→
If[ContainsName[#MapNames, #AttributeName],
  %n⟨∀ a . ‹AddInheritedName[#AttributeName]›[†‹{#ND}AttributeKeySortName[#AttributeName]›, †‹{#ND}AttributeValueSortName[#AttributeName]›, a] :: a ;
∀ a . ‹AddInheritedName[#AttributeName]›-Set[$StringEntrySort, †‹{#ND}AttributeKeySortName[#AttributeName]›, †‹{#ND}AttributeValueSortName[#AttributeName]›, a] :: a ;
⟩,
  %n⟪∀ a . «SetInheritedName[#AttributeName]»[†« {#ND}AttributeValueSortName[#AttributeName] », a] :: a;
⟫]
;

{$String : SortEntry} CRS-Rules-Inherited[Ok, $String<!--AttributeName-->, $String<!--ParsePrefix-->, NameSet<!--MapNames-->] :: Text;
-[Data[#AttributeName]]:
{#ND} CRS-Rules-Inherited[OK, #AttributeName, #ParsePrefix, #MapNames]
→
If[ContainsName[#MapNames, #AttributeName],
  %n⟨-[Data[#Key]]: ‹AddInheritedName[#AttributeName]›[#Key, #Value, {#Inherited}#] → ‹AddInheritedName[#AttributeName]›-Set[$[{#Inherited}Get[†‹{#ND}AttributeKeySortName[#AttributeName]›], "†‹#AttributeName›", ‹InheritedName[#AttributeName]›], #Key, #Value, #] ;
‹AddInheritedName[#AttributeName]›-Set[{#OldMap}‹InheritedName[#AttributeName]›, #Key, #Value, {#Inherited}#] → {#Inherited; "†‹#AttributeName›" : {#OldMap; #Key : #Value}‹InheritedName[#AttributeName]›}# ;
⟩,
  %n⟪-[Data[#Value]]: «SetInheritedName[#AttributeName]»[#Value, {#Inherited}#] → {#Inherited; "†«#AttributeName»" : «InheritedName[#AttributeName]»[#Value]}# ;
⟫]
;

{$String : SortEntry} CRS-Declarations-Synthesized[Ok, $String<!--AttributeName-->, $String<!--ParsePrefix-->, NameSet<!--MapNames-->] :: Text;
-[Data[#AttributeName]]:
{#ND} CRS-Declarations-Synthesized[OK, #AttributeName, #ParsePrefix, #MapNames]
→
If[ContainsName[#MapNames, #AttributeName],
  %n⟨∀ a . ‹AddSynthesizedName[#AttributeName]›[†‹{#ND}AttributeKeySortName[#AttributeName]›, †‹{#ND}AttributeValueSortName[#AttributeName]›, a] :: a ;
∀ a . ‹AddSynthesizedName[#AttributeName]›-Set[†‹{#ND}AttributeKeySortName[#AttributeName]›, †‹{#ND}AttributeValueSortName[#AttributeName]›, a] :: a ;
⟩,
  %n⟪∀ a . «SetSynthesizedName[#AttributeName]»[†« {#ND}AttributeValueSortName[#AttributeName] », a] :: a;
⟫]
;

{$String : SortEntry} CRS-Rules-Synthesized[Ok, $String<!--AttributeName-->, $String<!--ParsePrefix-->, NameSet<!--MapNames-->] :: Text;
-[Data[#AttributeName]]:
{#ND} CRS-Rules-Synthesized[OK, #AttributeName, #ParsePrefix, #MapNames]
→
If[ContainsName[#MapNames, #AttributeName],
  %n⟨-[Data[#Key]]: ‹AddSynthesizedName[#AttributeName]›[#Key, #Value, {#Synthesized}#] → ‹AddSynthesizedName[#AttributeName]›-Set[$[{#Synthesized}Get[†‹{#ND}AttributeKeySortName[#AttributeName]›], "†‹#AttributeName›", ‹SynthesizedName[#AttributeName]›], #Key, #Value, #] ;
‹AddSynthesizedName[#AttributeName]›-Set[{#OldMap}‹SynthesizedName[#AttributeName]›, #Key, #Value, {#Synthesized}#] → {#Synthesized; "†‹#AttributeName›" : {#OldMap; #Key : #Value}‹SynthesizedName[#AttributeName]›}# ;
⟩,
  %n⟪-[Data[#Value]]: «SetSynthesizedName[#AttributeName]»[#Value, {#Synthesized}#] → {#Synthesized; "†«#AttributeName»" : «SynthesizedName[#AttributeName]»[#Value]}# ;
⟫]
;


/////////////////////////////////////////////////////////////////////
// TERMS

RefMode ::=( RM_NONE; RM_ONLY_TOP; RM_ALL; );

∀ a . IfRefModeHides[RefMode, a, a] :: a ;
IfRefModeHides[RM_NONE, #1, #2] → #1 ;
IfRefModeHides[RM_ONLY_TOP, #1, #2] → #2 ;
IfRefModeHides[RM_ALL, #1, #2] → #2 ;

SubRefMode[RefMode] :: RefMode;
SubRefMode[RM_NONE] → RM_NONE ;
SubRefMode[RM_ONLY_TOP] → RM_NONE ;
SubRefMode[RM_ALL] → RM_ALL ;

AddTopRefMode[RefMode] :: RefMode;
AddTopRefMode[RM_NONE] → RM_ONLY_TOP ;
AddTopRefMode[RM_ONLY_TOP] → RM_ONLY_TOP ;
AddTopRefMode[RM_ALL] → RM_ALL ;

{$String : SortEntry} CRS-Term[RawTerm, $String<!--TopSort-->, $String<!--ParsePrefix-->, RefMode, $Boolean<!--Pattern?-->, $Boolean<!--SprayInherited?-->, $String<!--Variant-->, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;

-[Data[#Name]]:
{#ND}CRS-Term[RAW-Parsed[#Parsed, #Attributes], #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Parsed[#Parsed, #Attributes, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
;

-[Data[#Name]]:
{#ND}CRS-Term[RAW-ParsedSorted[#SortName, #Repeat, #Parsed, #Attributes], #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-Parsed[#Parsed, #Attributes, SortRepeatString[#SortName, #Repeat], #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
;

{#ND}CRS-Term[%rawTerm⟪ #Constructor# ( #Scopes# ) #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-TermConstruction[$[:,#Constructor#,#variant], #Constructor#, #Scopes#, #Attributes#, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
;

{#ND}CRS-Term[%rawTerm⟪ #Constructor_Sort# #Repeat# #Constructor# ( #Scopes# ) #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-TermConstruction[$[:,#Constructor#,#variant], #Constructor#, #Scopes#, #Attributes#, SortRepeatString[#Constructor_Sort#, #Repeat#], #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
;

{#ND}CRS-Term[%rawTerm⟪ #MetaVariable# [ #Terms# ] #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
#[OK, #Name, %n⟪†«#MetaVariable#»« WrappedTextFold[Map[t.{#ND}CRS-Term[t, "", #ParsePrefix, SubRefMode[#refmode], $False<!--NoPattern-->, #sprayinherited, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]], #Terms#], %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] »⟫, #Attributes#]
;
// TODO: record meta-variable positional types...
{#ND}CRS-Term[%rawTerm⟪ #Constructor_Sort# #Repeat# #MetaVariable# [ #Terms# ] #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
#[OK, #Constructor_Sort#, %n⟪†«#MetaVariable#»« WrappedTextFold[Map[t.{#ND}CRS-Term[t, "", #ParsePrefix, SubRefMode[#refmode], $False<!--NoPattern-->, #sprayinherited, "", ok s t as.CRS-TermAttributes[ok, t, as, s, #ParsePrefix]], #Terms#], %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] »⟫, #Attributes#]
;

{#ND}CRS-Term[%rawTerm⟪ #Variable# #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
%n⟪«
  IfRefModeHides[#refmode, %n⟨ ⟩, IfEmpty[#Attributes#, %n⟨ ⟩, {#ND}CRS-Attributes1[#Attributes#, #ParsePrefix, #Pattern, ok s t as.#[ok,s,t,as]]]]
»†«#Variable#»⟫ ;
;
// TODO: Look up variable sort to be assigned by CRS-Scope below!

{#ND}CRS-Term[%rawTerm⟪ #Constructor_Sort# #Repeat# #Variable# #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
%n⟪«
  IfRefModeHides[#refmode, %n⟨ ⟩, IfEmpty[#Attributes#, %n⟨ ⟩, {#ND}CRS-Attributes1[#Attributes#, #ParsePrefix, #Pattern, ok s t as.#[ok,s,t,as]]]]
»†«#Variable#»⟫ ;
;

{#ND}CRS-Term[%rawTerm⟪ #Literal# #Attributes# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
%n⟪«
  IfRefModeHides[#refmode, %n⟨ ⟩, IfEmpty[#Attributes#, %n⟨ ⟩, {#ND}CRS-Attributes1[#Attributes#, #ParsePrefix, #Pattern, ok s t as.#[ok,s,t,as]]]]
»†«#Literal#»⟫ ;
;

{#ND}CRS-Term[%rawTerm⟪ #Variable# #Term# ⟫, #Name, #ParsePrefix, #refmode, #Pattern, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]
→
%n⟪Special_†«#Variable#»[« {#ND}CRS-Term[#Term#, "", "n", #refmode, $False, #sprayinherited, #variant, ok s t as.#[ok,s,t,as]]  »]⟫ ;
;
// TODO: Look up variable sort to be assigned by CRS-Scope below!

// Parsed text: extract attribute updates.

{$String : SortEntry} CRS-Parsed[RawParsed, $List[RawAttribute], $String<!--SortName-->, $String<!--ParsePrefix-->, RefMode, $Boolean<!--Pattern?-->, $Boolean<!--SprayInherited?-->, $String<!--Variant-->, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;

{#ND}CRS-Parsed[#Parsed, #Attributes, #Name, #ParsePrefix, #refmode, #Pattern, $False<!--NoSprayInherited-->, #variant, ok s t as.#[ok,s,t,as]]
→
IfRefModeHides[#refmode,
  {#ND}CRS-Parsed1[#Attributes, #ParsePrefix, #Name, #Parsed, #refmode, #variant, ok s t as.#[ok,s,t,as]],
  Make_Alternate[#variant, {#ND}CRS-Attributes[#Attributes, #Name, #ParsePrefix, ok s t as.#[ok,s,t,as], #Pattern, {#ND}CRS-Parsed2[#Name, #Parsed, #ParsePrefix, SubRefMode[#refmode], ok s t as.#[ok,s,t,as]]]]
];

{#ND}CRS-Parsed[#Parsed, #Attributes, #Name, #ParsePrefix, #refmode, #Pattern, $True<!--SprayInherited-->, #variant, ok s t as.#[ok,s,t,as]]
→
IfRefModeHides[#refmode,
  {#ND}CRS-Parsed1[#Attributes, #ParsePrefix, #Name, #Parsed, #refmode, #variant, ok s t as.#[ok,s,t,as]],
  %n⟪{#Inherited}_SprayInherited[« {#ND}CRS-Parsed1[#Attributes, #ParsePrefix, #Name, #Parsed, RM_NONE, #variant, ok s t as.#[ok,s,t,as]] »]⟫
];

{$String : SortEntry} CRS-Parsed1[$List[RawAttribute], $String, $String, RawParsed, RefMode, $String, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-Parsed1[#Attributes, #ParsePrefix, #Name, #Parsed, #refmode, #variant, ok s t as.#[ok,s,t,as]]
→
Make_Alternate[#variant, %n⟪« {#ND}CRS-Attributes1[#Attributes, #ParsePrefix, $False, ok s t as.#[ok,s,t,as]] »« {#ND}CRS-Parsed2[#Name, #Parsed, #ParsePrefix, #refmode, ok s t as.#[ok,s,t,as]] »⟫] //()?
;

{$String : SortEntry} CRS-Parsed2[$String, RawParsed, $String, RefMode, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-Parsed2[#Name, #Parsed, #ParsePrefix, #refmode, ok s t as.#[ok,s,t,as]]
→
CRS-User[#ParsePrefix, %n⟨†« #Name »⟩,{#ND}CRS-Parsed-In[#Parsed, #ParsePrefix, SubRefMode[#refmode], ok s t as.#[ok,s,t,as]]]
;

// Attribute environment.

// Variant with primary #Inherit reference for the 'init pattern' and optional initialize/capture for all maps.
{$String : SortEntry} CRS-Attributes[$List[RawAttribute], $String<!--SortName-->, $String<!--ParsePrefix-->, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $Boolean, Text] :: Text;

{#ND}CRS-Attributes[#Attributes, #SortName, #ParsePrefix, ok s t as.#[ok,s,t,as], $True<!--Pattern-->, #text]
→
%n⟪({#Inherited« {#ND}CRS-Attributes2[#Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as], "; "] »« {#ND}N-CaptureOtherMaps[#Attributes] »}«#text»)⟫
;

{#ND}CRS-Attributes[#Attributes, #SortName, #ParsePrefix, ok s t as.#[ok,s,t,as], $False<!--NoPattern-->, #text]
→
{#ND}CRS-AddAttributes[OK, #text, #Attributes, #SortName, #ParsePrefix]
;

/// {#ND}CRS-Attributes[#Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as], #CapturePattern, #text]
/// →
/// %n⟪({#Inherited«
///   $[If, #CapturePattern, {#ND}CRS-Attributes2[#Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as], "; "], {#ND}CRS-AddAttributes[OK, #Term, #Attributes, #Name, #ParsePrefix]]
/// »«
///   $[If, #CapturePattern, {#ND}N-CaptureOtherMaps[#Attributes], %n⟨⟩]
/// »}«#text»)⟫ //wrapped in () to avoid JavaCC StringReader bug
/// ;

// Variant without primary #Inherit reference.
{$String : SortEntry} CRS-Attributes1[$List[RawAttribute], $String, $Boolean<!--IsPattern?-->, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-Attributes1[(),       #ParsePrefix, #Pattern, ok s t as.#[ok,s,t,as]] → $[If, #Pattern, %n⟪{#Inherited}⟫, %n⟪⟫] ;
{#ND}CRS-Attributes1[(#a;#as), #ParsePrefix, #Pattern, ok s t as.#[ok,s,t,as]] → %n⟪{« $[If, #Pattern, %n⟪#Inherited; ⟫, %n⟪⟫] »« {#ND}CRS-Attributes2[(#a;#as), #ParsePrefix, ok s t as.#[ok,s,t,as], ""] »}⟫ ;

// The specific attribute bindings.
{$String : SortEntry} CRS-Attributes2[$List[RawAttribute], $String, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $String] :: Text;
{#ND}CRS-Attributes2[#Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as], #sep] → {#ND}CRS-Attributes3[{}CRS-AttributeGroups[#Attributes, $True], #ParsePrefix, ok s t as.#[ok,s,t,as], #sep] ;

{$String : $List[RawAttribute]}ATTRIBUTE_MAP ::=( AM; );

{$String : $List[RawAttribute]} CRS-AttributeGroups[$List[RawAttribute], $Boolean<!--includesynthesized-->] :: ATTRIBUTE_MAP;
{#Map}CRS-AttributeGroups[(), #includesynthesized] → {#Map}AM ; 
{#Map}CRS-AttributeGroups[(%rawAttribute⟪ ↓ #AttributeName# #AttributeValue# ⟫ ; #Attributes), #includesynthesized]
→
{#Map}CRS-AttributeGroups2[$[{#Map}Get[$List[RawAttribute]], #AttributeName#, ()], #AttributeName#, %rawAttribute⟪ ↓ #AttributeName# #AttributeValue# ⟫, #Attributes, #includesynthesized]
;
{#Map}CRS-AttributeGroups[(%rawAttribute⟪ ↑ #AttributeName# #AttributeValue# ⟫ ; #Attributes), $True]
→
{#Map}CRS-AttributeGroups2[$[{#Map}Get[$List[RawAttribute]], #AttributeName#, ()], #AttributeName#, %rawAttribute⟪ ↑ #AttributeName# #AttributeValue# ⟫, #Attributes, $True]
;
{#Map}CRS-AttributeGroups[(%rawAttribute⟪ ↑ #AttributeName# #AttributeValue# ⟫ ; #Attributes), $False]
→
{#Map}CRS-AttributeGroups[#Attributes, $False]
;

{$String : $List[RawAttribute]} CRS-AttributeGroups2[$List[RawAttribute], $String<!--AttributeName-->, RawAttribute, $List[RawAttribute], $Boolean<!--includesynthesized-->] :: ATTRIBUTE_MAP;
{#Map}CRS-AttributeGroups2[#Old, #Name, #New, #Rest, #includesynthesized] → {#Map; #Name : (#New; #Old)}CRS-AttributeGroups[#Rest, #includesynthesized] ;

{$String : SortEntry} CRS-Attributes3[ATTRIBUTE_MAP, $String, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $String] :: Text;
{#ND}CRS-Attributes3[{#Map}AM, #ParsePrefix, ok s t as.#[ok,s,t,as], #sep]
→
{#ND}CRS-Attributes4[$[{#Map}Keys[$String]], {#Map}AM, #ParsePrefix, ok s t as.#[ok,s,t,as], #sep]
;

{$String : SortEntry} CRS-Attributes4[$List[$String], ATTRIBUTE_MAP, $String, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $String] :: Text;
{#ND}CRS-Attributes4[(), #AM, #ParsePrefix, ok s t as.#[ok,s,t,as], #sep] → %n⟪⟫ ;
{#ND}CRS-Attributes4[(#a; #as), {#Map}AM, #ParsePrefix, ok s t as.#[ok,s,t,as], #sep]
→
%n⟪†«#sep»« {#ND}CRS-AttributeKeyValues[#a, $[{#Map}Get[$List[RawAttribute]], #a], #ParsePrefix, ok s t as.#[ok,s,t,as]] »« {#ND}CRS-Attributes4[#as, {#Map}AM, #ParsePrefix, ok s t as.#[ok,s,t,as], "; "] »⟫
;

// One attribute group...

{$String : SortEntry} CRS-AttributeKeyValues[$String<!--AttributeName-->, $List[RawAttribute], $String<!--Prefix-->, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-AttributeKeyValues[#AttributeName#, #Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as]]
→
%n⟪"†«#AttributeName#»" : « {#ND}CRS-AttributeValues[#Attributes, #ParsePrefix, ok s t as.#[ok,s,t,as], $True, %n⟪⟫] »⟫
;

{$String : SortEntry} CRS-AttributeValues[$List[RawAttribute], $String, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $Boolean<!--first-->, Text<!--terminator-->] :: Text;

// Simple attributes can only have one value so do NOT recurse.
{#ND}CRS-AttributeValues[(%rawAttribute⟪↓ #AttributeName# ( #Term# ) ⟫; #Rest), #ParsePrefix, ok s t as.#[ok,s,t,as], #first, #terminator]
→
%n⟪«InheritedName[#AttributeName#]»[« {#ND}CRS-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] »]⟫
;
{#ND}CRS-AttributeValues[(%rawAttribute⟪↑ #AttributeName# ( #Term# ) ⟫; #Rest), #ParsePrefix, ok s t as.#[ok,s,t,as], #first, #terminator]
→
%n⟪«SynthesizedName[#AttributeName#]»[« {#ND}CRS-Term[#Term#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] »]⟫
;

// Set attributes accumulate
-[Data[#first]]:
{#ND}CRS-AttributeValues[(%rawAttribute⟪↓ #AttributeName# { #Term# } ⟫; #Rest), #ParsePrefix, ok s t as.#[ok,s,t,as], #first, #terminator]
→
%n⟪« $[If, #first, %n⟨{#InheritedMap_†‹#AttributeName#›⟩, %n⟨⟩] »; « {#ND}CRS-Term[#Term#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] » : OK« {#ND}CRS-AttributeValues[#Rest, #ParsePrefix, ok s t as.#[ok,s,t,as], $False, %n⟨}‹InheritedName[#AttributeName#]›⟩] »⟫
///%n⟪« SetInheritedName[#AttributeName#] »[« {#ND}CRS-Term[#Term#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] », OK, « {#ND}CRS-AttributeValues[#Rest, #ParsePrefix, ok s t as.#[ok,s,t,as], $False, %n⟨}‹InheritedName[#AttributeName#]›⟩] »]⟫
;
{#ND}CRS-AttributeValues[(%rawAttribute⟪↑ #AttributeName# { #Term# } ⟫; #Rest), #ParsePrefix, ok s t as.#[ok,s,t,as], #first, #terminator]
→
%n⟪« $[If, #first, %n⟨{#SynthesizedMap_†‹#AttributeName#›⟩, %n⟨⟩] »; « {#ND}CRS-Term[#Term#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] » : OK« {#ND}CRS-AttributeValues[#Rest, #ParsePrefix, ok s t as.#[ok,s,t,as], $False, %n⟨}‹SynthesizedName[#AttributeName#]›⟩] »⟫
///%n⟪« SetSythesizedName »[« {#ND}CRS-Term[#Term#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] », OK, « {#ND}CRS-AttributeValues[#Rest, #ParsePrefix, ok s t as.#[ok,s,t,as], $False, %n⟨}‹SynthesizedName[#AttributeName#]›⟩] »⟫
;

// Map attributes accumulate, too, of course.
{#ND}CRS-AttributeValues[(%rawAttribute⟪↓ #AttributeName# { #Term1# : #Term2# } ⟫; #Rest), #ParsePrefix, ok s t as.#[ok,s,t,as], #first, #terminator]
→
%n⟪« $[If, #first, %n⟨{#InheritedMap_†‹#AttributeName#›⟩, %n⟨⟩] »; « {#ND}CRS-Term[#Term1#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] » : « {#ND}CRS-Term[#Term2#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] »« {#ND}CRS-AttributeValues[#Rest, #ParsePrefix, ok s t as.#[ok,s,t,as], $False, %n⟨}‹InheritedName[#AttributeName#]›⟩] »⟫
;
{#ND}CRS-AttributeValues[(%rawAttribute⟪↑ #AttributeName# { #Term1# : #Term2# } ⟫; #Rest), #ParsePrefix, ok s t as.#[ok,s,t,as], #first, #terminator]
→
%n⟪« $[If, #first, %n⟨{#SynthesizedMap_†‹#AttributeName#›⟩, %n⟨⟩] »; « {#ND}CRS-Term[#Term1#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] » : « {#ND}CRS-Term[#Term2#, {#ND}AttributeValueSortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] »« {#ND}CRS-AttributeValues[#Rest, #ParsePrefix, ok s t as.#[ok,s,t,as], $False, %n⟨}‹SynthesizedName[#AttributeName#]›⟩] »⟫
;

// Negated keys intermix...
{#ND}CRS-AttributeValues[(%rawAttribute⟪↓ #AttributeName# { ¬ #Term# } ⟫; #Rest), #ParsePrefix, ok s t as.#[ok,s,t,as], #first, #terminator]
→
%n⟪« $[If, #first, %n⟨{#InheritedMap_†‹#AttributeName#›⟩, %n⟨⟩] »; &not; « {#ND}CRS-Term[#Term#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] »« {#ND}CRS-AttributeValues[#Rest, #ParsePrefix, ok s t as.#[ok,s,t,as], $False, %n⟨}‹InheritedName[#AttributeName#]›⟩] »⟫
;
{#ND}CRS-AttributeValues[(%rawAttribute⟪↑ #AttributeName# { ¬ #Term# } ⟫; #Rest), #ParsePrefix, ok s t as.#[ok,s,t,as], #first, #terminator]
→
%n⟪« $[If, #first, %n⟨{#SynthesizedMap_†‹#AttributeName#›⟩, %n⟨⟩] »; &not; « {#ND}CRS-Term[#Term#, {#ND}AttributeKeySortName[#AttributeName#], #ParsePrefix, RM_NONE, $False, $False, "", ok s t as.#[ok,s,t,as]] »« {#ND}CRS-AttributeValues[#Rest, #ParsePrefix, ok s t as.#[ok,s,t,as], $False, %n⟨}‹SynthesizedName[#AttributeName#]›⟩] »⟫
;

// Terminator.
{#ND}CRS-AttributeValues[(), #ParsePrefix, ok s t as.#[ok,s,t,as], #first, #terminator]
→
#terminator
;

{String : SortEntry}CRS-Parsed-In[RawParsed, $String, RefMode, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-Parsed-In[RAW-ParsedDone, #ParsePrefix, #refmode, ok s t as.#[ok,s,t,as]] → %n⟪⟫ ;
{#ND}CRS-Parsed-In[RAW-ParsedWord[#Word, #Parsed], #ParsePrefix, #refmode, ok s t as.#[ok,s,t,as]] → %n⟪†« #Word » « {#ND}CRS-Parsed-In[#Parsed, #ParsePrefix, #refmode, ok s t as.#[ok,s,t,as]] »⟫ ;
{#ND}CRS-Parsed-In[RAW-ParsedTerm[#Term, #Parsed], #ParsePrefix, #refmode, ok s t as.#[ok,s,t,as]]
→
%n⟪« {#ND}CRS-Parsed-In2[#Term, TermTopSort[#Term, ""], #ParsePrefix, SubRefMode[#refmode], ok s t as.#[ok,s,t,as]] »« {#ND}CRS-Parsed-In[#Parsed, #ParsePrefix, #refmode, ok s t as.#[ok,s,t,as]] »⟫
;
{String : SortEntry}CRS-Parsed-In2[RawTerm, $String, $String, RefMode, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-Parsed-In2[#Term, #SortName, #ParsePrefix, #refmode, ok s t as.#[ok,s,t,as]]
→
CRS-Embed[#SortName, %n⟪(« {#ND}CRS-Term[#Term, #SortName, #ParsePrefix, #refmode, $False, $False, "", ok s t as.#[ok,s,t,as]] »)⟫]
;

// Construction: recurse with argument sorts.

{String : SortEntry} CRS-TermConstruction[$String<!--Constructor-->, $String<!--BaseConstructor-->, $List[RawScope], $List[RawAttribute], $String, $String, RefMode, $Boolean, $Boolean, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-TermConstruction[#Constructor, #BaseConstructor, #Scopes, #Attributes, #TopSortName, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
{#ND}CRS-TermConstruction1[#Constructor, #Scopes, #Attributes, #TopSortName, {#ND}ConstructorScopeSorts[#TopSortName, #BaseConstructor], #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
;

{String : SortEntry} CRS-TermConstruction1[$String, $List[RawScope], $List[RawAttribute], $String, Lifted[$List[RawScopeSort]], $String, RefMode, $Boolean, $Boolean, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-TermConstruction1[#Constructor, #Scopes, #Attributes, #TopSortName, #LiftedScopeSorts, #ParsePrefix, #refmode, #Pattern, #sprayinherited, ok s t as.#[ok,s,t,as]]
→
IfRefModeHides[#refmode,
 %n⟪« {#ND}CRS-Attributes1[#Attributes, #ParsePrefix, $[If,#Pattern,$True,#sprayinherited], ok s t as.#[ok,s,t,as]] »« {#ND}CRS-TermConstruction2[#Constructor, #Scopes, #LiftedScopeSorts, #ParsePrefix, SubRefMode[#refmode], ok s t as.#[ok,s,t,as]] »⟫,
 {#ND}CRS-Attributes[#Attributes, #TopSortName, #ParsePrefix, ok s t as.#[ok,s,t,as], $[If,#Pattern,$True,#sprayinherited], {#ND}CRS-TermConstruction2[#Constructor, #Scopes, #LiftedScopeSorts, #ParsePrefix, SubRefMode[#refmode], ok s t as.#[ok,s,t,as]]]
];

{String : SortEntry} CRS-TermConstruction2[$String, $List[RawScope], Lifted[$List[RawScopeSort]], $String, RefMode, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-TermConstruction2[#Constructor, (), LIFTED[()],     #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as]] → %n⟪†«#Constructor»⟫ ;
{#ND}CRS-TermConstruction2[#Constructor, (), BOTTOM,         #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as]] → %n⟪†«#Constructor»⟫ ;
{#ND}CRS-TermConstruction2[#Constructor, (), LIFTED[(#1;##)], #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as]] → $[Error,$[:,"Use of ",#Constructor," is missing arguments!"]] ;
{#ND}CRS-TermConstruction2[#Constructor, (#Scope;#Scopes), LIFTED[()],                       #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as]] → $[Error,$[:,"Use of ",#Constructor," has extra arguments!"]] ;
{#ND}CRS-TermConstruction2[#Constructor, (#Scope;#Scopes), BOTTOM,                           #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as]] → %n⟪†«#Constructor»[« {#ND}CRS-TermConstruction3[#Constructor, (#Scope;#Scopes), BOTTOM, #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], ""] »]⟫ ;
{#ND}CRS-TermConstruction2[#Constructor, (#Scope;#Scopes), LIFTED[(#ScopeSort;#ScopeSorts)], #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as]] → %n⟪†«#Constructor»[« {#ND}CRS-TermConstruction3[#Constructor, (#Scope;#Scopes), LIFTED[(#ScopeSort;#ScopeSorts)], #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], ""] »]⟫ ;

{String : SortEntry} CRS-TermConstruction3[$String, $List[RawScope], Lifted[$List[RawScopeSort]], $String, RefMode, ok::Ok s::$String t::Text as::$List[RawAttribute].Text, $String] :: Text;

{#ND}CRS-TermConstruction3[#Constructor, (), LIFTED[()],     #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], #sep] → %n⟪⟫ ;
{#ND}CRS-TermConstruction3[#Constructor, (), BOTTOM,         #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], #sep] → %n⟪⟫ ;
{#ND}CRS-TermConstruction3[#Constructor, (), LIFTED[(#1;##)], #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], #sep] → $[Error,$[:,"Use of ",#Constructor," is missing arguments!"]] ;

{#ND}CRS-TermConstruction3[#Constructor, (#Scope;#Scopes), LIFTED[()], #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], #sep] → $[Error,$[:,"Use of ",#Constructor," has extra arguments!"]] ;
{#ND}CRS-TermConstruction3[#Constructor, (#Scope;#Scopes), BOTTOM,     #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], #sep]
→
%n⟪†«#sep»« {#ND}CRS-Scope[#Scope, BOTTOM, #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as]] »« {#ND}CRS-TermConstruction3[#Constructor, #Scopes, BOTTOM, #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], ", "] »⟫
;
{#ND}CRS-TermConstruction3[#Constructor, (#Scope;#Scopes), LIFTED[(#ScopeSort;#ScopeSorts)], #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], #sep]
→
%n⟪†«#sep»« {#ND}CRS-Scope[#Scope, LIFTED[#ScopeSort], #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as]] »« {#ND}CRS-TermConstruction3[#Constructor, #Scopes, LIFTED[#ScopeSorts], #ParsePrefix, #subrefmode, ok s t as.#[ok,s,t,as], ", "] »⟫
;

// Single scoped subterm. 

{$String : SortEntry} CRS-Scope[RawScope, Lifted[RawScopeSort], $String, RefMode, ok::Ok s::$String t::Text as::$List[RawAttribute].Text] :: Text;
{#ND}CRS-Scope[%rawScope⟪ [#VariableList#] #Term# ⟫, #LiftedScopeSort, #ParsePrefix, #refmode, ok s t as.#[ok,s,t,as]]
→
%n⟪« WrappedTextFold[MapWhen[ok v.ThenAsText[ok,v], #VariableList#], %n⟨ ⟩, %n⟨ ⟩, %n⟨ . ⟩] »« {#ND}CRS-Term[#Term#, Drop[#LiftedScopeSort, s.ScopeSortName[s], ""], #ParsePrefix, #refmode, $False, $False, "", ok s t as.#[ok,s,t,as]] »⟫
;
// TODO: assign sorts to scope binders, and check them for variable CRS-Terms!


/// /////////////////////////////////////////////////////////////////////
/// // EXTRACTING NATIVE FORM HEAD FROM EACH FORM
/// 
/// FormHeadIndex ::=( {$String : FormHead}FHI; );
/// FormHead ::=( FH[$String, $Boolean<!--IsScheme-->]; );
/// 
/// {$String : $StringEntrySort}CRS-FormHeadIndex[$String<!--ParsePrefix-->] :: FormHeadIndex ;
/// {#ND}CRS-FormHeadIndex[#Prefix] → {#ND} CRS-FormHeadIndex0[#Prefix, $[{#ND}Keys]] ;
/// 
/// {#ND}CRS-FormHeadIndex0[#Prefix, #Keys] → FoldWhen[ok k hi.{#ND} CRS-FormHeadIndex1[ok, k, #Prefix, hi], #Keys, {}FHI] ;
/// 
/// {$String : $StringEntrySort}CRS-FormHeadIndex1[Ok, $String<!--SortName-->, $String<!--Prefix-->, FormHeadIndex] :: FormHeadIndex ;
/// {#ND}CRS-FormHeadIndex1[OK, #SortName, #Prefix, #FHI] → CRS-FormHead-Entry[$[{#ND}Get,#SortName,SE_NONE], #SortName, #Prefix, #FHI] ;
/// 
/// CRS-FormHead-Entry[$StringEntrySort, $String<!--SortName-->, $String<!--Prefix-->, FormHeadIndex] :: FormHeadIndex ;
/// //
/// CRS-FormHead-Entry[SE_NONE,                                     #SortName, #Prefix, #FHI] → #FHI ;
/// CRS-FormHead-Entry[SE_TOKEN[#Name],    #SortName, #Prefix, #FHI] → #FHI ;
/// CRS-FormHead-Entry[SE_ATTRIBUTE[#Kind, #Name, #Form, #Options], #SortName, #Prefix, #FHI] → #FHI ;
/// //
/// CRS-FormHead-Entry[SE_SORT[#Defines, #FullName, #Precs, #Wrapper], #SortName, #Prefix, {#FHI}FHI]
/// →
/// Fold[d hi.CRS-FormHead-Define[d, #SortName, #Prefix, hi], #Defines, {#FHI}FHI]
/// ;
/// 
/// CRS-FormHead-Define[Define, $String<!--Key-->, $String<!--Prefix-->, FormHeadIndex] :: FormHeadIndex ;
/// //
/// -[Fresh[dummy]]:
/// CRS-FormHead-Define[D_ABSTRACTION[a.#Define[a]], #SortName, #Prefix, #FHI] → CRS-FormHead-Define[#Define[dummy], #SortName, #Prefix, #FHI] ;
/// // 
/// CRS-FormHead-Define[D_NONE,                                    #SortName, #Prefix, #FHI] → #FHI ;
/// CRS-FormHead-Define[D_RULE[#Rule, #Sort, #IsDataEquivalence?], #SortName, #Prefix, #FHI] → #FHI ;
/// //
/// CRS-FormHead-Define[D_FORM[#Form, FK_DATA[#Tags]],        #SortName, #Prefix, #FHI] → CRS-FormHead-Form[#Form, $False<!--Data-->,  #SortName, #Prefix, #FHI] ;
/// CRS-FormHead-Define[D_FORM[#Form, FK_SCHEME[#Inh]],        #SortName, #Prefix, #FHI] → CRS-FormHead-Form[#Form, $True<!--Scheme-->, #SortName, #Prefix, #FHI] ;
/// CRS-FormHead-Define[D_FORM[#Form, FK_SYMBOL[#Static]],     #SortName, #Prefix, #FHI] → CRS-FormHead-Form[#Form, $False<!--Data-->,  #SortName, #Prefix, #FHI] ;
/// CRS-FormHead-Define[D_FORM[#Form, FK_SUGAR[#Term]],        #SortName, #Prefix, #FHI] → CRS-FormHead-Form[#Form, $True<!--Scheme-->, #SortName, #Prefix, #FHI] ;
/// CRS-FormHead-Define[D_FORM[#Form, FK_ALIAS],               #SortName, #Prefix, #FHI] → CRS-FormHead-Form[#Form, $False<!--Data-->,  #SortName, #Prefix, #FHI] ;
/// 
/// CRS-FormHead-Form[RawForm, $Boolean<!--Scheme?-->, $String<!--Key-->, $String<!--Prefix-->, FormHeadIndex] :: FormHeadIndex ;
/// CRS-FormHead-Form[RAW-FormParsedSorted[#SortName, #ParsedForm, #Prec, #AttRefs], #Scheme?, #SortName2, #Prefix, #FHI] → CRS-FormHead-extend[CRS-ParsedFormHead[#ParsedForm, #Prefix, #SortName], #SortName2, #Scheme?, #FHI] ;
/// CRS-FormHead-Form[RAW-FormParsedUnsorted[#ParsedForm, #Prec, #AttRefs],          #Scheme?, #SortName2, #Prefix, #FHI] → CRS-FormHead-extend[CRS-ParsedFormHead[#ParsedForm, #Prefix, #SortName2], #SortName2, #Scheme?, #FHI] ;
/// CRS-FormHead-Form[RAW-FormConstruction[#Constructor, #Scopes, #AttRefs],         #Scheme?, #SortName2, #Prefix, #FHI] → CRS-FormHead-extend[LIFTED[#Constructor], #SortName2, #Scheme?, #FHI] ;
/// 
/// -[Data[#Constructor,#SortName,#Scheme?]]:
/// CRS-FormHead-extend[LIFTED[#Constructor], #SortName, #Scheme?, {#FHI}FHI] → {#FHI; #Constructor : FH[#SortName, #Scheme?]}FHI ;
/// CRS-FormHead-extend[BOTTOM,               #SortName, #Scheme?, {#FHI}FHI] → {#FHI}FHI ;
/// 
/// CRS-ParsedFormHead[#ParsedForm, #Prefix, #SortName]
/// →
/// CRS-ParsedTextHead[TextToString[CRS-ParsedForm-ParsedForm[#ParsedForm, $True<!--Sorted-->, $False<!--NotForm-->, ok s p q r.%n⟨ A⟩, 1]], #Prefix, #SortName]
/// ;
/// 
/// {#ND}CRS-ParsedHead[#Parsed, #Prefix, ""]
/// →
/// CRS-ParsedTextHead[TextToString[{#ND}CRS-Parsed[#Parsed, (), "", #Prefix, RM_NONE, $False<!--NoCapturePattern-->, $False<!--NoSprayinherited-->]], #Prefix, ""]
/// ;
/// 
/// -[Data[#SortName]]:
/// {#ND}CRS-ParsedHead[#Parsed, #Prefix, #SortName]
/// →
/// CRS-ParsedTextHead[TextToString[{#ND}CRS-Parsed[#Parsed, (), #SortName, #Prefix, RM_NONE, $False<!--NoCapturePattern-->, $False<!--NoSprayinherited-->]], #Prefix, #SortName]
/// ;
/// 
/// -[Data[#ParseText]]:
/// CRS-ParsedTextHead[#ParseText, #Prefix, #SortName]
/// →
/// CRS-ParsedTextHead1[$[ParseText,$[:,#Prefix,#SortName],#ParseText]]
/// ;
/// 
/// CRS-ParsedTextHead1[$[C,#Head,#Args]] → LIFTED[#Head] ;
/// CRS-ParsedTextHead1[$[V,#Name]] → BOTTOM ;
/// 
/// {#ND}IsParsedScheme[#Parsed, #Prefix, #SortName] → IsSchemeHead[{#ND}CRS-ParsedHead[#Parsed, #Prefix, #SortName]] ;
/// {#ND}IsParsedFormScheme[#ParsedForm, #Prefix, #SortName] → IsSchemeHead[{#ND}CRS-ParsedFormHead[#ParsedForm, #Prefix, #SortName]] ;
/// 
/// {#ND}IsSchemeHead[BOTTOM] → $False ;
/// {#ND}IsSchemeHead[LIFTED[#Constructor]] → {#ND}IsScheme[#Constructor] ;
/// 
/// {#ND; "$AllFormHeads" : FORM_HEADS[{#FHI}FHI]}
/// IsScheme[#Constructor]
/// →
/// IsScheme2[$[{#FHI}Get, #Constructor, FH["", $False]]]
/// ;
/// 
/// IsScheme2[FH[#Name, #IsScheme]] → #IsScheme ;


/////////////////////////////////////////////////////////////////////
// CRS CONSTRUCTOR NAMES.

SynthesizedName[$String] :: Text;
SynthesizedName[#AttributeName] → %n⟪Synthesized_†«#AttributeName»⟫ ;

NeedsSynthesizedName[$String] :: Text;
-[Data[#AttributeName]]: NeedsSynthesizedName[#AttributeName] → %n⟪Needs-synthesized-†«#AttributeName»⟫ ;

CollectSynthesizedName[$String] :: Text;
-[Data[#ProductionName,#AttributeName]]: CollectSynthesizedName[#AttributeName] → %n⟪Collect-synthesized-†«#AttributeName»⟫ ;

SetSynthesizedName[$String] :: Text;
-[Data[#AttributeName]]: SetSynthesizedName[#AttributeName] → %n⟪Set-synthesized-†«#AttributeName»⟫ ;

AddSynthesizedName[$String] :: Text;
-[Data[#AttributeName]]: AddSynthesizedName[#AttributeName] → %n⟪Add-synthesized-†«#AttributeName»⟫ ;

InheritedName[$String] :: Text;
InheritedName[#AttributeName] → %n⟪Inherited_†«#AttributeName»⟫ ;

SetInheritedName[$String] :: Text;
-[Data[#AttributeName]]: SetInheritedName[#AttributeName] → %n⟪Set-inherited-†«#AttributeName»⟫ ;

AddInheritedName[$String] :: Text;
-[Data[#ProductionName,#AttributeName]]: AddInheritedName[#AttributeName] → %n⟪Add-inherited-†«#AttributeName»⟫ ;


/////////////////////////////////////////////////////////////////////
// OUTPUT TEMPLATES

// Fragment to be parsed as user language text.
//
CRS-User[$String<!--ParsePrefix-->, Text<!--ProductionName-->, Text] :: Text ;
-[Data[#ParsePrefix, #ProductionName, #Unparsed]]: CRS-User[#ParsePrefix, #ProductionName, #Unparsed] → CRS-User2[#ParsePrefix, #ProductionName, #Unparsed] ;

CRS-User2[$String<!--ParsePrefix-->, Text<!--ProductionName-->, Text] :: Text ;
CRS-User2[#ParsePrefix, #ProductionName, #Unparsed] → %n⟪%†«#ParsePrefix»«#ProductionName»†«"\u27ea"»« #Unparsed »†«"\u27eb"»⟫ ;
///-[Data[#ParsePrefix, #ProductionName, #Unparsed]]: CRS-User[#ParsePrefix, #ProductionName, #Unparsed] → CRS-User2[#ParsePrefix, TextToString[#ProductionName], TextToString[#Unparsed]] ; 
///-[Data[#ProductionName, #UnParsed]]: CRS-User2[#ParsePrefix, #ProductionName, #Unparsed] →$[ParseText, $[:,#ParsePrefix,#ProductionName], #Unparsed] ;

// Fragment denoting term embedded in user language text.
//
CRS-Embed[$String<!--SortName-->, Text<!--Term-->] :: Text ;
CRS-Embed[#SortName, #TermText] → %n⟪ †«"\u27e8"»†«#SortName» « #TermText »†«"\u27e9"» ⟫ ;

// Fragment denoting parsed or indented user language text.
//
CRS-Literate[Text<!--Term-->] :: Text ;
CRS-Literate[#TermText] → %n⟪†«"\u27e6"»« #TermText »†«"\u27e7"»⟫ ;

// Fragment to be parsed as generated text (to be printed).
//
CRS-Text[Text] :: Text ;
CRS-Text[#content] → CRS-User["n", %n⟨⟩, #content] ;


/////////////////////////////////////////////////////////////////////

)]

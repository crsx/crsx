/* Generated By:JavaCC: Do not edit this line. Raw.java */
package net.sf.crsx.hoacs.bootstrap;

/**
 * Grammar for "raw" HOACS systems, in PG form.
 * Used to bootstrap HOACS on a crsx3 system.
 *
 * @author <a href="http://www.research.ibm.com/people/k/krisrose">Kristoffer Rose</a>.
 * @version $Id: Raw.pg,v 1.32 2013/12/05 03:28:29 krisrose Exp $
 */
public class Raw implements net.sf.crsx.Parser, RawConstants {
        /** Factory. */
        net.sf.crsx.Factory<? extends net.sf.crsx.Term> factory;
        /** Compilation unit name for error messages. */
        String unit;
        /** Whether the parser should capture token locations. */
        boolean captureLocations = true;
        /** Constructor with token location information. */
        private net.sf.crsx.Constructor makeTConstructor(net.sf.crsx.Sink sink, Token t, Object object, String sort)
        {
                net.sf.crsx.Constructor c = sort == null ? sink.makeConstructor(object) : sink.makeLiteral(object, sort);
                if (t == null) t = token;
                if (captureLocations && t != null)
                {
                        if (factory.get("meta") == null)
                                c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn);
                }
                return c;
        }

        /** Helper interface with category non-terminal calls. */
        abstract class CategoryCall { abstract net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException; }
        /** Direct category invocations. */
        java.util.Map<String,CategoryCall> categoryCall = new java.util.HashMap<String,CategoryCall>();
        {
                categoryCall.put("raw", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Module$WithEOF(sink, bound);} });
                categoryCall.put("rawModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Module$WithEOF(sink, bound);} });
                categoryCall.put("rawModuleName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ModuleName$WithEOF(sink, bound);} });
                categoryCall.put("rawEmbeddedModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_EmbeddedModule$WithEOF(sink, bound);} });
                categoryCall.put("rawDeclaration", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Declaration$WithEOF(sink, bound);} });
                categoryCall.put("rawDeclarations", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Declarations$WithEOF(sink, bound);} });
                categoryCall.put("rawSortAbstraction", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortAbstraction$WithEOF(sink, bound);} });
                categoryCall.put("rawRule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Rule$WithEOF(sink, bound);} });
                categoryCall.put("rawSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Sort$WithEOF(sink, bound);} });
                categoryCall.put("rawSortParam", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortParam$WithEOF(sink, bound);} });
                categoryCall.put("rawSortName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortName$WithEOF(sink, bound);} });
                categoryCall.put("rawSortNames", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortNames$WithEOF(sink, bound);} });
                categoryCall.put("rawSimpleSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SimpleSort$WithEOF(sink, bound);} });
                categoryCall.put("rawSimpleSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SimpleSorts$WithEOF(sink, bound);} });
                categoryCall.put("rawSubstituteSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SubstituteSorts$WithEOF(sink, bound);} });
                categoryCall.put("rawSubstituteSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SubstituteSort$WithEOF(sink, bound);} });
                categoryCall.put("rawTagging", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Tagging$WithEOF(sink, bound);} });
                categoryCall.put("rawSortAlternative", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortAlternative$WithEOF(sink, bound);} });
                categoryCall.put("rawSortAlternatives", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortAlternatives$WithEOF(sink, bound);} });
                categoryCall.put("rawForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Form$WithEOF(sink, bound);} });
                categoryCall.put("rawFormPrec", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_FormPrec$WithEOF(sink, bound);} });
                categoryCall.put("rawInheritedRefs", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_InheritedRefs$WithEOF(sink, bound);} });
                categoryCall.put("rawInheritedRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_InheritedRef$WithEOF(sink, bound);} });
                categoryCall.put("rawSynthesizedRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SynthesizedRef$WithEOF(sink, bound);} });
                categoryCall.put("rawAttributeKind", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeKind$WithEOF(sink, bound);} });
                categoryCall.put("rawAttributeForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeForm$WithEOF(sink, bound);} });
                categoryCall.put("rawAttributeOptions", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeOptions$WithEOF(sink, bound);} });
                categoryCall.put("rawAttributeOption", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeOption$WithEOF(sink, bound);} });
                categoryCall.put("rawScopeSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ScopeSorts$WithEOF(sink, bound);} });
                categoryCall.put("rawScopeSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ScopeSort$WithEOF(sink, bound);} });
                categoryCall.put("rawParsedForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ParsedForm$WithEOF(sink, bound);} });
                categoryCall.put("rawRepeat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Repeat$WithEOF(sink, bound);} });
                categoryCall.put("rawPriority", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Priority$WithEOF(sink, bound);} });
                categoryCall.put("rawFragmentName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_FragmentName$WithEOF(sink, bound);} });
                categoryCall.put("rawFragmentRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_FragmentRef$WithEOF(sink, bound);} });
                categoryCall.put("rawRegExp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExp$WithEOF(sink, bound);} });
                categoryCall.put("rawRegExpChoice", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpChoice$WithEOF(sink, bound);} });
                categoryCall.put("rawRegExpUnits", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpUnits$WithEOF(sink, bound);} });
                categoryCall.put("rawRegExpUnit", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpUnit$WithEOF(sink, bound);} });
                categoryCall.put("rawRegExpSimple", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpSimple$WithEOF(sink, bound);} });
                categoryCall.put("rawRegExpLeaf", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpLeaf$WithEOF(sink, bound);} });
                categoryCall.put("rawWord", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Word$WithEOF(sink, bound);} });
                categoryCall.put("rawTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Term$WithEOF(sink, bound);} });
                categoryCall.put("rawNotVariableTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_NotVariableTerm$WithEOF(sink, bound);} });
                categoryCall.put("rawAttributes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Attributes$WithEOF(sink, bound);} });
                categoryCall.put("rawAttribute", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Attribute$WithEOF(sink, bound);} });
                categoryCall.put("rawAttributeValue", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeValue$WithEOF(sink, bound);} });
                categoryCall.put("rawScopes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Scopes$WithEOF(sink, bound);} });
                categoryCall.put("rawScope", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Scope$WithEOF(sink, bound);} });
                categoryCall.put("rawTerms", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Terms$WithEOF(sink, bound);} });
                categoryCall.put("rawParsed", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Parsed$WithEOF(sink, bound);} });
                categoryCall.put("rawLiteral", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Literal$WithEOF(sink, bound);} });
                categoryCall.put("rawConstructor", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Constructor$WithEOF(sink, bound);} });
                categoryCall.put("rawMetaVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_MetaVariable$WithEOF(sink, bound);} });
                categoryCall.put("rawMetaVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_MetaVariables$WithEOF(sink, bound);} });
                categoryCall.put("rawVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Variable$WithEOF(sink, bound);} });
                categoryCall.put("rawVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Variables$WithEOF(sink, bound);} });
                categoryCall.put("rawAttributeName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeName$WithEOF(sink, bound);} });
                categoryCall.put("rawRegExpClass", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpClass$WithEOF(sink, bound);} });
                categoryCall.put("rawCC", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC$WithEOF(sink, bound);} });
                categoryCall.put("rawCC_RangesTop", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_RangesTop$WithEOF(sink, bound);} });
                categoryCall.put("rawCC_Ranges", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_Ranges$WithEOF(sink, bound);} });
                categoryCall.put("rawCC_FirstRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_FirstRangeStartChar$WithEOF(sink, bound);} });
                categoryCall.put("rawCC_NonDashRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_NonDashRangeStartChar$WithEOF(sink, bound);} });
                categoryCall.put("rawCC_RangeChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_RangeChar$WithEOF(sink, bound);} });
        }

        // Constructor.

        /** Construct dummy instance. */
        public Raw()
        {
                this((java.io.Reader) null);
                disable_tracing();
        }

        // Parser implementation.

        public net.sf.crsx.Parser parser(net.sf.crsx.Factory<? extends net.sf.crsx.Term> f)
        {
                if (factory != null)
                {
                        net.sf.crsx.Parser parser = new Raw().parser(f);
                        parser.setParserVerbose(trace_enabled); parser.setParserLocation(captureLocations);
                        return parser;
                }
                else
                {
                        factory = f;
                        assert f != null : "Or Else!";
                        return this;
                }
        }

        public void setParserVerbose(boolean verbose)
        {
                if (verbose)
                        enable_tracing();
                else
                        disable_tracing();
        }

        public void setParserLocation(boolean capture)
        {
                captureLocations = capture;
        }

        public void setEmbeddedParser(net.sf.crsx.Parser subparser) throws net.sf.crsx.CRSException
        {}

        public Iterable<String> categories()
        {
                return categoryCall.keySet();
        }

        public net.sf.crsx.Sink parse(net.sf.crsx.Sink sink, String category, java.io.Reader reader, String unit, int firstLine, int firstColumn, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                try
                {
                        this.unit = unit;
                        ReInit((java.io.Reader) null);
                        jj_input_stream.ReInit(reader, firstLine, firstColumn); token_source = new RawTokenManager(jj_input_stream); // hacks to update line and column numbers
                        if (bound == null) bound = new net.sf.crsx.util.LinkedExtensibleMap<String, net.sf.crsx.Variable>();
                        if (category == null || category.length() == 0) return N_Module(sink, bound);
                        else if (categoryCall.containsKey(category)) return categoryCall.get(category).call(sink, bound);
                        else throw new net.sf.crsx.CRSException("Parser category '"+category+"' not supported!");
                }
                catch (ParseException e)
                {
                        throw new net.sf.crsx.CRSException(e.getMessage());
                }
        }

        public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
                parse(buffer.sink(), category, reader, null, 1, 1, bound);
                return buffer.term(true);
        }


  static String raw(String s) {return "RAW-"+s;} // prefix for constructors
  static String unembed(String s) {return s.substring(1, s.length()-1);}

        /**
	 * Run the parser and print the resulting term.
	 * @param args should contain two strings: the category and an input file name
	 */
        public static void main(String[] args)
        {
                try
                {
                        if (args.length != 2)
                        {
                                System.err.println("Usage: Raw category input");
                                System.exit(2);
                        }
                        String category = args[0];
                        java.io.Reader reader = new java.io.FileReader(args[1]);
                        net.sf.crsx.Factory<net.sf.crsx.generic.GenericTerm> factory = new net.sf.crsx.generic.GenericFactory();
                        net.sf.crsx.Parser parser = new Raw();
                        net.sf.crsx.Sink sink = factory.sink(System.out);
                        parser.parser(factory).parse(sink, category, reader, null, 1, 1, null);
                }
                catch (net.sf.crsx.CRSException e)
                {
                        System.err.println("CRS error: "+e);
                        System.exit(1);
                }
                catch (java.io.IOException e)
                {
                        System.err.println("I/O error: "+e);
                        System.exit(1);
                }
        }

/**
 * <em>Embedded</em> ::=   <a href="#T_Embedded">Embedded</a><font color="red">$$:unembed</font> 
 */
  final public net.sf.crsx.Sink N_Embedded(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Embedded");
    try {
        Token t = null;
      t = jj_consume_token(T_Embedded);
                try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unembed(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Embedded");
    }
  }

/** <em>Module$WithEOF</em> ::= <em>Module</em> EOF . */
  final public net.sf.crsx.Sink N_Module$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Module$WithEOF");
    try {
      sink = N_Module(sink, env);
      jj_consume_token(0);
                                  {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Module$WithEOF");
    }
  }

/**
 * <em>Module</em> ::=  <font color="red">{top-module}</font><font color="red">:raw</font>   <a href="#N_EmbeddedModule">&lang;EmbeddedModule&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Module(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Module");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Module:
        t = jj_consume_token(MT_Module);
                       sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_1:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[0] = jj_gen;
              break label_1;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[1] = jj_gen;
          ;
        }
                                                                                                                                                                    {if (true) return sink.endMetaApplication();}
        break;
      case IT_Module:
        jj_consume_token(IT_Module);
                      sink=N_Embedded(sink, env);
                                                     {if (true) return sink;}
        break;
      case MT_EmbeddedModule:
      case IT_EmbeddedModule:
      case T_MODULE:
                sink = sink .start(makeTConstructor(sink, t, raw("top-module"), null)) ;
        sink = N_EmbeddedModule(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Module");
    }
  }

/** <em>EmbeddedModule$WithEOF</em> ::= <em>EmbeddedModule</em> EOF . */
  final public net.sf.crsx.Sink N_EmbeddedModule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_EmbeddedModule$WithEOF");
    try {
      sink = N_EmbeddedModule(sink, env);
      jj_consume_token(0);
                                          {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_EmbeddedModule$WithEOF");
    }
  }

/**
 * <em>EmbeddedModule</em> ::=   <a href="#T_MODULE">MODULE</a><font color="red">:raw</font>   <a href="#N_ModuleName">&lang;ModuleName&rang;</a>     <a href="#T_LBRACE">LBRACE</a>   <a href="#N_Declarations">&lang;Declarations&rang;</a>     <a href="#T_RBRACE">RBRACE</a> 
 */
  final public net.sf.crsx.Sink N_EmbeddedModule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_EmbeddedModule");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_EmbeddedModule:
        t = jj_consume_token(MT_EmbeddedModule);
                               sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_2:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[3] = jj_gen;
              break label_2;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[4] = jj_gen;
          ;
        }
                                                                                                                                                                            {if (true) return sink.endMetaApplication();}
        break;
      case IT_EmbeddedModule:
        jj_consume_token(IT_EmbeddedModule);
                              sink=N_Embedded(sink, env);
                                                             {if (true) return sink;}
        break;
      case T_MODULE:
        t = jj_consume_token(T_MODULE);
                sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
        sink = N_ModuleName(sink, env);
        jj_consume_token(T_LBRACE);
        sink = N_Declarations(sink, env);
        jj_consume_token(T_RBRACE);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_EmbeddedModule");
    }
  }

/** <em>Declarations$WithEOF</em> ::= <em>Declarations</em> EOF . */
  final public net.sf.crsx.Sink N_Declarations$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Declarations$WithEOF");
    try {
      sink = N_Declarations(sink, env);
      jj_consume_token(0);
                                        {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Declarations$WithEOF");
    }
  }

/**
 * <em>Declarations</em> ::=  (  <font color="red">{$Cons}</font><font color="red">:raw</font>   <a href="#N_Declaration">&lang;Declaration&rang;</a>    <a href="#N_Declarations">&lang;Declarations&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_Declarations(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Declarations");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Declarations:
        t = jj_consume_token(MT_Declarations);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_3:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[6] = jj_gen;
              break label_3;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_Declarations:
        jj_consume_token(IT_Declarations);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      default:
        jj_la1[9] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MT_EmbeddedModule:
        case IT_EmbeddedModule:
        case MT_Declaration:
        case IT_Declaration:
        case MT_SortAlternatives:
        case IT_SortAlternatives:
        case MT_SortAlternative:
        case IT_SortAlternative:
        case MT_Rule:
        case IT_Rule:
        case MT_Priority:
        case IT_Priority:
        case MT_Construction:
        case IT_Construction:
        case MT_Constructor:
        case IT_Constructor:
        case MT_Literal:
        case IT_Literal:
        case MT_Number:
        case IT_Number:
        case MT_Natural:
        case IT_Natural:
        case MT_String:
        case IT_String:
        case T_CONCRETESTART:
        case T_SEMI:
        case T_BAR:
        case T_LBRACE:
        case T_DASH:
        case T_DIGIT:
        case T_UPPER:
        case T_MODULE:
        case T_SORT:
        case T_ATTRIBUTE:
        case T_RULE:
        case T_PRIORITY:
        case T_DEFAULT:
        case T_IMPORT:
        case T_SPACE:
        case T_TOKEN:
        case T_FRAGMENT:
        case T_CON:
        case T_NATURAL:
        case T_UNNATURAL:
        case T_STRING:
                        sink = sink .start(makeTConstructor(sink, t, raw("Declarations$Cons"), null)) ;
          sink = N_Declaration(sink, env);
          sink = N_Declarations(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[8] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "Declarations$Nil", null)) ;
                        sink = sink .end() ;
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Declarations");
    }
  }

/** <em>Declaration$WithEOF</em> ::= <em>Declaration</em> EOF . */
  final public net.sf.crsx.Sink N_Declaration$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Declaration$WithEOF");
    try {
      sink = N_Declaration(sink, env);
      jj_consume_token(0);
                                       {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Declaration$WithEOF");
    }
  }

/**
 * <em>Declaration</em> ::=  <font color="red">{embedded-module}</font><font color="red">:raw</font>   <a href="#N_EmbeddedModule">&lang;EmbeddedModule&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_IMPORT">IMPORT</a><font color="red">:raw</font>   <a href="#N_ModuleName">&lang;ModuleName&rang;</a>    (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_SortNames">&lang;SortNames&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |  <font color="red">{$Nil}</font>  )    <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_SPACE">SPACE</a><font color="red">:raw</font>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_TOKEN">TOKEN</a>   (  <font color="red">{'token'}</font><font color="red">:raw</font>   <a href="#N_SortName">&lang;SortName&rang;</a>     <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  |   <a href="#T_FRAGMENT">FRAGMENT</a><font color="red">:raw</font>   <a href="#N_FragmentName">&lang;FragmentName&rang;</a>     <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  )  <br>
 *  |   <a href="#T_FRAGMENT">FRAGMENT</a><font color="red">:raw</font>   <a href="#N_FragmentName">&lang;FragmentName&rang;</a>     <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_ATTRIBUTE">ATTRIBUTE</a><font color="red">:raw</font>   <a href="#N_AttributeKind">&lang;AttributeKind&rang;</a>    <a href="#N_AttributeName">&lang;AttributeName&rang;</a>    <a href="#N_AttributeForm">&lang;AttributeForm&rang;</a>    <a href="#N_AttributeOptions">&lang;AttributeOptions&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_SORT">SORT</a><font color="red">:raw</font>   <a href="#N_SortName">&lang;SortName&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>    <a href="#N_SortAbstraction">&lang;SortAbstraction&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  <font color="red">{anonymous}</font><font color="red">:raw</font>   <a href="#N_SortAlternatives">&lang;SortAlternatives&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  (   <a href="#T_RULE">RULE</a>  )?   <font color="red">{rule}</font><font color="red">:raw</font>   <a href="#N_Rule">&lang;Rule&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  <font color="red">{nestedDeclarations}</font><font color="red">:raw</font>    <a href="#T_LBRACE">LBRACE</a>   <a href="#N_Declarations">&lang;Declarations&rang;</a>     <a href="#T_RBRACE">RBRACE</a> 
 */
  final public net.sf.crsx.Sink N_Declaration(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Declaration");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Declaration:
        t = jj_consume_token(MT_Declaration);
                            sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_4:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[10] = jj_gen;
              break label_4;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[11] = jj_gen;
          ;
        }
                                                                                                                                                                         {if (true) return sink.endMetaApplication();}
        break;
      case IT_Declaration:
        jj_consume_token(IT_Declaration);
                           sink=N_Embedded(sink, env);
                                                          {if (true) return sink;}
        break;
      case MT_EmbeddedModule:
      case IT_EmbeddedModule:
      case T_MODULE:
                sink = sink .start(makeTConstructor(sink, t, raw("embedded-module"), null)) ;
        sink = N_EmbeddedModule(sink, env);
        jj_consume_token(T_SEMI);
                {if (true) return sink .end() ;}
        break;
      case T_IMPORT:
        t = jj_consume_token(T_IMPORT);
                sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
        sink = N_ModuleName(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_LPAREN:
          jj_consume_token(T_LPAREN);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MT_SortNames:
          case IT_SortNames:
          case MT_SortName:
          case IT_SortName:
          case MT_Constructor:
          case IT_Constructor:
          case T_DASH:
          case T_UPPER:
          case T_CON:
            sink = N_SortNames(sink, env);
            break;
          default:
            jj_la1[12] = jj_gen;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
          }
          jj_consume_token(T_RPAREN);
          break;
        default:
          jj_la1[13] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        jj_consume_token(T_SEMI);
                {if (true) return sink .end() ;}
        break;
      case T_SPACE:
        t = jj_consume_token(T_SPACE);
                sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
        sink = N_RegExp(sink, env);
        jj_consume_token(T_SEMI);
                {if (true) return sink .end() ;}
        break;
      case T_TOKEN:
        jj_consume_token(T_TOKEN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MT_SortName:
        case IT_SortName:
        case MT_Constructor:
        case IT_Constructor:
        case T_DASH:
        case T_UPPER:
        case T_CON:
                        sink = sink .start(makeTConstructor(sink, t, raw("token"), null)) ;
          sink = N_SortName(sink, env);
          jj_consume_token(T_BAR);
          sink = N_RegExp(sink, env);
          jj_consume_token(T_SEMI);
                        sink = sink .end() ;
          break;
        case T_FRAGMENT:
          t = jj_consume_token(T_FRAGMENT);
                        sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
          sink = N_FragmentName(sink, env);
          jj_consume_token(T_BAR);
          sink = N_RegExp(sink, env);
          jj_consume_token(T_SEMI);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      case T_FRAGMENT:
        t = jj_consume_token(T_FRAGMENT);
                sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
        sink = N_FragmentName(sink, env);
        jj_consume_token(T_BAR);
        sink = N_RegExp(sink, env);
        jj_consume_token(T_SEMI);
                {if (true) return sink .end() ;}
        break;
      case T_ATTRIBUTE:
        t = jj_consume_token(T_ATTRIBUTE);
                sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
        sink = N_AttributeKind(sink, env);
        sink = N_AttributeName(sink, env);
        sink = N_AttributeForm(sink, env);
        sink = N_AttributeOptions(sink, env);
        jj_consume_token(T_SEMI);
                {if (true) return sink .end() ;}
        break;
      case T_SORT:
        t = jj_consume_token(T_SORT);
                sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
        sink = N_SortName(sink, env);
        sink = N_Repeat(sink, env);
        sink = N_SortAbstraction(sink, env);
        jj_consume_token(T_SEMI);
                {if (true) return sink .end() ;}
        break;
      case MT_SortAlternatives:
      case IT_SortAlternatives:
      case MT_SortAlternative:
      case IT_SortAlternative:
      case T_SEMI:
      case T_BAR:
                sink = sink .start(makeTConstructor(sink, t, raw("anonymous"), null)) ;
        sink = N_SortAlternatives(sink, env);
        jj_consume_token(T_SEMI);
                {if (true) return sink .end() ;}
        break;
      case MT_Rule:
      case IT_Rule:
      case MT_Priority:
      case IT_Priority:
      case MT_Construction:
      case IT_Construction:
      case MT_Constructor:
      case IT_Constructor:
      case MT_Literal:
      case IT_Literal:
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case MT_String:
      case IT_String:
      case T_CONCRETESTART:
      case T_DASH:
      case T_DIGIT:
      case T_UPPER:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_CON:
      case T_NATURAL:
      case T_UNNATURAL:
      case T_STRING:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_RULE:
          jj_consume_token(T_RULE);
          break;
        default:
          jj_la1[15] = jj_gen;
          ;
        }
                sink = sink .start(makeTConstructor(sink, t, raw("rule"), null)) ;
        sink = N_Rule(sink, env);
        jj_consume_token(T_SEMI);
                {if (true) return sink .end() ;}
        break;
      case T_LBRACE:
                sink = sink .start(makeTConstructor(sink, t, raw("nestedDeclarations"), null)) ;
        jj_consume_token(T_LBRACE);
        sink = N_Declarations(sink, env);
        jj_consume_token(T_RBRACE);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Declaration");
    }
  }

/** <em>RegExp$WithEOF</em> ::= <em>RegExp</em> EOF . */
  final public net.sf.crsx.Sink N_RegExp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExp$WithEOF");
    try {
   token_source.SwitchTo(RE);
      sink = N_RegExp(sink, env);
      jj_consume_token(0);
                                                               {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExp$WithEOF");
    }
  }

/**
 * <em>RegExp</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_RegExpChoice">&lang;RegExpChoice&rang;</a>    (   <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_RegExp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExp");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_RegExp:
        t = jj_consume_token(MT_RegExp);
                       sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_5:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[17] = jj_gen;
              break label_5;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[18] = jj_gen;
          ;
        }
                                                                                                                                                                    {if (true) return sink.endMetaApplication();}
        break;
      case IT_RegExp:
        jj_consume_token(IT_RegExp);
                      sink=N_Embedded(sink, env);
                                                     {if (true) return sink;}
        break;
      default:
        jj_la1[20] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "RegExp$Cons", null)) ;
        sink = N_RegExpChoice(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_BAR:
          jj_consume_token(T_BAR);
          sink = N_RegExp(sink, env);
          break;
        default:
          jj_la1[19] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "RegExp$Nil", null)) ;
                        sink = sink .end() ;
        }
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExp");
    }
  }

/** <em>RegExpChoice$WithEOF</em> ::= <em>RegExpChoice</em> EOF . */
  final public net.sf.crsx.Sink N_RegExpChoice$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpChoice$WithEOF");
    try {
   token_source.SwitchTo(RE);
      sink = N_RegExpChoice(sink, env);
      jj_consume_token(0);
                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpChoice$WithEOF");
    }
  }

/**
 * <em>RegExpChoice</em> ::=   <a href="#T_NESTED">NESTED</a><font color="red">:raw</font>   <a href="#N_RegExpSimple">&lang;RegExpSimple&rang;</a>    <a href="#N_RegExpSimple">&lang;RegExpSimple&rang;</a>   <br>
 *  |  <font color="red">{RegExpConcat}</font><font color="red">:raw</font>   <a href="#N_RegExpUnits">&lang;RegExpUnits&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RegExpChoice(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpChoice");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_RegExpChoice:
        t = jj_consume_token(MT_RegExpChoice);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_6:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[21] = jj_gen;
              break label_6;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_RegExpChoice:
        jj_consume_token(IT_RegExpChoice);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case T_NESTED:
        t = jj_consume_token(T_NESTED);
                sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
        sink = N_RegExpSimple(sink, env);
        sink = N_RegExpSimple(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[23] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpConcat"), null)) ;
        sink = N_RegExpUnits(sink, env);
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpChoice");
    }
  }

/** <em>RegExpUnits$WithEOF</em> ::= <em>RegExpUnits</em> EOF . */
  final public net.sf.crsx.Sink N_RegExpUnits$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpUnits$WithEOF");
    try {
   token_source.SwitchTo(RE);
      sink = N_RegExpUnits(sink, env);
      jj_consume_token(0);
                                                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpUnits$WithEOF");
    }
  }

/**
 * <em>RegExpUnits</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_RegExpUnit">&lang;RegExpUnit&rang;</a>    <a href="#N_RegExpUnits">&lang;RegExpUnits&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_RegExpUnits(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpUnits");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_RegExpUnits:
        t = jj_consume_token(MT_RegExpUnits);
                            sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_7:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[24] = jj_gen;
              break label_7;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[25] = jj_gen;
          ;
        }
                                                                                                                                                                         {if (true) return sink.endMetaApplication();}
        break;
      case IT_RegExpUnits:
        jj_consume_token(IT_RegExpUnits);
                           sink=N_Embedded(sink, env);
                                                          {if (true) return sink;}
        break;
      case MT_RegExpUnit:
      case IT_RegExpUnit:
      case MT_RegExpLeaf:
      case IT_RegExpLeaf:
      case MT_RegExpSimple:
      case IT_RegExpSimple:
      case MT_FragmentRef:
      case IT_FragmentRef:
      case MT_String:
      case IT_String:
      case MT_Word:
      case IT_Word:
      case MT_RegExpClass:
      case IT_RegExpClass:
      case T_LPAREN:
      case T_DOT:
      case T_DASH:
      case T_UPPER:
      case T_CON:
      case T_FRAGMENT_REF:
      case T_STRING:
      case T_ESCAPEDCHAR:
      case T_WORD:
      case T_CHAR_CLASS:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_RegExpUnit(sink, env);
        sink = N_RegExpUnits(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[26] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpUnits");
    }
  }

/** <em>RegExpUnit$WithEOF</em> ::= <em>RegExpUnit</em> EOF . */
  final public net.sf.crsx.Sink N_RegExpUnit$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpUnit$WithEOF");
    try {
   token_source.SwitchTo(RE);
      sink = N_RegExpUnit(sink, env);
      jj_consume_token(0);
                                                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpUnit$WithEOF");
    }
  }

/**
 * <em>RegExpUnit</em> ::=  <font color="red">{RegExpUnit}</font><font color="red">:raw</font>   <a href="#N_RegExpSimple">&lang;RegExpSimple&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RegExpUnit(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpUnit");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_RegExpUnit:
        t = jj_consume_token(MT_RegExpUnit);
                           sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_8:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[27] = jj_gen;
              break label_8;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[28] = jj_gen;
          ;
        }
                                                                                                                                                                        {if (true) return sink.endMetaApplication();}
        break;
      case IT_RegExpUnit:
        jj_consume_token(IT_RegExpUnit);
                          sink=N_Embedded(sink, env);
                                                         {if (true) return sink;}
        break;
      case MT_RegExpLeaf:
      case IT_RegExpLeaf:
      case MT_RegExpSimple:
      case IT_RegExpSimple:
      case MT_FragmentRef:
      case IT_FragmentRef:
      case MT_String:
      case IT_String:
      case MT_Word:
      case IT_Word:
      case MT_RegExpClass:
      case IT_RegExpClass:
      case T_LPAREN:
      case T_DOT:
      case T_DASH:
      case T_UPPER:
      case T_CON:
      case T_FRAGMENT_REF:
      case T_STRING:
      case T_ESCAPEDCHAR:
      case T_WORD:
      case T_CHAR_CLASS:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpUnit"), null)) ;
        sink = N_RegExpSimple(sink, env);
        sink = N_Repeat(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpUnit");
    }
  }

/** <em>Repeat$WithEOF</em> ::= <em>Repeat</em> EOF . */
  final public net.sf.crsx.Sink N_Repeat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Repeat$WithEOF");
    try {
   token_source.SwitchTo(DEFAULT);
      sink = N_Repeat(sink, env);
      jj_consume_token(0);
                                                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Repeat$WithEOF");
    }
  }

/**
 * <em>Repeat</em> ::=   <a href="#T_PLUS">PLUS</a>   (  <font color="red">{RepeatSomeSep}</font><font color="red">:raw</font>    <a href="#T_SUB">SUB</a>   (  <a href="#N_RegExpLeaf">&lang;RegExpLeaf&rang;</a>   |  <font color="red">{RegExpWord}</font><font color="red">:raw</font>   <a href="#N_Separator">&lang;Separator&rang;</a>   )  |  <font color="red">{RepeatSome}</font><font color="red">:raw</font>  )  <br>
 *  |  <font color="red">{RepeatMaybeSome}</font><font color="red">:raw</font>    <a href="#T_STAR">STAR</a>  <br>
 *  |  <font color="red">{RepeatMaybe}</font><font color="red">:raw</font>    <a href="#T_QUEST">QUEST</a>  <br>
 *  |  <font color="red">{RepeatSingle}</font><font color="red">:raw</font> 
 */
  final public net.sf.crsx.Sink N_Repeat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Repeat");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Repeat:
        t = jj_consume_token(MT_Repeat);
                       sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_9:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[30] = jj_gen;
              break label_9;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[31] = jj_gen;
          ;
        }
                                                                                                                                                                    {if (true) return sink.endMetaApplication();}
        break;
      case IT_Repeat:
        jj_consume_token(IT_Repeat);
                      sink=N_Embedded(sink, env);
                                                     {if (true) return sink;}
        break;
      case T_PLUS:
        jj_consume_token(T_PLUS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_SUB:
                        sink = sink .start(makeTConstructor(sink, t, raw("RepeatSomeSep"), null)) ;
          jj_consume_token(T_SUB);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MT_RegExpLeaf:
          case IT_RegExpLeaf:
          case MT_String:
          case IT_String:
          case MT_Word:
          case IT_Word:
          case T_DASH:
          case T_UPPER:
          case T_CON:
          case T_STRING:
          case T_WORD:
            sink = N_RegExpLeaf(sink, env);
            break;
          case MT_Separator:
          case IT_Separator:
          case T_SEMI:
          case T_BAR:
          case T_STAR:
          case T_DOT:
          case T_COLON:
          case T_COMMA:
                                sink = sink .start(makeTConstructor(sink, t, raw("RegExpWord"), null)) ;
            sink = N_Separator(sink, env);
                                sink = sink .end() ;
            break;
          default:
            jj_la1[32] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                        sink = sink .end() ;
          break;
        default:
          jj_la1[33] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, raw("RepeatSome"), null)) ;
                        sink = sink .end() ;
        }
         {if (true) return sink;}
        break;
      case T_STAR:
                sink = sink .start(makeTConstructor(sink, t, raw("RepeatMaybeSome"), null)) ;
        jj_consume_token(T_STAR);
                {if (true) return sink .end() ;}
        break;
      case T_QUEST:
                sink = sink .start(makeTConstructor(sink, t, raw("RepeatMaybe"), null)) ;
        jj_consume_token(T_QUEST);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[34] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, raw("RepeatSingle"), null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Repeat");
    }
  }

/** <em>RegExpLeaf$WithEOF</em> ::= <em>RegExpLeaf</em> EOF . */
  final public net.sf.crsx.Sink N_RegExpLeaf$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpLeaf$WithEOF");
    try {
   token_source.SwitchTo(DEFAULT);
      sink = N_RegExpLeaf(sink, env);
      jj_consume_token(0);
                                                                        {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpLeaf$WithEOF");
    }
  }

/**
 * <em>RegExpLeaf</em> ::=  <font color="red">{RegExpString}</font><font color="red">:raw</font>   <a href="#N_String">&lang;String&rang;</a>   <br>
 *  |  <font color="red">{RegExpWord}</font><font color="red">:raw</font>   <a href="#N_Word">&lang;Word&rang;</a>  
 */
  final public net.sf.crsx.Sink N_RegExpLeaf(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpLeaf");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_RegExpLeaf:
        t = jj_consume_token(MT_RegExpLeaf);
                           sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_10:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[35] = jj_gen;
              break label_10;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
                                                                                                                                                                        {if (true) return sink.endMetaApplication();}
        break;
      case IT_RegExpLeaf:
        jj_consume_token(IT_RegExpLeaf);
                          sink=N_Embedded(sink, env);
                                                         {if (true) return sink;}
        break;
      case MT_String:
      case IT_String:
      case T_STRING:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpString"), null)) ;
        sink = N_String(sink, env);
                {if (true) return sink .end() ;}
        break;
      case MT_Word:
      case IT_Word:
      case T_DASH:
      case T_UPPER:
      case T_CON:
      case T_WORD:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpWord"), null)) ;
        sink = N_Word(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpLeaf");
    }
  }

/** <em>RegExpSimple$WithEOF</em> ::= <em>RegExpSimple</em> EOF . */
  final public net.sf.crsx.Sink N_RegExpSimple$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpSimple$WithEOF");
    try {
   token_source.SwitchTo(RE);
      sink = N_RegExpSimple(sink, env);
      jj_consume_token(0);
                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpSimple$WithEOF");
    }
  }

/**
 * <em>RegExpSimple</em> ::=  <a href="#N_RegExpLeaf">&lang;RegExpLeaf&rang;</a>   <br>
 *  |  <font color="red">{RegExpRef}</font><font color="red">:raw</font>   <a href="#N_FragmentRef">&lang;FragmentRef&rang;</a>   <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:raw</font>   <a href="#N_RegExpClass">&lang;RegExpClass&rang;</a>   <br>
 *  |  <font color="red">{RegExpAny}</font><font color="red">:raw</font>    <a href="#T_DOT">DOT</a>  <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:raw</font>   <font color="red">{RegExpClassChar}</font><font color="red">:raw</font>   (   <a href="#T_ESCAPEDCHAR">ESCAPEDCHAR</a><font color="red">$</font>  )   <font color="red">{RegExpClassDone}</font><font color="red">:raw</font>  <br>
 *  |  <font color="red">{RegExpNest}</font><font color="red">:raw</font>    <a href="#T_LPAREN">LPAREN</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_RPAREN">RPAREN</a> 
 */
  final public net.sf.crsx.Sink N_RegExpSimple(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpSimple");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_RegExpSimple:
        t = jj_consume_token(MT_RegExpSimple);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_11:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[38] = jj_gen;
              break label_11;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[39] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_RegExpSimple:
        jj_consume_token(IT_RegExpSimple);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case MT_RegExpLeaf:
      case IT_RegExpLeaf:
      case MT_String:
      case IT_String:
      case MT_Word:
      case IT_Word:
      case T_DASH:
      case T_UPPER:
      case T_CON:
      case T_STRING:
      case T_WORD:
        sink = N_RegExpLeaf(sink, env);
         {if (true) return sink;}
        break;
      case MT_FragmentRef:
      case IT_FragmentRef:
      case T_FRAGMENT_REF:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpRef"), null)) ;
        sink = N_FragmentRef(sink, env);
                {if (true) return sink .end() ;}
        break;
      case MT_RegExpClass:
      case IT_RegExpClass:
      case T_CHAR_CLASS:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpClass"), null)) ;
        sink = N_RegExpClass(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_DOT:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpAny"), null)) ;
        jj_consume_token(T_DOT);
                {if (true) return sink .end() ;}
        break;
      case T_ESCAPEDCHAR:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpClass"), null)) ;
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassChar"), null)) ;
        t = jj_consume_token(T_ESCAPEDCHAR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassDone"), null)) ;
                {if (true) return sink .end().end().end() ;}
        break;
      case T_LPAREN:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpNest"), null)) ;
        jj_consume_token(T_LPAREN);
        sink = N_RegExp(sink, env);
        jj_consume_token(T_RPAREN);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpSimple");
    }
  }

/** <em>AttributeForm$WithEOF</em> ::= <em>AttributeForm</em> EOF . */
  final public net.sf.crsx.Sink N_AttributeForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeForm$WithEOF");
    try {
      sink = N_AttributeForm(sink, env);
      jj_consume_token(0);
                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeForm$WithEOF");
    }
  }

/**
 * <em>AttributeForm</em> ::=  <font color="red">{AttributeFormSimple}</font><font color="red">:raw</font>    <a href="#T_LPAREN">LPAREN</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RPAREN">RPAREN</a>  <br>
 *  |   <a href="#T_LBRACE">LBRACE</a>   <a href="#N_Sort">&lang;Sort&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeFormMap}</font><font color="red">:raw</font>   <font color="red">{{#}}</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  |  <font color="red">{AttributeFormSet}</font><font color="red">:raw</font>   <font color="red">{{#}}</font>    <a href="#T_RBRACE">RBRACE</a>  ) 
 */
  final public net.sf.crsx.Sink N_AttributeForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeForm");
    try {
        Token t = null;
        net.sf.crsx.Sink bs__ = null;
        net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_AttributeForm:
        t = jj_consume_token(MT_AttributeForm);
                              sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_12:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[41] = jj_gen;
              break label_12;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[42] = jj_gen;
          ;
        }
                                                                                                                                                                           {if (true) return sink.endMetaApplication();}
        break;
      case IT_AttributeForm:
        jj_consume_token(IT_AttributeForm);
                             sink=N_Embedded(sink, env);
                                                            {if (true) return sink;}
        break;
      case T_LPAREN:
                sink = sink .start(makeTConstructor(sink, t, raw("AttributeFormSimple"), null)) ;
        jj_consume_token(T_LPAREN);
        sink = N_Sort(sink, env);
        jj_consume_token(T_RPAREN);
                {if (true) return sink .end() ;}
        break;
      case T_LBRACE:
        jj_consume_token(T_LBRACE);
                bs__ = b__.sink();
        N_Sort(bs__, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_COLON:
                        sink = sink .start(makeTConstructor(sink, t, raw("AttributeFormMap"), null)) ;
                        sink = sink .copy(b__, true) ;
          jj_consume_token(T_COLON);
          sink = N_Sort(sink, env);
          jj_consume_token(T_RBRACE);
                        sink = sink .end() ;
          break;
        case T_RBRACE:
                        sink = sink .start(makeTConstructor(sink, t, raw("AttributeFormSet"), null)) ;
                        sink = sink .copy(b__, true) ;
          jj_consume_token(T_RBRACE);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[43] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeForm");
    }
  }

/** <em>AttributeOptions$WithEOF</em> ::= <em>AttributeOptions</em> EOF . */
  final public net.sf.crsx.Sink N_AttributeOptions$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeOptions$WithEOF");
    try {
      sink = N_AttributeOptions(sink, env);
      jj_consume_token(0);
                                            {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeOptions$WithEOF");
    }
  }

/**
 * <em>AttributeOptions</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_AttributeOption">&lang;AttributeOption&rang;</a>    <a href="#N_AttributeOptions">&lang;AttributeOptions&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_AttributeOptions(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeOptions");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_AttributeOptions:
        t = jj_consume_token(MT_AttributeOptions);
                                 sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_13:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[45] = jj_gen;
              break label_13;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[46] = jj_gen;
          ;
        }
                                                                                                                                                                              {if (true) return sink.endMetaApplication();}
        break;
      case IT_AttributeOptions:
        jj_consume_token(IT_AttributeOptions);
                                sink=N_Embedded(sink, env);
                                                               {if (true) return sink;}
        break;
      case MT_AttributeOption:
      case IT_AttributeOption:
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_AttributeOption(sink, env);
        sink = N_AttributeOptions(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[47] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeOptions");
    }
  }

/** <em>AttributeOption$WithEOF</em> ::= <em>AttributeOption</em> EOF . */
  final public net.sf.crsx.Sink N_AttributeOption$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeOption$WithEOF");
    try {
      sink = N_AttributeOption(sink, env);
      jj_consume_token(0);
                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeOption$WithEOF");
    }
  }

/**
 * <em>AttributeOption</em> ::=  <font color="red">{AttributeOption}</font><font color="red">:raw</font>   <a href="#N_Variable">&lang;Variable&rang;</a>    <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
  final public net.sf.crsx.Sink N_AttributeOption(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeOption");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_AttributeOption:
        t = jj_consume_token(MT_AttributeOption);
                                sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_14:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[48] = jj_gen;
              break label_14;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[49] = jj_gen;
          ;
        }
                                                                                                                                                                             {if (true) return sink.endMetaApplication();}
        break;
      case IT_AttributeOption:
        jj_consume_token(IT_AttributeOption);
                               sink=N_Embedded(sink, env);
                                                              {if (true) return sink;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                sink = sink .start(makeTConstructor(sink, t, raw("AttributeOption"), null)) ;
        sink = N_Variable(sink, env);
        sink = N_Constructor(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeOption");
    }
  }

/** <em>SortNames$WithEOF</em> ::= <em>SortNames</em> EOF . */
  final public net.sf.crsx.Sink N_SortNames$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortNames$WithEOF");
    try {
      sink = N_SortNames(sink, env);
      jj_consume_token(0);
                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortNames$WithEOF");
    }
  }

/**
 * <em>SortNames</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SortName">&lang;SortName&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_SortNames">&lang;SortNames&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_SortNames(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortNames");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SortNames:
        t = jj_consume_token(MT_SortNames);
                          sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_15:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[51] = jj_gen;
              break label_15;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[52] = jj_gen;
          ;
        }
                                                                                                                                                                       {if (true) return sink.endMetaApplication();}
        break;
      case IT_SortNames:
        jj_consume_token(IT_SortNames);
                         sink=N_Embedded(sink, env);
                                                        {if (true) return sink;}
        break;
      case MT_SortName:
      case IT_SortName:
      case MT_Constructor:
      case IT_Constructor:
      case T_DASH:
      case T_UPPER:
      case T_CON:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_SortName(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_COMMA:
          jj_consume_token(T_COMMA);
          sink = N_SortNames(sink, env);
          break;
        default:
          jj_la1[53] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortNames");
    }
  }

/** <em>SortAbstraction$WithEOF</em> ::= <em>SortAbstraction</em> EOF . */
  final public net.sf.crsx.Sink N_SortAbstraction$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortAbstraction$WithEOF");
    try {
      sink = N_SortAbstraction(sink, env);
      jj_consume_token(0);
                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortAbstraction$WithEOF");
    }
  }

/**
 * <em>SortAbstraction</em> ::=  <font color="red">{SortAbstractionParam}</font><font color="red">:raw</font>   <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">^a</font>   <a href="#N_SortAbstraction">&lang;SortAbstraction&rang;</a> <font color="red">[a]</font>  <br>
 *  |  <font color="red">{SortAbstractionBody}</font><font color="red">:raw</font>   <a href="#N_SortAlternatives">&lang;SortAlternatives&rang;</a>  
 */
  final public net.sf.crsx.Sink N_SortAbstraction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortAbstraction");
    try {
        String s_a = null;
        Token t = null;
        net.sf.crsx.Variable v_a = null;
        String c0 = null;
        net.sf.crsx.util.Buffer b_a = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs_a = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SortAbstraction:
        t = jj_consume_token(MT_SortAbstraction);
                                sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_16:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[55] = jj_gen;
              break label_16;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[56] = jj_gen;
          ;
        }
                                                                                                                                                                             {if (true) return sink.endMetaApplication();}
        break;
      case IT_SortAbstraction:
        jj_consume_token(IT_SortAbstraction);
                               sink=N_Embedded(sink, env);
                                                              {if (true) return sink;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                sink = sink .start(makeTConstructor(sink, t, raw("SortAbstractionParam"), null)) ;
                bs_a = b_a.sink();
        N_Variable(bs_a, env);
                if (b_a.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_a.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_a.term(false)+")");}
                c0 = b_a.term(true).constructor().symbol();
                s_a = c0;
                v_a = sink.makeVariable(s_a,true);
                {
                        net.sf.crsx.Variable[] bs1 = {v_a};
                        sink = sink .binds(bs1) ;
                }
        sink = N_SortAbstraction(sink, env.extend(s_a, v_a));
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[57] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, raw("SortAbstractionBody"), null)) ;
        sink = N_SortAlternatives(sink, env);
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortAbstraction");
    }
  }

/** <em>SortAlternatives$WithEOF</em> ::= <em>SortAlternatives</em> EOF . */
  final public net.sf.crsx.Sink N_SortAlternatives$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortAlternatives$WithEOF");
    try {
      sink = N_SortAlternatives(sink, env);
      jj_consume_token(0);
                                            {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortAlternatives$WithEOF");
    }
  }

/**
 * <em>SortAlternatives</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SortAlternative">&lang;SortAlternative&rang;</a>    <a href="#N_SortAlternatives">&lang;SortAlternatives&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_SortAlternatives(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortAlternatives");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SortAlternatives:
        t = jj_consume_token(MT_SortAlternatives);
                                 sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_17:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[58] = jj_gen;
              break label_17;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[59] = jj_gen;
          ;
        }
                                                                                                                                                                              {if (true) return sink.endMetaApplication();}
        break;
      case IT_SortAlternatives:
        jj_consume_token(IT_SortAlternatives);
                                sink=N_Embedded(sink, env);
                                                               {if (true) return sink;}
        break;
      case MT_SortAlternative:
      case IT_SortAlternative:
      case T_BAR:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_SortAlternative(sink, env);
        sink = N_SortAlternatives(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[60] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortAlternatives");
    }
  }

/** <em>SortAlternative$WithEOF</em> ::= <em>SortAlternative</em> EOF . */
  final public net.sf.crsx.Sink N_SortAlternative$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortAlternative$WithEOF");
    try {
      sink = N_SortAlternative(sink, env);
      jj_consume_token(0);
                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortAlternative$WithEOF");
    }
  }

/**
 * <em>SortAlternative</em> ::=   <a href="#T_BAR">BAR</a>   (   <a href="#T_SCHEME">SCHEME</a><font color="red">:raw</font>   <a href="#N_Form">&lang;Form&rang;</a>   |  <font color="red">{SynthesizedRef}</font><font color="red">:raw</font>    <a href="#T_UP">UP</a>   <a href="#N_AttributeName">&lang;AttributeName&rang;</a>   |   <a href="#T_SUGAR">SUGAR</a><font color="red">:raw</font>   <a href="#N_Form">&lang;Form&rang;</a>     <a href="#T_ARROW">ARROW</a>   <a href="#N_Term">&lang;Term&rang;</a>   |   <a href="#T_SYMBOL">SYMBOL</a><font color="red">:raw</font>   <a href="#N_Form">&lang;Form&rang;</a>   |   <a href="#T_STATIC">STATIC</a><font color="red">:raw</font>   (   <a href="#T_SYMBOL">SYMBOL</a>  )?   <a href="#N_Form">&lang;Form&rang;</a>   |  <font color="red">{data}</font><font color="red">:raw</font>   (   <a href="#T_DATA">DATA</a>  )?   <a href="#N_Form">&lang;Form&rang;</a>    <a href="#N_Tagging">&lang;Tagging&rang;</a>   ) 
 */
  final public net.sf.crsx.Sink N_SortAlternative(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortAlternative");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SortAlternative:
        t = jj_consume_token(MT_SortAlternative);
                                sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_18:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[61] = jj_gen;
              break label_18;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[62] = jj_gen;
          ;
        }
                                                                                                                                                                             {if (true) return sink.endMetaApplication();}
        break;
      case IT_SortAlternative:
        jj_consume_token(IT_SortAlternative);
                               sink=N_Embedded(sink, env);
                                                              {if (true) return sink;}
        break;
      case T_BAR:
        jj_consume_token(T_BAR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_SCHEME:
          t = jj_consume_token(T_SCHEME);
                        sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
          sink = N_Form(sink, env);
                        sink = sink .end() ;
          break;
        case T_UP:
                        sink = sink .start(makeTConstructor(sink, t, raw("SynthesizedRef"), null)) ;
          jj_consume_token(T_UP);
          sink = N_AttributeName(sink, env);
                        sink = sink .end() ;
          break;
        case T_SUGAR:
          t = jj_consume_token(T_SUGAR);
                        sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
          sink = N_Form(sink, env);
          jj_consume_token(T_ARROW);
          sink = N_Term(sink, env);
                        sink = sink .end() ;
          break;
        case T_SYMBOL:
          t = jj_consume_token(T_SYMBOL);
                        sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
          sink = N_Form(sink, env);
                        sink = sink .end() ;
          break;
        case T_STATIC:
          t = jj_consume_token(T_STATIC);
                        sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_SYMBOL:
            jj_consume_token(T_SYMBOL);
            break;
          default:
            jj_la1[63] = jj_gen;
            ;
          }
          sink = N_Form(sink, env);
                        sink = sink .end() ;
          break;
        case MT_Form:
        case IT_Form:
        case MT_Constructor:
        case IT_Constructor:
        case T_CONCRETESTART:
        case T_DASH:
        case T_UPPER:
        case T_DATA:
        case T_CON:
                        sink = sink .start(makeTConstructor(sink, t, raw("data"), null)) ;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_DATA:
            jj_consume_token(T_DATA);
            break;
          default:
            jj_la1[64] = jj_gen;
            ;
          }
          sink = N_Form(sink, env);
          sink = N_Tagging(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[65] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[66] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortAlternative");
    }
  }

/** <em>Form$WithEOF</em> ::= <em>Form</em> EOF . */
  final public net.sf.crsx.Sink N_Form$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Form$WithEOF");
    try {
      sink = N_Form(sink, env);
      jj_consume_token(0);
                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Form$WithEOF");
    }
  }

/**
 * <em>Form</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a> <font color="red">:#C</font>   (  <font color="red">{FormParsedSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_FormPrec">&lang;FormPrec&rang;</a>    <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>   |  <font color="red">{FormConstruction}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_ScopeSorts">&lang;ScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>   )  <br>
 *  |  <font color="red">{FormParsedUnsorted}</font><font color="red">:raw</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_FormPrec">&lang;FormPrec&rang;</a>    <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Form(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Form");
    try {
        net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.Sink bs__C = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Form:
        t = jj_consume_token(MT_Form);
                     sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_19:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[67] = jj_gen;
              break label_19;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[68] = jj_gen;
          ;
        }
                                                                                                                                                                  {if (true) return sink.endMetaApplication();}
        break;
      case IT_Form:
        jj_consume_token(IT_Form);
                    sink=N_Embedded(sink, env);
                                                   {if (true) return sink;}
        break;
      case MT_Constructor:
      case IT_Constructor:
      case T_DASH:
      case T_UPPER:
      case T_CON:
                bs__C = b__C.sink();
        N_Constructor(bs__C, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_CONCRETESTART:
                        sink = sink .start(makeTConstructor(sink, t, raw("FormParsedSorted"), null)) ;
                        sink = sink .copy(b__C, true) ;
          jj_consume_token(T_CONCRETESTART);
          sink = N_ParsedForm(sink, env);
          jj_consume_token(T_CONCRETEEND);
          sink = N_FormPrec(sink, env);
          sink = N_InheritedRefs(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[71] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, raw("FormConstruction"), null)) ;
                        sink = sink .copy(b__C, true) ;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_LPAREN:
            jj_consume_token(T_LPAREN);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_ScopeSorts:
            case IT_ScopeSorts:
            case MT_ScopeSort:
            case IT_ScopeSort:
            case MT_Sort:
            case IT_Sort:
            case MT_SimpleSort:
            case IT_SimpleSort:
            case MT_SortParam:
            case IT_SortParam:
            case MT_SortName:
            case IT_SortName:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case T_LPAREN:
            case T_LBRACKET:
            case T_DASH:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_VAR:
            case T_CON:
              sink = N_ScopeSorts(sink, env);
              break;
            default:
              jj_la1[69] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RPAREN);
            break;
          default:
            jj_la1[70] = jj_gen;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
          }
          sink = N_InheritedRefs(sink, env);
                        sink = sink .end() ;
        }
         {if (true) return sink;}
        break;
      case T_CONCRETESTART:
                sink = sink .start(makeTConstructor(sink, t, raw("FormParsedUnsorted"), null)) ;
        jj_consume_token(T_CONCRETESTART);
        sink = N_ParsedForm(sink, env);
        jj_consume_token(T_CONCRETEEND);
        sink = N_FormPrec(sink, env);
        sink = N_InheritedRefs(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Form");
    }
  }

/** <em>ScopeSorts$WithEOF</em> ::= <em>ScopeSorts</em> EOF . */
  final public net.sf.crsx.Sink N_ScopeSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ScopeSorts$WithEOF");
    try {
      sink = N_ScopeSorts(sink, env);
      jj_consume_token(0);
                                      {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ScopeSorts$WithEOF");
    }
  }

/**
 * <em>ScopeSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_ScopeSort">&lang;ScopeSort&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_ScopeSorts">&lang;ScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_ScopeSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ScopeSorts");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_ScopeSorts:
        t = jj_consume_token(MT_ScopeSorts);
                           sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_20:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[73] = jj_gen;
              break label_20;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[74] = jj_gen;
          ;
        }
                                                                                                                                                                        {if (true) return sink.endMetaApplication();}
        break;
      case IT_ScopeSorts:
        jj_consume_token(IT_ScopeSorts);
                          sink=N_Embedded(sink, env);
                                                         {if (true) return sink;}
        break;
      case MT_ScopeSort:
      case IT_ScopeSort:
      case MT_Sort:
      case IT_Sort:
      case MT_SimpleSort:
      case IT_SimpleSort:
      case MT_SortParam:
      case IT_SortParam:
      case MT_SortName:
      case IT_SortName:
      case MT_Constructor:
      case IT_Constructor:
      case MT_Variable:
      case IT_Variable:
      case T_LPAREN:
      case T_LBRACKET:
      case T_DASH:
      case T_LOWER:
      case T_UPPER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
      case T_CON:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_ScopeSort(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_COMMA:
          jj_consume_token(T_COMMA);
          sink = N_ScopeSorts(sink, env);
          break;
        default:
          jj_la1[75] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[76] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ScopeSorts");
    }
  }

/** <em>ScopeSort$WithEOF</em> ::= <em>ScopeSort</em> EOF . */
  final public net.sf.crsx.Sink N_ScopeSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ScopeSort$WithEOF");
    try {
      sink = N_ScopeSort(sink, env);
      jj_consume_token(0);
                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ScopeSort$WithEOF");
    }
  }

/**
 * <em>ScopeSort</em> ::=  <font color="red">{ScopeSort}</font><font color="red">:raw</font>   <a href="#N_Sort">&lang;Sort&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_SubstituteSorts">&lang;SubstituteSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )  <br>
 *  |  <font color="red">{ScopeSortBinder}</font><font color="red">:raw</font>    <a href="#T_LBRACKET">LBRACKET</a>   <a href="#N_Variable">&lang;Variable&rang;</a>     <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RBRACKET">RBRACKET</a> 
 */
  final public net.sf.crsx.Sink N_ScopeSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ScopeSort");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_ScopeSort:
        t = jj_consume_token(MT_ScopeSort);
                          sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_21:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[77] = jj_gen;
              break label_21;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[78] = jj_gen;
          ;
        }
                                                                                                                                                                       {if (true) return sink.endMetaApplication();}
        break;
      case IT_ScopeSort:
        jj_consume_token(IT_ScopeSort);
                         sink=N_Embedded(sink, env);
                                                        {if (true) return sink;}
        break;
      case MT_Sort:
      case IT_Sort:
      case MT_SimpleSort:
      case IT_SimpleSort:
      case MT_SortParam:
      case IT_SortParam:
      case MT_SortName:
      case IT_SortName:
      case MT_Constructor:
      case IT_Constructor:
      case MT_Variable:
      case IT_Variable:
      case T_LPAREN:
      case T_DASH:
      case T_LOWER:
      case T_UPPER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
      case T_CON:
                sink = sink .start(makeTConstructor(sink, t, raw("ScopeSort"), null)) ;
        sink = N_Sort(sink, env);
        sink = N_Repeat(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_LBRACKET:
          jj_consume_token(T_LBRACKET);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MT_SubstituteSorts:
          case IT_SubstituteSorts:
          case MT_SubstituteSort:
          case IT_SubstituteSort:
          case MT_Variable:
          case IT_Variable:
          case T_LOWER:
          case T_MODULE:
          case T_SORT:
          case T_DATA:
          case T_SCHEME:
          case T_AUTOMATIC:
          case T_SYMBOL:
          case T_STATIC:
          case T_ATTRIBUTE:
          case T_COMPOSE:
          case T_SUGAR:
          case T_RULE:
          case T_PRIORITY:
          case T_DEFAULT:
          case T_IMPORT:
          case T_TAG:
          case T_SPACE:
          case T_TOKEN:
          case T_FRAGMENT:
          case T_NESTED:
          case T_VAR:
            sink = N_SubstituteSorts(sink, env);
            break;
          default:
            jj_la1[79] = jj_gen;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
          }
          jj_consume_token(T_RBRACKET);
          break;
        default:
          jj_la1[80] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
                {if (true) return sink .end() ;}
        break;
      case T_LBRACKET:
                sink = sink .start(makeTConstructor(sink, t, raw("ScopeSortBinder"), null)) ;
        jj_consume_token(T_LBRACKET);
        sink = N_Variable(sink, env);
        jj_consume_token(T_COLON);
        sink = N_Sort(sink, env);
        jj_consume_token(T_RBRACKET);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[81] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ScopeSort");
    }
  }

/** <em>SubstituteSorts$WithEOF</em> ::= <em>SubstituteSorts</em> EOF . */
  final public net.sf.crsx.Sink N_SubstituteSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SubstituteSorts$WithEOF");
    try {
      sink = N_SubstituteSorts(sink, env);
      jj_consume_token(0);
                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SubstituteSorts$WithEOF");
    }
  }

/**
 * <em>SubstituteSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SubstituteSort">&lang;SubstituteSort&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_SubstituteSorts">&lang;SubstituteSorts&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_SubstituteSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SubstituteSorts");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SubstituteSorts:
        t = jj_consume_token(MT_SubstituteSorts);
                                sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_22:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[82] = jj_gen;
              break label_22;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[83] = jj_gen;
          ;
        }
                                                                                                                                                                             {if (true) return sink.endMetaApplication();}
        break;
      case IT_SubstituteSorts:
        jj_consume_token(IT_SubstituteSorts);
                               sink=N_Embedded(sink, env);
                                                              {if (true) return sink;}
        break;
      case MT_SubstituteSort:
      case IT_SubstituteSort:
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_SubstituteSort(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_COMMA:
          jj_consume_token(T_COMMA);
          sink = N_SubstituteSorts(sink, env);
          break;
        default:
          jj_la1[84] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SubstituteSorts");
    }
  }

/** <em>SubstituteSort$WithEOF</em> ::= <em>SubstituteSort</em> EOF . */
  final public net.sf.crsx.Sink N_SubstituteSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SubstituteSort$WithEOF");
    try {
      sink = N_SubstituteSort(sink, env);
      jj_consume_token(0);
                                          {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SubstituteSort$WithEOF");
    }
  }

/**
 * <em>SubstituteSort</em> ::=  <font color="red">{SubstituteSort}</font><font color="red">:raw</font>   <a href="#N_Variable">&lang;Variable&rang;</a>     <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>  
 */
  final public net.sf.crsx.Sink N_SubstituteSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SubstituteSort");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SubstituteSort:
        t = jj_consume_token(MT_SubstituteSort);
                               sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_23:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[86] = jj_gen;
              break label_23;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[87] = jj_gen;
          ;
        }
                                                                                                                                                                            {if (true) return sink.endMetaApplication();}
        break;
      case IT_SubstituteSort:
        jj_consume_token(IT_SubstituteSort);
                              sink=N_Embedded(sink, env);
                                                             {if (true) return sink;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                sink = sink .start(makeTConstructor(sink, t, raw("SubstituteSort"), null)) ;
        sink = N_Variable(sink, env);
        jj_consume_token(T_COLON);
        sink = N_Sort(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SubstituteSort");
    }
  }

/** <em>Sort$WithEOF</em> ::= <em>Sort</em> EOF . */
  final public net.sf.crsx.Sink N_Sort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Sort$WithEOF");
    try {
      sink = N_Sort(sink, env);
      jj_consume_token(0);
                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Sort$WithEOF");
    }
  }

/**
 * <em>Sort</em> ::=  <font color="red">{Sort}</font><font color="red">:raw</font>   <a href="#N_SimpleSort">&lang;SimpleSort&rang;</a>    <a href="#N_SimpleSorts">&lang;SimpleSorts&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Sort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Sort");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Sort:
        t = jj_consume_token(MT_Sort);
                     sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_24:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[89] = jj_gen;
              break label_24;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[90] = jj_gen;
          ;
        }
                                                                                                                                                                  {if (true) return sink.endMetaApplication();}
        break;
      case IT_Sort:
        jj_consume_token(IT_Sort);
                    sink=N_Embedded(sink, env);
                                                   {if (true) return sink;}
        break;
      case MT_SimpleSort:
      case IT_SimpleSort:
      case MT_SortParam:
      case IT_SortParam:
      case MT_SortName:
      case IT_SortName:
      case MT_Constructor:
      case IT_Constructor:
      case MT_Variable:
      case IT_Variable:
      case T_LPAREN:
      case T_DASH:
      case T_LOWER:
      case T_UPPER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
      case T_CON:
                sink = sink .start(makeTConstructor(sink, t, raw("Sort"), null)) ;
        sink = N_SimpleSort(sink, env);
        sink = N_SimpleSorts(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[91] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Sort");
    }
  }

/** <em>SimpleSorts$WithEOF</em> ::= <em>SimpleSorts</em> EOF . */
  final public net.sf.crsx.Sink N_SimpleSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SimpleSorts$WithEOF");
    try {
      sink = N_SimpleSorts(sink, env);
      jj_consume_token(0);
                                       {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SimpleSorts$WithEOF");
    }
  }

/**
 * <em>SimpleSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SimpleSort">&lang;SimpleSort&rang;</a>    <a href="#N_SimpleSorts">&lang;SimpleSorts&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_SimpleSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SimpleSorts");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SimpleSorts:
        t = jj_consume_token(MT_SimpleSorts);
                            sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_25:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[92] = jj_gen;
              break label_25;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[93] = jj_gen;
          ;
        }
                                                                                                                                                                         {if (true) return sink.endMetaApplication();}
        break;
      case IT_SimpleSorts:
        jj_consume_token(IT_SimpleSorts);
                           sink=N_Embedded(sink, env);
                                                          {if (true) return sink;}
        break;
      case MT_SimpleSort:
      case IT_SimpleSort:
      case MT_SortParam:
      case IT_SortParam:
      case MT_SortName:
      case IT_SortName:
      case MT_Constructor:
      case IT_Constructor:
      case MT_Variable:
      case IT_Variable:
      case T_LPAREN:
      case T_DASH:
      case T_LOWER:
      case T_UPPER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
      case T_CON:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_SimpleSort(sink, env);
        sink = N_SimpleSorts(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[94] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SimpleSorts");
    }
  }

/** <em>SimpleSort$WithEOF</em> ::= <em>SimpleSort</em> EOF . */
  final public net.sf.crsx.Sink N_SimpleSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SimpleSort$WithEOF");
    try {
      sink = N_SimpleSort(sink, env);
      jj_consume_token(0);
                                      {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SimpleSort$WithEOF");
    }
  }

/**
 * <em>SimpleSort</em> ::=  <font color="red">{SortName}</font><font color="red">:raw</font>   <a href="#N_SortName">&lang;SortName&rang;</a>    <a href="#N_MetaVariables">&lang;MetaVariables&rang;</a>   <br>
 *  |  <font color="red">{SortParam}</font><font color="red">:raw</font>   <a href="#N_SortParam">&lang;SortParam&rang;</a>   <br>
 *  |   <a href="#T_LPAREN">LPAREN</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RPAREN">RPAREN</a> 
 */
  final public net.sf.crsx.Sink N_SimpleSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SimpleSort");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SimpleSort:
        t = jj_consume_token(MT_SimpleSort);
                           sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_26:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[95] = jj_gen;
              break label_26;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[96] = jj_gen;
          ;
        }
                                                                                                                                                                        {if (true) return sink.endMetaApplication();}
        break;
      case IT_SimpleSort:
        jj_consume_token(IT_SimpleSort);
                          sink=N_Embedded(sink, env);
                                                         {if (true) return sink;}
        break;
      case MT_SortName:
      case IT_SortName:
      case MT_Constructor:
      case IT_Constructor:
      case T_DASH:
      case T_UPPER:
      case T_CON:
                sink = sink .start(makeTConstructor(sink, t, raw("SortName"), null)) ;
        sink = N_SortName(sink, env);
        sink = N_MetaVariables(sink, env);
                {if (true) return sink .end() ;}
        break;
      case MT_SortParam:
      case IT_SortParam:
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                sink = sink .start(makeTConstructor(sink, t, raw("SortParam"), null)) ;
        sink = N_SortParam(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_LPAREN:
        jj_consume_token(T_LPAREN);
        sink = N_Sort(sink, env);
        jj_consume_token(T_RPAREN);
         {if (true) return sink;}
        break;
      default:
        jj_la1[97] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SimpleSort");
    }
  }

/** <em>MetaVariables$WithEOF</em> ::= <em>MetaVariables</em> EOF . */
  final public net.sf.crsx.Sink N_MetaVariables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_MetaVariables$WithEOF");
    try {
      sink = N_MetaVariables(sink, env);
      jj_consume_token(0);
                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_MetaVariables$WithEOF");
    }
  }

/**
 * <em>MetaVariables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_MetaVariable">&lang;MetaVariable&rang;</a>    <font color="red">{$Nil}</font>  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_MetaVariables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_MetaVariables");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_MetaVariables:
        t = jj_consume_token(MT_MetaVariables);
                              sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_27:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[98] = jj_gen;
              break label_27;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[99] = jj_gen;
          ;
        }
                                                                                                                                                                           {if (true) return sink.endMetaApplication();}
        break;
      case IT_MetaVariables:
        jj_consume_token(IT_MetaVariables);
                             sink=N_Embedded(sink, env);
                                                            {if (true) return sink;}
        break;
      case MT_MetaVariable:
      case IT_MetaVariable:
      case T_HASH:
      case T_META:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_MetaVariable(sink, env);
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end().end() ;}
        break;
      default:
        jj_la1[100] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_MetaVariables");
    }
  }

/** <em>SortParam$WithEOF</em> ::= <em>SortParam</em> EOF . */
  final public net.sf.crsx.Sink N_SortParam$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortParam$WithEOF");
    try {
      sink = N_SortParam(sink, env);
      jj_consume_token(0);
                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortParam$WithEOF");
    }
  }

/**
 * <em>SortParam</em> ::=  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!</font> 
 */
  final public net.sf.crsx.Sink N_SortParam(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortParam");
    try {
        Token t = null;
        net.sf.crsx.Variable v_Variable = null;
        String s_Variable = null;
        net.sf.crsx.Sink bs_Variable = null;
        String c0 = null;
        net.sf.crsx.util.Buffer b_Variable = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SortParam:
        t = jj_consume_token(MT_SortParam);
                          sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_28:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[101] = jj_gen;
              break label_28;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[102] = jj_gen;
          ;
        }
                                                                                                                                                                       {if (true) return sink.endMetaApplication();}
        break;
      case IT_SortParam:
        jj_consume_token(IT_SortParam);
                         sink=N_Embedded(sink, env);
                                                        {if (true) return sink;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                bs_Variable = b_Variable.sink();
        N_Variable(bs_Variable, env);
                if (b_Variable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_Variable.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_Variable.term(false)+")");}
                c0 = b_Variable.term(true).constructor().symbol();
                s_Variable = c0;
                v_Variable = env.get(s_Variable);
                if (v_Variable == null) {if (true) throw new ParseException("Variable "+s_Variable+" cannot be resolved?");}
                sink = sink .use(v_Variable) ;
         {if (true) return sink;}
        break;
      default:
        jj_la1[103] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortParam");
    }
  }

/** <em>ParsedForm$WithEOF</em> ::= <em>ParsedForm</em> EOF . */
  final public net.sf.crsx.Sink N_ParsedForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ParsedForm$WithEOF");
    try {
      sink = N_ParsedForm(sink, env);
      jj_consume_token(0);
                                      {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ParsedForm$WithEOF");
    }
  }

/**
 * <em>ParsedForm</em> ::=  <font color="red">{ParsedFormSpace}</font><font color="red">:raw</font>   <a href="#N_ConcreteSpace">&lang;ConcreteSpace&rang;</a>    <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormWord}</font><font color="red">:raw</font>   <a href="#N_ConcreteWord">&lang;ConcreteWord&rang;</a>    <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>   <br>
 *  |   <a href="#T_CONCRETEPUSH">CONCRETEPUSH</a>   <font color="red">{ParsedFormTerm}</font><font color="red">:raw</font>   <a href="#N_ScopeSort">&lang;ScopeSort&rang;</a>    <a href="#N_FormPrec">&lang;FormPrec&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>     <a href="#T_CONCRETEPOP">CONCRETEPOP</a>   <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormDone}</font><font color="red">:raw</font> 
 */
  final public net.sf.crsx.Sink N_ParsedForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ParsedForm");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_ParsedForm:
        t = jj_consume_token(MT_ParsedForm);
                           sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_29:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[104] = jj_gen;
              break label_29;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[105] = jj_gen;
          ;
        }
                                                                                                                                                                        {if (true) return sink.endMetaApplication();}
        break;
      case IT_ParsedForm:
        jj_consume_token(IT_ParsedForm);
                          sink=N_Embedded(sink, env);
                                                         {if (true) return sink;}
        break;
      case MT_ConcreteSpace:
      case IT_ConcreteSpace:
      case T_CONCRETESPACE:
                sink = sink .start(makeTConstructor(sink, t, raw("ParsedFormSpace"), null)) ;
        sink = N_ConcreteSpace(sink, env);
        sink = N_ParsedForm(sink, env);
                {if (true) return sink .end() ;}
        break;
      case MT_ConcreteWord:
      case IT_ConcreteWord:
      case T_CONCRETEWORD:
                sink = sink .start(makeTConstructor(sink, t, raw("ParsedFormWord"), null)) ;
        sink = N_ConcreteWord(sink, env);
        sink = N_ParsedForm(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_CONCRETEPUSH:
        jj_consume_token(T_CONCRETEPUSH);
                sink = sink .start(makeTConstructor(sink, t, raw("ParsedFormTerm"), null)) ;
        sink = N_ScopeSort(sink, env);
        sink = N_FormPrec(sink, env);
        sink = N_Repeat(sink, env);
        jj_consume_token(T_CONCRETEPOP);
        sink = N_ParsedForm(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[106] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, raw("ParsedFormDone"), null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ParsedForm");
    }
  }

/** <em>FormPrec$WithEOF</em> ::= <em>FormPrec</em> EOF . */
  final public net.sf.crsx.Sink N_FormPrec$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_FormPrec$WithEOF");
    try {
      sink = N_FormPrec(sink, env);
      jj_consume_token(0);
                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_FormPrec$WithEOF");
    }
  }

/**
 * <em>FormPrec</em> ::=  (   <a href="#T_AT">AT</a>   <a href="#N_Natural">&lang;Natural&rang;</a>   |  <font color="red">{"0"}</font>  ) 
 */
  final public net.sf.crsx.Sink N_FormPrec(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_FormPrec");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_FormPrec:
        t = jj_consume_token(MT_FormPrec);
                         sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_30:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[107] = jj_gen;
              break label_30;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[108] = jj_gen;
          ;
        }
                                                                                                                                                                      {if (true) return sink.endMetaApplication();}
        break;
      case IT_FormPrec:
        jj_consume_token(IT_FormPrec);
                        sink=N_Embedded(sink, env);
                                                       {if (true) return sink;}
        break;
      default:
        jj_la1[110] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_AT:
          jj_consume_token(T_AT);
          sink = N_Natural(sink, env);
          break;
        default:
          jj_la1[109] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "0", null)) ;
                        sink = sink .end() ;
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_FormPrec");
    }
  }

/** <em>Tagging$WithEOF</em> ::= <em>Tagging</em> EOF . */
  final public net.sf.crsx.Sink N_Tagging$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Tagging$WithEOF");
    try {
      sink = N_Tagging(sink, env);
      jj_consume_token(0);
                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Tagging$WithEOF");
    }
  }

/**
 * <em>Tagging</em> ::=  (  <font color="red">{$Cons}</font>    <a href="#T_TAG">TAG</a>   <a href="#N_Constructor">&lang;Constructor&rang;</a>    (  <font color="red">{$Nil}</font>  )  |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_Tagging(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Tagging");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Tagging:
        t = jj_consume_token(MT_Tagging);
                        sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_31:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[111] = jj_gen;
              break label_31;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[112] = jj_gen;
          ;
        }
                                                                                                                                                                     {if (true) return sink.endMetaApplication();}
        break;
      case IT_Tagging:
        jj_consume_token(IT_Tagging);
                       sink=N_Embedded(sink, env);
                                                      {if (true) return sink;}
        break;
      default:
        jj_la1[114] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_TAG:
                        sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
          jj_consume_token(T_TAG);
          sink = N_Constructor(sink, env);
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[113] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Tagging");
    }
  }

/** <em>InheritedRefs$WithEOF</em> ::= <em>InheritedRefs</em> EOF . */
  final public net.sf.crsx.Sink N_InheritedRefs$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_InheritedRefs$WithEOF");
    try {
      sink = N_InheritedRefs(sink, env);
      jj_consume_token(0);
                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_InheritedRefs$WithEOF");
    }
  }

/**
 * <em>InheritedRefs</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_InheritedRef">&lang;InheritedRef&rang;</a>    <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_InheritedRefs(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_InheritedRefs");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_InheritedRefs:
        t = jj_consume_token(MT_InheritedRefs);
                              sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_32:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[115] = jj_gen;
              break label_32;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[116] = jj_gen;
          ;
        }
                                                                                                                                                                           {if (true) return sink.endMetaApplication();}
        break;
      case IT_InheritedRefs:
        jj_consume_token(IT_InheritedRefs);
                             sink=N_Embedded(sink, env);
                                                            {if (true) return sink;}
        break;
      default:
        jj_la1[118] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MT_InheritedRef:
        case IT_InheritedRef:
        case T_DOWN:
                        sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
          sink = N_InheritedRef(sink, env);
          sink = N_InheritedRefs(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[117] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_InheritedRefs");
    }
  }

/** <em>InheritedRef$WithEOF</em> ::= <em>InheritedRef</em> EOF . */
  final public net.sf.crsx.Sink N_InheritedRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_InheritedRef$WithEOF");
    try {
      sink = N_InheritedRef(sink, env);
      jj_consume_token(0);
                                        {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_InheritedRef$WithEOF");
    }
  }

/**
 * <em>InheritedRef</em> ::=  <font color="red">{InheritedRef}</font><font color="red">:raw</font>    <a href="#T_DOWN">DOWN</a>   <a href="#N_AttributeName">&lang;AttributeName&rang;</a>  
 */
  final public net.sf.crsx.Sink N_InheritedRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_InheritedRef");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_InheritedRef:
        t = jj_consume_token(MT_InheritedRef);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_33:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[119] = jj_gen;
              break label_33;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[120] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_InheritedRef:
        jj_consume_token(IT_InheritedRef);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case T_DOWN:
                sink = sink .start(makeTConstructor(sink, t, raw("InheritedRef"), null)) ;
        jj_consume_token(T_DOWN);
        sink = N_AttributeName(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[121] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_InheritedRef");
    }
  }

/** <em>Rule$WithEOF</em> ::= <em>Rule</em> EOF . */
  final public net.sf.crsx.Sink N_Rule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Rule$WithEOF");
    try {
      sink = N_Rule(sink, env);
      jj_consume_token(0);
                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Rule$WithEOF");
    }
  }

/**
 * <em>Rule</em> ::=  <font color="red">{Rule}</font><font color="red">:raw</font>   <a href="#N_Priority">&lang;Priority&rang;</a>    <a href="#N_Construction">&lang;Construction&rang;</a> <font color="red">:#first</font>   (   <a href="#T_COLON">COLON</a>   <font color="red">{{#first}}</font>   <a href="#N_Construction">&lang;Construction&rang;</a>   |  <font color="red">{{OMITTED}}</font>   <font color="red">{{#first}}</font>  )   (   <a href="#T_ARROW">ARROW</a>   <a href="#N_Term">&lang;Term&rang;</a>   |  <font color="red">{{OMITTED}}</font>  ) 
 */
  final public net.sf.crsx.Sink N_Rule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Rule");
    try {
        net.sf.crsx.util.Buffer b__first = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.Sink bs__first = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Rule:
        t = jj_consume_token(MT_Rule);
                     sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_34:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[122] = jj_gen;
              break label_34;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[123] = jj_gen;
          ;
        }
                                                                                                                                                                  {if (true) return sink.endMetaApplication();}
        break;
      case IT_Rule:
        jj_consume_token(IT_Rule);
                    sink=N_Embedded(sink, env);
                                                   {if (true) return sink;}
        break;
      case MT_Priority:
      case IT_Priority:
      case MT_Construction:
      case IT_Construction:
      case MT_Constructor:
      case IT_Constructor:
      case MT_Literal:
      case IT_Literal:
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case MT_String:
      case IT_String:
      case T_CONCRETESTART:
      case T_DASH:
      case T_DIGIT:
      case T_UPPER:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_CON:
      case T_NATURAL:
      case T_UNNATURAL:
      case T_STRING:
                sink = sink .start(makeTConstructor(sink, t, raw("Rule"), null)) ;
        sink = N_Priority(sink, env);
                bs__first = b__first.sink();
        N_Construction(bs__first, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_COLON:
          jj_consume_token(T_COLON);
                        sink = sink .copy(b__first, true) ;
          sink = N_Construction(sink, env);
          break;
        default:
          jj_la1[124] = jj_gen;
                        sink = sink .start(sink.makeConstructor("OMITTED")) .end() ;
                        sink = sink .copy(b__first, true) ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_ARROW:
          jj_consume_token(T_ARROW);
          sink = N_Term(sink, env);
          break;
        default:
          jj_la1[125] = jj_gen;
                        sink = sink .start(sink.makeConstructor("OMITTED")) .end() ;
        }
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[126] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Rule");
    }
  }

/** <em>Priority$WithEOF</em> ::= <em>Priority</em> EOF . */
  final public net.sf.crsx.Sink N_Priority$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Priority$WithEOF");
    try {
      sink = N_Priority(sink, env);
      jj_consume_token(0);
                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Priority$WithEOF");
    }
  }

/**
 * <em>Priority</em> ::=  (   <a href="#T_DEFAULT">DEFAULT</a><font color="red">:raw</font>  |   <a href="#T_PRIORITY">PRIORITY</a><font color="red">:raw</font>  |  <font color="red">{Normal}</font><font color="red">:raw</font>  ) 
 */
  final public net.sf.crsx.Sink N_Priority(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Priority");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Priority:
        t = jj_consume_token(MT_Priority);
                         sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_35:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[127] = jj_gen;
              break label_35;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[128] = jj_gen;
          ;
        }
                                                                                                                                                                      {if (true) return sink.endMetaApplication();}
        break;
      case IT_Priority:
        jj_consume_token(IT_Priority);
                        sink=N_Embedded(sink, env);
                                                       {if (true) return sink;}
        break;
      default:
        jj_la1[130] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_DEFAULT:
          t = jj_consume_token(T_DEFAULT);
                        sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
                        sink = sink .end() ;
          break;
        case T_PRIORITY:
          t = jj_consume_token(T_PRIORITY);
                        sink = sink .start(makeTConstructor(sink, t, raw(t.toString()), null)) ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[129] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, raw("Normal"), null)) ;
                        sink = sink .end() ;
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Priority");
    }
  }

/** <em>Term$WithEOF</em> ::= <em>Term</em> EOF . */
  final public net.sf.crsx.Sink N_Term$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Term$WithEOF");
    try {
      sink = N_Term(sink, env);
      jj_consume_token(0);
                                {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Term$WithEOF");
    }
  }

/**
 * <em>Term</em> ::=  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">:#v</font>   (  <font color="red">{Special}</font><font color="red">:raw</font>   <font color="red">{{#v}}</font>   <a href="#N_Term">&lang;Term&rang;</a>   |  <font color="red">{VariableUse}</font><font color="red">:raw</font>   <font color="red">{{#v}}</font>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   )  <br>
 *  |  <a href="#N_NotVariableTerm">&lang;NotVariableTerm&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Term(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Term");
    try {
        Token t = null;
        net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs__v = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Term:
        t = jj_consume_token(MT_Term);
                     sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_36:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[131] = jj_gen;
              break label_36;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[132] = jj_gen;
          ;
        }
                                                                                                                                                                  {if (true) return sink.endMetaApplication();}
        break;
      case IT_Term:
        jj_consume_token(IT_Term);
                    sink=N_Embedded(sink, env);
                                                   {if (true) return sink;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                bs__v = b__v.sink();
        N_Variable(bs__v, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MT_Term:
        case IT_Term:
        case MT_NotVariableTerm:
        case IT_NotVariableTerm:
        case MT_Constructor:
        case IT_Constructor:
        case MT_Variable:
        case IT_Variable:
        case MT_MetaVariable:
        case IT_MetaVariable:
        case MT_Literal:
        case IT_Literal:
        case MT_Number:
        case IT_Number:
        case MT_Natural:
        case IT_Natural:
        case MT_String:
        case IT_String:
        case T_CONCRETESTART:
        case T_HASH:
        case T_DASH:
        case T_DIGIT:
        case T_LOWER:
        case T_UPPER:
        case T_MODULE:
        case T_SORT:
        case T_DATA:
        case T_SCHEME:
        case T_AUTOMATIC:
        case T_SYMBOL:
        case T_STATIC:
        case T_ATTRIBUTE:
        case T_COMPOSE:
        case T_SUGAR:
        case T_RULE:
        case T_PRIORITY:
        case T_DEFAULT:
        case T_IMPORT:
        case T_TAG:
        case T_SPACE:
        case T_TOKEN:
        case T_FRAGMENT:
        case T_NESTED:
        case T_META:
        case T_VAR:
        case T_CON:
        case T_NATURAL:
        case T_UNNATURAL:
        case T_STRING:
                        sink = sink .start(makeTConstructor(sink, t, raw("Special"), null)) ;
                        sink = sink .copy(b__v, true) ;
          sink = N_Term(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[133] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, raw("VariableUse"), null)) ;
                        sink = sink .copy(b__v, true) ;
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
        }
         {if (true) return sink;}
        break;
      case MT_NotVariableTerm:
      case IT_NotVariableTerm:
      case MT_Constructor:
      case IT_Constructor:
      case MT_MetaVariable:
      case IT_MetaVariable:
      case MT_Literal:
      case IT_Literal:
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case MT_String:
      case IT_String:
      case T_CONCRETESTART:
      case T_HASH:
      case T_DASH:
      case T_DIGIT:
      case T_UPPER:
      case T_META:
      case T_CON:
      case T_NATURAL:
      case T_UNNATURAL:
      case T_STRING:
        sink = N_NotVariableTerm(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[134] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Term");
    }
  }

/** <em>NotVariableTerm$WithEOF</em> ::= <em>NotVariableTerm</em> EOF . */
  final public net.sf.crsx.Sink N_NotVariableTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_NotVariableTerm$WithEOF");
    try {
      sink = N_NotVariableTerm(sink, env);
      jj_consume_token(0);
                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_NotVariableTerm$WithEOF");
    }
  }

/**
 * <em>NotVariableTerm</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a> <font color="red">:#C</font>   <a href="#N_Repeat">&lang;Repeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{ParsedSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{MetaApplicationSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_MetaVariable">&lang;MetaVariable&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Terms">&lang;Terms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Constructor">&lang;Constructor&rang;</a>    (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{VariableUseSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Variable">&lang;Variable&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:raw</font>   <a href="#N_Literal">&lang;Literal&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   <br>
 *  |  <font color="red">{Parsed}</font><font color="red">:raw</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   <br>
 *  |  <font color="red">{MetaApplication}</font><font color="red">:raw</font>   <a href="#N_MetaVariable">&lang;MetaVariable&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Terms">&lang;Terms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_NotVariableTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_NotVariableTerm");
    try {
        net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.Sink bs__C = null;
        net.sf.crsx.Sink bs__R = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_NotVariableTerm:
        t = jj_consume_token(MT_NotVariableTerm);
                                sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_37:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[135] = jj_gen;
              break label_37;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[136] = jj_gen;
          ;
        }
                                                                                                                                                                             {if (true) return sink.endMetaApplication();}
        break;
      case IT_NotVariableTerm:
        jj_consume_token(IT_NotVariableTerm);
                               sink=N_Embedded(sink, env);
                                                              {if (true) return sink;}
        break;
      case MT_Constructor:
      case IT_Constructor:
      case T_DASH:
      case T_UPPER:
      case T_CON:
                bs__C = b__C.sink();
        N_Constructor(bs__C, env);
                bs__R = b__R.sink();
        N_Repeat(bs__R, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_CONCRETESTART:
                        sink = sink .start(makeTConstructor(sink, t, raw("ParsedSorted"), null)) ;
                        sink = sink .copy(b__C, true) ;
                        sink = sink .copy(b__R, true) ;
          jj_consume_token(T_CONCRETESTART);
          sink = N_Parsed(sink, env);
          jj_consume_token(T_CONCRETEEND);
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
          break;
        case MT_MetaVariable:
        case IT_MetaVariable:
        case T_HASH:
        case T_META:
                        sink = sink .start(makeTConstructor(sink, t, raw("MetaApplicationSorted"), null)) ;
                        sink = sink .copy(b__C, true) ;
                        sink = sink .copy(b__R, true) ;
          sink = N_MetaVariable(sink, env);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_LBRACKET:
            jj_consume_token(T_LBRACKET);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_Term:
            case IT_Term:
            case MT_NotVariableTerm:
            case IT_NotVariableTerm:
            case MT_Terms:
            case IT_Terms:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case MT_MetaVariable:
            case IT_MetaVariable:
            case MT_Literal:
            case IT_Literal:
            case MT_Number:
            case IT_Number:
            case MT_Natural:
            case IT_Natural:
            case MT_String:
            case IT_String:
            case T_CONCRETESTART:
            case T_HASH:
            case T_DASH:
            case T_DIGIT:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_META:
            case T_VAR:
            case T_CON:
            case T_NATURAL:
            case T_UNNATURAL:
            case T_STRING:
              sink = N_Terms(sink, env);
              break;
            default:
              jj_la1[137] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RBRACKET);
            break;
          default:
            jj_la1[138] = jj_gen;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
          }
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
          break;
        case MT_Constructor:
        case IT_Constructor:
        case T_DASH:
        case T_UPPER:
        case T_CON:
                        sink = sink .start(makeTConstructor(sink, t, raw("ConstructionSorted"), null)) ;
                        sink = sink .copy(b__C, true) ;
                        sink = sink .copy(b__R, true) ;
          sink = N_Constructor(sink, env);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_LPAREN:
            jj_consume_token(T_LPAREN);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_NotVariableTerm:
            case IT_NotVariableTerm:
            case MT_Scopes:
            case IT_Scopes:
            case MT_Scope:
            case IT_Scope:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case MT_MetaVariable:
            case IT_MetaVariable:
            case MT_Literal:
            case IT_Literal:
            case MT_Number:
            case IT_Number:
            case MT_Natural:
            case IT_Natural:
            case MT_String:
            case IT_String:
            case T_CONCRETESTART:
            case T_HASH:
            case T_LBRACKET:
            case T_DASH:
            case T_DIGIT:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_META:
            case T_VAR:
            case T_CON:
            case T_NATURAL:
            case T_UNNATURAL:
            case T_STRING:
              sink = N_Scopes(sink, env);
              break;
            default:
              jj_la1[139] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RPAREN);
            break;
          case T_LBRACKET:
            jj_consume_token(T_LBRACKET);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_NotVariableTerm:
            case IT_NotVariableTerm:
            case MT_Scopes:
            case IT_Scopes:
            case MT_Scope:
            case IT_Scope:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case MT_MetaVariable:
            case IT_MetaVariable:
            case MT_Literal:
            case IT_Literal:
            case MT_Number:
            case IT_Number:
            case MT_Natural:
            case IT_Natural:
            case MT_String:
            case IT_String:
            case T_CONCRETESTART:
            case T_HASH:
            case T_LBRACKET:
            case T_DASH:
            case T_DIGIT:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_META:
            case T_VAR:
            case T_CON:
            case T_NATURAL:
            case T_UNNATURAL:
            case T_STRING:
              sink = N_Scopes(sink, env);
              break;
            default:
              jj_la1[140] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RBRACKET);
            break;
          default:
            jj_la1[141] = jj_gen;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
          }
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
          break;
        case MT_Variable:
        case IT_Variable:
        case T_LOWER:
        case T_MODULE:
        case T_SORT:
        case T_DATA:
        case T_SCHEME:
        case T_AUTOMATIC:
        case T_SYMBOL:
        case T_STATIC:
        case T_ATTRIBUTE:
        case T_COMPOSE:
        case T_SUGAR:
        case T_RULE:
        case T_PRIORITY:
        case T_DEFAULT:
        case T_IMPORT:
        case T_TAG:
        case T_SPACE:
        case T_TOKEN:
        case T_FRAGMENT:
        case T_NESTED:
        case T_VAR:
                        sink = sink .start(makeTConstructor(sink, t, raw("VariableUseSorted"), null)) ;
                        sink = sink .copy(b__C, true) ;
                        sink = sink .copy(b__R, true) ;
          sink = N_Variable(sink, env);
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[145] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, raw("Construction"), null)) ;
                        sink = sink .copy(b__C, true) ;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_LPAREN:
            jj_consume_token(T_LPAREN);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_NotVariableTerm:
            case IT_NotVariableTerm:
            case MT_Scopes:
            case IT_Scopes:
            case MT_Scope:
            case IT_Scope:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case MT_MetaVariable:
            case IT_MetaVariable:
            case MT_Literal:
            case IT_Literal:
            case MT_Number:
            case IT_Number:
            case MT_Natural:
            case IT_Natural:
            case MT_String:
            case IT_String:
            case T_CONCRETESTART:
            case T_HASH:
            case T_LBRACKET:
            case T_DASH:
            case T_DIGIT:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_META:
            case T_VAR:
            case T_CON:
            case T_NATURAL:
            case T_UNNATURAL:
            case T_STRING:
              sink = N_Scopes(sink, env);
              break;
            default:
              jj_la1[142] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RPAREN);
            break;
          case T_LBRACKET:
            jj_consume_token(T_LBRACKET);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_NotVariableTerm:
            case IT_NotVariableTerm:
            case MT_Scopes:
            case IT_Scopes:
            case MT_Scope:
            case IT_Scope:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case MT_MetaVariable:
            case IT_MetaVariable:
            case MT_Literal:
            case IT_Literal:
            case MT_Number:
            case IT_Number:
            case MT_Natural:
            case IT_Natural:
            case MT_String:
            case IT_String:
            case T_CONCRETESTART:
            case T_HASH:
            case T_LBRACKET:
            case T_DASH:
            case T_DIGIT:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_META:
            case T_VAR:
            case T_CON:
            case T_NATURAL:
            case T_UNNATURAL:
            case T_STRING:
              sink = N_Scopes(sink, env);
              break;
            default:
              jj_la1[143] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RBRACKET);
            break;
          default:
            jj_la1[144] = jj_gen;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
          }
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
        }
         {if (true) return sink;}
        break;
      case MT_Literal:
      case IT_Literal:
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case MT_String:
      case IT_String:
      case T_DIGIT:
      case T_NATURAL:
      case T_UNNATURAL:
      case T_STRING:
                sink = sink .start(makeTConstructor(sink, t, raw("Literal"), null)) ;
        sink = N_Literal(sink, env);
        sink = N_Attributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_CONCRETESTART:
                sink = sink .start(makeTConstructor(sink, t, raw("Parsed"), null)) ;
        jj_consume_token(T_CONCRETESTART);
        sink = N_Parsed(sink, env);
        jj_consume_token(T_CONCRETEEND);
        sink = N_Attributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case MT_MetaVariable:
      case IT_MetaVariable:
      case T_HASH:
      case T_META:
                sink = sink .start(makeTConstructor(sink, t, raw("MetaApplication"), null)) ;
        sink = N_MetaVariable(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_LBRACKET:
          jj_consume_token(T_LBRACKET);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case MT_Term:
          case IT_Term:
          case MT_NotVariableTerm:
          case IT_NotVariableTerm:
          case MT_Terms:
          case IT_Terms:
          case MT_Constructor:
          case IT_Constructor:
          case MT_Variable:
          case IT_Variable:
          case MT_MetaVariable:
          case IT_MetaVariable:
          case MT_Literal:
          case IT_Literal:
          case MT_Number:
          case IT_Number:
          case MT_Natural:
          case IT_Natural:
          case MT_String:
          case IT_String:
          case T_CONCRETESTART:
          case T_HASH:
          case T_DASH:
          case T_DIGIT:
          case T_LOWER:
          case T_UPPER:
          case T_MODULE:
          case T_SORT:
          case T_DATA:
          case T_SCHEME:
          case T_AUTOMATIC:
          case T_SYMBOL:
          case T_STATIC:
          case T_ATTRIBUTE:
          case T_COMPOSE:
          case T_SUGAR:
          case T_RULE:
          case T_PRIORITY:
          case T_DEFAULT:
          case T_IMPORT:
          case T_TAG:
          case T_SPACE:
          case T_TOKEN:
          case T_FRAGMENT:
          case T_NESTED:
          case T_META:
          case T_VAR:
          case T_CON:
          case T_NATURAL:
          case T_UNNATURAL:
          case T_STRING:
            sink = N_Terms(sink, env);
            break;
          default:
            jj_la1[146] = jj_gen;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
          }
          jj_consume_token(T_RBRACKET);
          break;
        default:
          jj_la1[147] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        sink = N_Attributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[148] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_NotVariableTerm");
    }
  }

/**
 * <em>Construction</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a> <font color="red">:#C</font>   <a href="#N_Repeat">&lang;Repeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{ParsedSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Constructor">&lang;Constructor&rang;</a>    (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:raw</font>   <font color="red">{{#C}}</font>   (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:raw</font>   <a href="#N_Literal">&lang;Literal&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   <br>
 *  |  <font color="red">{Parsed}</font><font color="red">:raw</font>    <a href="#T_CONCRETESTART">CONCRETESTART</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>     <a href="#T_CONCRETEEND">CONCRETEEND</a>   <a href="#N_Attributes">&lang;Attributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Construction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Construction");
    try {
        net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.Sink bs__C = null;
        net.sf.crsx.Sink bs__R = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Construction:
        t = jj_consume_token(MT_Construction);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_38:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[149] = jj_gen;
              break label_38;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[150] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_Construction:
        jj_consume_token(IT_Construction);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case MT_Constructor:
      case IT_Constructor:
      case T_DASH:
      case T_UPPER:
      case T_CON:
                bs__C = b__C.sink();
        N_Constructor(bs__C, env);
                bs__R = b__R.sink();
        N_Repeat(bs__R, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_CONCRETESTART:
                        sink = sink .start(makeTConstructor(sink, t, raw("ParsedSorted"), null)) ;
                        sink = sink .copy(b__C, true) ;
                        sink = sink .copy(b__R, true) ;
          jj_consume_token(T_CONCRETESTART);
          sink = N_Parsed(sink, env);
          jj_consume_token(T_CONCRETEEND);
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
          break;
        case MT_Constructor:
        case IT_Constructor:
        case T_DASH:
        case T_UPPER:
        case T_CON:
                        sink = sink .start(makeTConstructor(sink, t, raw("ConstructionSorted"), null)) ;
                        sink = sink .copy(b__C, true) ;
                        sink = sink .copy(b__R, true) ;
          sink = N_Constructor(sink, env);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_LPAREN:
            jj_consume_token(T_LPAREN);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_NotVariableTerm:
            case IT_NotVariableTerm:
            case MT_Scopes:
            case IT_Scopes:
            case MT_Scope:
            case IT_Scope:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case MT_MetaVariable:
            case IT_MetaVariable:
            case MT_Literal:
            case IT_Literal:
            case MT_Number:
            case IT_Number:
            case MT_Natural:
            case IT_Natural:
            case MT_String:
            case IT_String:
            case T_CONCRETESTART:
            case T_HASH:
            case T_LBRACKET:
            case T_DASH:
            case T_DIGIT:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_META:
            case T_VAR:
            case T_CON:
            case T_NATURAL:
            case T_UNNATURAL:
            case T_STRING:
              sink = N_Scopes(sink, env);
              break;
            default:
              jj_la1[151] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RPAREN);
            break;
          case T_LBRACKET:
            jj_consume_token(T_LBRACKET);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_NotVariableTerm:
            case IT_NotVariableTerm:
            case MT_Scopes:
            case IT_Scopes:
            case MT_Scope:
            case IT_Scope:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case MT_MetaVariable:
            case IT_MetaVariable:
            case MT_Literal:
            case IT_Literal:
            case MT_Number:
            case IT_Number:
            case MT_Natural:
            case IT_Natural:
            case MT_String:
            case IT_String:
            case T_CONCRETESTART:
            case T_HASH:
            case T_LBRACKET:
            case T_DASH:
            case T_DIGIT:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_META:
            case T_VAR:
            case T_CON:
            case T_NATURAL:
            case T_UNNATURAL:
            case T_STRING:
              sink = N_Scopes(sink, env);
              break;
            default:
              jj_la1[152] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RBRACKET);
            break;
          default:
            jj_la1[153] = jj_gen;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
          }
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[157] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, raw("Construction"), null)) ;
                        sink = sink .copy(b__C, true) ;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_LPAREN:
            jj_consume_token(T_LPAREN);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_NotVariableTerm:
            case IT_NotVariableTerm:
            case MT_Scopes:
            case IT_Scopes:
            case MT_Scope:
            case IT_Scope:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case MT_MetaVariable:
            case IT_MetaVariable:
            case MT_Literal:
            case IT_Literal:
            case MT_Number:
            case IT_Number:
            case MT_Natural:
            case IT_Natural:
            case MT_String:
            case IT_String:
            case T_CONCRETESTART:
            case T_HASH:
            case T_LBRACKET:
            case T_DASH:
            case T_DIGIT:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_META:
            case T_VAR:
            case T_CON:
            case T_NATURAL:
            case T_UNNATURAL:
            case T_STRING:
              sink = N_Scopes(sink, env);
              break;
            default:
              jj_la1[154] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RPAREN);
            break;
          case T_LBRACKET:
            jj_consume_token(T_LBRACKET);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MT_NotVariableTerm:
            case IT_NotVariableTerm:
            case MT_Scopes:
            case IT_Scopes:
            case MT_Scope:
            case IT_Scope:
            case MT_Constructor:
            case IT_Constructor:
            case MT_Variable:
            case IT_Variable:
            case MT_MetaVariable:
            case IT_MetaVariable:
            case MT_Literal:
            case IT_Literal:
            case MT_Number:
            case IT_Number:
            case MT_Natural:
            case IT_Natural:
            case MT_String:
            case IT_String:
            case T_CONCRETESTART:
            case T_HASH:
            case T_LBRACKET:
            case T_DASH:
            case T_DIGIT:
            case T_LOWER:
            case T_UPPER:
            case T_MODULE:
            case T_SORT:
            case T_DATA:
            case T_SCHEME:
            case T_AUTOMATIC:
            case T_SYMBOL:
            case T_STATIC:
            case T_ATTRIBUTE:
            case T_COMPOSE:
            case T_SUGAR:
            case T_RULE:
            case T_PRIORITY:
            case T_DEFAULT:
            case T_IMPORT:
            case T_TAG:
            case T_SPACE:
            case T_TOKEN:
            case T_FRAGMENT:
            case T_NESTED:
            case T_META:
            case T_VAR:
            case T_CON:
            case T_NATURAL:
            case T_UNNATURAL:
            case T_STRING:
              sink = N_Scopes(sink, env);
              break;
            default:
              jj_la1[155] = jj_gen;
                                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                        sink = sink .end() ;
            }
            jj_consume_token(T_RBRACKET);
            break;
          default:
            jj_la1[156] = jj_gen;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
          }
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
        }
         {if (true) return sink;}
        break;
      case MT_Literal:
      case IT_Literal:
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case MT_String:
      case IT_String:
      case T_DIGIT:
      case T_NATURAL:
      case T_UNNATURAL:
      case T_STRING:
                sink = sink .start(makeTConstructor(sink, t, raw("Literal"), null)) ;
        sink = N_Literal(sink, env);
        sink = N_Attributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_CONCRETESTART:
                sink = sink .start(makeTConstructor(sink, t, raw("Parsed"), null)) ;
        jj_consume_token(T_CONCRETESTART);
        sink = N_Parsed(sink, env);
        jj_consume_token(T_CONCRETEEND);
        sink = N_Attributes(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[158] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Construction");
    }
  }

/** <em>Scopes$WithEOF</em> ::= <em>Scopes</em> EOF . */
  final public net.sf.crsx.Sink N_Scopes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Scopes$WithEOF");
    try {
      sink = N_Scopes(sink, env);
      jj_consume_token(0);
                                  {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Scopes$WithEOF");
    }
  }

/**
 * <em>Scopes</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Scope">&lang;Scope&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_Scopes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Scopes");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Scopes:
        t = jj_consume_token(MT_Scopes);
                       sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_39:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[159] = jj_gen;
              break label_39;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[160] = jj_gen;
          ;
        }
                                                                                                                                                                    {if (true) return sink.endMetaApplication();}
        break;
      case IT_Scopes:
        jj_consume_token(IT_Scopes);
                      sink=N_Embedded(sink, env);
                                                     {if (true) return sink;}
        break;
      case MT_NotVariableTerm:
      case IT_NotVariableTerm:
      case MT_Scope:
      case IT_Scope:
      case MT_Constructor:
      case IT_Constructor:
      case MT_Variable:
      case IT_Variable:
      case MT_MetaVariable:
      case IT_MetaVariable:
      case MT_Literal:
      case IT_Literal:
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case MT_String:
      case IT_String:
      case T_CONCRETESTART:
      case T_HASH:
      case T_LBRACKET:
      case T_DASH:
      case T_DIGIT:
      case T_LOWER:
      case T_UPPER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_META:
      case T_VAR:
      case T_CON:
      case T_NATURAL:
      case T_UNNATURAL:
      case T_STRING:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_Scope(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_COMMA:
          jj_consume_token(T_COMMA);
          sink = N_Scopes(sink, env);
          break;
        default:
          jj_la1[161] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[162] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Scopes");
    }
  }

/** <em>Scope$WithEOF</em> ::= <em>Scope</em> EOF . */
  final public net.sf.crsx.Sink N_Scope$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Scope$WithEOF");
    try {
      sink = N_Scope(sink, env);
      jj_consume_token(0);
                                 {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Scope$WithEOF");
    }
  }

/**
 * <em>Scope</em> ::=  <font color="red">{Scope}</font><font color="red">:raw</font>   (  <font color="red">{$Nil}</font>  )   <a href="#N_NotVariableTerm">&lang;NotVariableTerm&rang;</a>   <br>
 *  |  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">:#v</font>   (  <font color="red">{Scope}</font><font color="red">:raw</font>   (  <font color="red">{$Cons}</font>   <font color="red">{{#v}}</font>   <a href="#N_Variables">&lang;Variables&rang;</a>   )    <a href="#T_DOT">DOT</a>   <a href="#N_Term">&lang;Term&rang;</a>   |  <font color="red">{Scope}</font><font color="red">:raw</font>   (  <font color="red">{$Nil}</font>  )   (  <font color="red">{VariableUse}</font><font color="red">:raw</font>   <font color="red">{{#v}}</font>  )  )  <br>
 *  |  <font color="red">{Scope}</font><font color="red">:raw</font>    <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_VariableList">&lang;VariableList&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>   <a href="#N_Term">&lang;Term&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Scope(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Scope");
    try {
        Token t = null;
        net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs__v = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Scope:
        t = jj_consume_token(MT_Scope);
                      sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_40:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[163] = jj_gen;
              break label_40;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[164] = jj_gen;
          ;
        }
                                                                                                                                                                   {if (true) return sink.endMetaApplication();}
        break;
      case IT_Scope:
        jj_consume_token(IT_Scope);
                     sink=N_Embedded(sink, env);
                                                    {if (true) return sink;}
        break;
      case MT_NotVariableTerm:
      case IT_NotVariableTerm:
      case MT_Constructor:
      case IT_Constructor:
      case MT_MetaVariable:
      case IT_MetaVariable:
      case MT_Literal:
      case IT_Literal:
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case MT_String:
      case IT_String:
      case T_CONCRETESTART:
      case T_HASH:
      case T_DASH:
      case T_DIGIT:
      case T_UPPER:
      case T_META:
      case T_CON:
      case T_NATURAL:
      case T_UNNATURAL:
      case T_STRING:
                sink = sink .start(makeTConstructor(sink, t, raw("Scope"), null)) ;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        sink = N_NotVariableTerm(sink, env);
                {if (true) return sink .end() ;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                bs__v = b__v.sink();
        N_Variable(bs__v, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MT_Variables:
        case IT_Variables:
        case MT_Variable:
        case IT_Variable:
        case T_DOT:
        case T_LOWER:
        case T_MODULE:
        case T_SORT:
        case T_DATA:
        case T_SCHEME:
        case T_AUTOMATIC:
        case T_SYMBOL:
        case T_STATIC:
        case T_ATTRIBUTE:
        case T_COMPOSE:
        case T_SUGAR:
        case T_RULE:
        case T_PRIORITY:
        case T_DEFAULT:
        case T_IMPORT:
        case T_TAG:
        case T_SPACE:
        case T_TOKEN:
        case T_FRAGMENT:
        case T_NESTED:
        case T_VAR:
                        sink = sink .start(makeTConstructor(sink, t, raw("Scope"), null)) ;
                                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
                                sink = sink .copy(b__v, true) ;
          sink = N_Variables(sink, env);
                                sink = sink .end() ;
          jj_consume_token(T_DOT);
          sink = N_Term(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[165] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, raw("Scope"), null)) ;
                                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                                sink = sink .end() ;
                                sink = sink .start(makeTConstructor(sink, t, raw("VariableUse"), null)) ;
                                sink = sink .copy(b__v, true) ;
                                sink = sink .end() ;
                        sink = sink .end() ;
        }
         {if (true) return sink;}
        break;
      case T_LBRACKET:
                sink = sink .start(makeTConstructor(sink, t, raw("Scope"), null)) ;
        jj_consume_token(T_LBRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MT_VariableList:
        case IT_VariableList:
        case MT_Variable:
        case IT_Variable:
        case T_LOWER:
        case T_MODULE:
        case T_SORT:
        case T_DATA:
        case T_SCHEME:
        case T_AUTOMATIC:
        case T_SYMBOL:
        case T_STATIC:
        case T_ATTRIBUTE:
        case T_COMPOSE:
        case T_SUGAR:
        case T_RULE:
        case T_PRIORITY:
        case T_DEFAULT:
        case T_IMPORT:
        case T_TAG:
        case T_SPACE:
        case T_TOKEN:
        case T_FRAGMENT:
        case T_NESTED:
        case T_VAR:
          sink = N_VariableList(sink, env);
          break;
        default:
          jj_la1[166] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
        jj_consume_token(T_RBRACKET);
        sink = N_Term(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[167] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Scope");
    }
  }

/** <em>Variables$WithEOF</em> ::= <em>Variables</em> EOF . */
  final public net.sf.crsx.Sink N_Variables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Variables$WithEOF");
    try {
      sink = N_Variables(sink, env);
      jj_consume_token(0);
                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Variables$WithEOF");
    }
  }

/**
 * <em>Variables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Variable">&lang;Variable&rang;</a>    <a href="#N_Variables">&lang;Variables&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_Variables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Variables");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Variables:
        t = jj_consume_token(MT_Variables);
                          sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_41:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[168] = jj_gen;
              break label_41;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[169] = jj_gen;
          ;
        }
                                                                                                                                                                       {if (true) return sink.endMetaApplication();}
        break;
      case IT_Variables:
        jj_consume_token(IT_Variables);
                         sink=N_Embedded(sink, env);
                                                        {if (true) return sink;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_Variable(sink, env);
        sink = N_Variables(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[170] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Variables");
    }
  }

/**
 * <em>VariableList</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Variable">&lang;Variable&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_VariableList">&lang;VariableList&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_VariableList(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_VariableList");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_VariableList:
        t = jj_consume_token(MT_VariableList);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_42:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[171] = jj_gen;
              break label_42;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[172] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_VariableList:
        jj_consume_token(IT_VariableList);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_Variable(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_COMMA:
          jj_consume_token(T_COMMA);
          sink = N_VariableList(sink, env);
          break;
        default:
          jj_la1[173] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[174] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_VariableList");
    }
  }

/** <em>Terms$WithEOF</em> ::= <em>Terms</em> EOF . */
  final public net.sf.crsx.Sink N_Terms$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Terms$WithEOF");
    try {
      sink = N_Terms(sink, env);
      jj_consume_token(0);
                                 {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Terms$WithEOF");
    }
  }

/**
 * <em>Terms</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Term">&lang;Term&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_Terms">&lang;Terms&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_Terms(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Terms");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Terms:
        t = jj_consume_token(MT_Terms);
                      sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_43:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[175] = jj_gen;
              break label_43;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[176] = jj_gen;
          ;
        }
                                                                                                                                                                   {if (true) return sink.endMetaApplication();}
        break;
      case IT_Terms:
        jj_consume_token(IT_Terms);
                     sink=N_Embedded(sink, env);
                                                    {if (true) return sink;}
        break;
      case MT_Term:
      case IT_Term:
      case MT_NotVariableTerm:
      case IT_NotVariableTerm:
      case MT_Constructor:
      case IT_Constructor:
      case MT_Variable:
      case IT_Variable:
      case MT_MetaVariable:
      case IT_MetaVariable:
      case MT_Literal:
      case IT_Literal:
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case MT_String:
      case IT_String:
      case T_CONCRETESTART:
      case T_HASH:
      case T_DASH:
      case T_DIGIT:
      case T_LOWER:
      case T_UPPER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_META:
      case T_VAR:
      case T_CON:
      case T_NATURAL:
      case T_UNNATURAL:
      case T_STRING:
                sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_Term(sink, env);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_COMMA:
          jj_consume_token(T_COMMA);
          sink = N_Terms(sink, env);
          break;
        default:
          jj_la1[177] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[178] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Terms");
    }
  }

/** <em>Parsed$WithEOF</em> ::= <em>Parsed</em> EOF . */
  final public net.sf.crsx.Sink N_Parsed$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Parsed$WithEOF");
    try {
      sink = N_Parsed(sink, env);
      jj_consume_token(0);
                                  {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Parsed$WithEOF");
    }
  }

/**
 * <em>Parsed</em> ::=   <a href="#T_CONCRETESPACE">CONCRETESPACE</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>   <br>
 *  |  <font color="red">{ParsedWord}</font><font color="red">:raw</font>   <a href="#N_ConcreteWord">&lang;ConcreteWord&rang;</a>    <a href="#N_Parsed">&lang;Parsed&rang;</a>   <br>
 *  |   <a href="#T_CONCRETEPUSH">CONCRETEPUSH</a>   <font color="red">{ParsedTerm}</font><font color="red">:raw</font>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_CONCRETEPOP">CONCRETEPOP</a>   <a href="#N_Parsed">&lang;Parsed&rang;</a>   <br>
 *  |  <font color="red">{ParsedDone}</font><font color="red">:raw</font> 
 */
  final public net.sf.crsx.Sink N_Parsed(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Parsed");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Parsed:
        t = jj_consume_token(MT_Parsed);
                       sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_44:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[179] = jj_gen;
              break label_44;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[180] = jj_gen;
          ;
        }
                                                                                                                                                                    {if (true) return sink.endMetaApplication();}
        break;
      case IT_Parsed:
        jj_consume_token(IT_Parsed);
                      sink=N_Embedded(sink, env);
                                                     {if (true) return sink;}
        break;
      case T_CONCRETESPACE:
        jj_consume_token(T_CONCRETESPACE);
        sink = N_Parsed(sink, env);
         {if (true) return sink;}
        break;
      case MT_ConcreteWord:
      case IT_ConcreteWord:
      case T_CONCRETEWORD:
                sink = sink .start(makeTConstructor(sink, t, raw("ParsedWord"), null)) ;
        sink = N_ConcreteWord(sink, env);
        sink = N_Parsed(sink, env);
                {if (true) return sink .end() ;}
        break;
      case T_CONCRETEPUSH:
        jj_consume_token(T_CONCRETEPUSH);
                sink = sink .start(makeTConstructor(sink, t, raw("ParsedTerm"), null)) ;
        sink = N_Term(sink, env);
        jj_consume_token(T_CONCRETEPOP);
        sink = N_Parsed(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[181] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, raw("ParsedDone"), null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Parsed");
    }
  }

/** <em>Attributes$WithEOF</em> ::= <em>Attributes</em> EOF . */
  final public net.sf.crsx.Sink N_Attributes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Attributes$WithEOF");
    try {
      sink = N_Attributes(sink, env);
      jj_consume_token(0);
                                      {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Attributes$WithEOF");
    }
  }

/**
 * <em>Attributes</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_Attribute">&lang;Attribute&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_Attributes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Attributes");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Attributes:
        t = jj_consume_token(MT_Attributes);
                           sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_45:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[182] = jj_gen;
              break label_45;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[183] = jj_gen;
          ;
        }
                                                                                                                                                                        {if (true) return sink.endMetaApplication();}
        break;
      case IT_Attributes:
        jj_consume_token(IT_Attributes);
                          sink=N_Embedded(sink, env);
                                                         {if (true) return sink;}
        break;
      default:
        jj_la1[185] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MT_Attribute:
        case IT_Attribute:
        case MT_AttributeKind:
        case IT_AttributeKind:
        case T_UP:
        case T_DOWN:
                        sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
          sink = N_Attribute(sink, env);
          sink = N_Attributes(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[184] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
                        sink = sink .end() ;
        }
         {if (true) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Attributes");
    }
  }

/** <em>Attribute$WithEOF</em> ::= <em>Attribute</em> EOF . */
  final public net.sf.crsx.Sink N_Attribute$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Attribute$WithEOF");
    try {
      sink = N_Attribute(sink, env);
      jj_consume_token(0);
                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Attribute$WithEOF");
    }
  }

/**
 * <em>Attribute</em> ::=  <font color="red">{Attribute}</font><font color="red">:raw</font>   <a href="#N_AttributeKind">&lang;AttributeKind&rang;</a>    <a href="#N_AttributeName">&lang;AttributeName&rang;</a>    <a href="#N_AttributeValue">&lang;AttributeValue&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Attribute(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Attribute");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Attribute:
        t = jj_consume_token(MT_Attribute);
                          sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_46:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[186] = jj_gen;
              break label_46;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[187] = jj_gen;
          ;
        }
                                                                                                                                                                       {if (true) return sink.endMetaApplication();}
        break;
      case IT_Attribute:
        jj_consume_token(IT_Attribute);
                         sink=N_Embedded(sink, env);
                                                        {if (true) return sink;}
        break;
      case MT_AttributeKind:
      case IT_AttributeKind:
      case T_UP:
      case T_DOWN:
                sink = sink .start(makeTConstructor(sink, t, raw("Attribute"), null)) ;
        sink = N_AttributeKind(sink, env);
        sink = N_AttributeName(sink, env);
        sink = N_AttributeValue(sink, env);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[188] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Attribute");
    }
  }

/** <em>AttributeKind$WithEOF</em> ::= <em>AttributeKind</em> EOF . */
  final public net.sf.crsx.Sink N_AttributeKind$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeKind$WithEOF");
    try {
      sink = N_AttributeKind(sink, env);
      jj_consume_token(0);
                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeKind$WithEOF");
    }
  }

/**
 * <em>AttributeKind</em> ::=  (  <font color="red">{AttributeKindUp}</font><font color="red">:raw</font>    <a href="#T_UP">UP</a>  |  <font color="red">{AttributeKindDown}</font><font color="red">:raw</font>    <a href="#T_DOWN">DOWN</a>  ) 
 */
  final public net.sf.crsx.Sink N_AttributeKind(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeKind");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_AttributeKind:
        t = jj_consume_token(MT_AttributeKind);
                              sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_47:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[189] = jj_gen;
              break label_47;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[190] = jj_gen;
          ;
        }
                                                                                                                                                                           {if (true) return sink.endMetaApplication();}
        break;
      case IT_AttributeKind:
        jj_consume_token(IT_AttributeKind);
                             sink=N_Embedded(sink, env);
                                                            {if (true) return sink;}
        break;
      case T_UP:
      case T_DOWN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_UP:
                        sink = sink .start(makeTConstructor(sink, t, raw("AttributeKindUp"), null)) ;
          jj_consume_token(T_UP);
                        sink = sink .end() ;
          break;
        case T_DOWN:
                        sink = sink .start(makeTConstructor(sink, t, raw("AttributeKindDown"), null)) ;
          jj_consume_token(T_DOWN);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[191] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[192] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeKind");
    }
  }

/** <em>AttributeValue$WithEOF</em> ::= <em>AttributeValue</em> EOF . */
  final public net.sf.crsx.Sink N_AttributeValue$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeValue$WithEOF");
    try {
      sink = N_AttributeValue(sink, env);
      jj_consume_token(0);
                                          {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeValue$WithEOF");
    }
  }

/**
 * <em>AttributeValue</em> ::=  <font color="red">{AttributeValue}</font><font color="red">:raw</font>    <a href="#T_LPAREN">LPAREN</a>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_RPAREN">RPAREN</a>  <br>
 *  |   <a href="#T_LBRACE">LBRACE</a>   (  <a href="#N_Term">&lang;Term&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeKeyValue}</font><font color="red">:raw</font>   <font color="red">{{#}}</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  |  <font color="red">{AttributeKey}</font><font color="red">:raw</font>   <font color="red">{{#}}</font>    <a href="#T_RBRACE">RBRACE</a>  )  |  <font color="red">{AttributeNotKey}</font><font color="red">:raw</font>    <a href="#T_NOT">NOT</a>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  ) 
 */
  final public net.sf.crsx.Sink N_AttributeValue(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeValue");
    try {
        Token t = null;
        net.sf.crsx.Sink bs__ = null;
        net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_AttributeValue:
        t = jj_consume_token(MT_AttributeValue);
                               sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_48:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[193] = jj_gen;
              break label_48;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[194] = jj_gen;
          ;
        }
                                                                                                                                                                            {if (true) return sink.endMetaApplication();}
        break;
      case IT_AttributeValue:
        jj_consume_token(IT_AttributeValue);
                              sink=N_Embedded(sink, env);
                                                             {if (true) return sink;}
        break;
      case T_LPAREN:
                sink = sink .start(makeTConstructor(sink, t, raw("AttributeValue"), null)) ;
        jj_consume_token(T_LPAREN);
        sink = N_Term(sink, env);
        jj_consume_token(T_RPAREN);
                {if (true) return sink .end() ;}
        break;
      case T_LBRACE:
        jj_consume_token(T_LBRACE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MT_Term:
        case IT_Term:
        case MT_NotVariableTerm:
        case IT_NotVariableTerm:
        case MT_Constructor:
        case IT_Constructor:
        case MT_Variable:
        case IT_Variable:
        case MT_MetaVariable:
        case IT_MetaVariable:
        case MT_Literal:
        case IT_Literal:
        case MT_Number:
        case IT_Number:
        case MT_Natural:
        case IT_Natural:
        case MT_String:
        case IT_String:
        case T_CONCRETESTART:
        case T_HASH:
        case T_DASH:
        case T_DIGIT:
        case T_LOWER:
        case T_UPPER:
        case T_MODULE:
        case T_SORT:
        case T_DATA:
        case T_SCHEME:
        case T_AUTOMATIC:
        case T_SYMBOL:
        case T_STATIC:
        case T_ATTRIBUTE:
        case T_COMPOSE:
        case T_SUGAR:
        case T_RULE:
        case T_PRIORITY:
        case T_DEFAULT:
        case T_IMPORT:
        case T_TAG:
        case T_SPACE:
        case T_TOKEN:
        case T_FRAGMENT:
        case T_NESTED:
        case T_META:
        case T_VAR:
        case T_CON:
        case T_NATURAL:
        case T_UNNATURAL:
        case T_STRING:
                        bs__ = b__.sink();
          N_Term(bs__, env);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case T_COLON:
                                sink = sink .start(makeTConstructor(sink, t, raw("AttributeKeyValue"), null)) ;
                                sink = sink .copy(b__, true) ;
            jj_consume_token(T_COLON);
            sink = N_Term(sink, env);
            jj_consume_token(T_RBRACE);
                                sink = sink .end() ;
            break;
          case T_RBRACE:
                                sink = sink .start(makeTConstructor(sink, t, raw("AttributeKey"), null)) ;
                                sink = sink .copy(b__, true) ;
            jj_consume_token(T_RBRACE);
                                sink = sink .end() ;
            break;
          default:
            jj_la1[195] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case T_NOT:
                        sink = sink .start(makeTConstructor(sink, t, raw("AttributeNotKey"), null)) ;
          jj_consume_token(T_NOT);
          sink = N_Term(sink, env);
          jj_consume_token(T_RBRACE);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[196] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[197] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeValue");
    }
  }

/**
 * <em>ConcreteSpace</em> ::=   <a href="#T_CONCRETESPACE">CONCRETESPACE</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_ConcreteSpace(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ConcreteSpace");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_ConcreteSpace:
        t = jj_consume_token(MT_ConcreteSpace);
                              sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_49:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[198] = jj_gen;
              break label_49;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[199] = jj_gen;
          ;
        }
                                                                                                                                                                           {if (true) return sink.endMetaApplication();}
        break;
      case IT_ConcreteSpace:
        jj_consume_token(IT_ConcreteSpace);
                             sink=N_Embedded(sink, env);
                                                            {if (true) return sink;}
        break;
      case T_CONCRETESPACE:
        t = jj_consume_token(T_CONCRETESPACE);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[200] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ConcreteSpace");
    }
  }

/**
 * <em>ConcreteWord</em> ::=   <a href="#T_CONCRETEWORD">CONCRETEWORD</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_ConcreteWord(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ConcreteWord");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_ConcreteWord:
        t = jj_consume_token(MT_ConcreteWord);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_50:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[201] = jj_gen;
              break label_50;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[202] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_ConcreteWord:
        jj_consume_token(IT_ConcreteWord);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case T_CONCRETEWORD:
        t = jj_consume_token(T_CONCRETEWORD);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[203] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ConcreteWord");
    }
  }

/** <em>ModuleName$WithEOF</em> ::= <em>ModuleName</em> EOF . */
  final public net.sf.crsx.Sink N_ModuleName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ModuleName$WithEOF");
    try {
      sink = N_ModuleName(sink, env);
      jj_consume_token(0);
                                      {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ModuleName$WithEOF");
    }
  }

/**
 * <em>ModuleName</em> ::=  <a href="#N_String">&lang;String&rang;</a>   <br>
 *  |  <a href="#N_Variable">&lang;Variable&rang;</a>   <br>
 *  |  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
  final public net.sf.crsx.Sink N_ModuleName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_ModuleName");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_ModuleName:
        t = jj_consume_token(MT_ModuleName);
                           sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_51:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[204] = jj_gen;
              break label_51;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[205] = jj_gen;
          ;
        }
                                                                                                                                                                        {if (true) return sink.endMetaApplication();}
        break;
      case IT_ModuleName:
        jj_consume_token(IT_ModuleName);
                          sink=N_Embedded(sink, env);
                                                         {if (true) return sink;}
        break;
      case MT_String:
      case IT_String:
      case T_STRING:
        sink = N_String(sink, env);
         {if (true) return sink;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
        sink = N_Variable(sink, env);
         {if (true) return sink;}
        break;
      case MT_Constructor:
      case IT_Constructor:
      case T_DASH:
      case T_UPPER:
      case T_CON:
        sink = N_Constructor(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[206] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_ModuleName");
    }
  }

/** <em>SortName$WithEOF</em> ::= <em>SortName</em> EOF . */
  final public net.sf.crsx.Sink N_SortName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortName$WithEOF");
    try {
   token_source.SwitchTo(DEFAULT);
      sink = N_SortName(sink, env);
      jj_consume_token(0);
                                                                      {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortName$WithEOF");
    }
  }

/**
 * <em>SortName</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
  final public net.sf.crsx.Sink N_SortName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_SortName");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_SortName:
        t = jj_consume_token(MT_SortName);
                         sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_52:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[207] = jj_gen;
              break label_52;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[208] = jj_gen;
          ;
        }
                                                                                                                                                                      {if (true) return sink.endMetaApplication();}
        break;
      case IT_SortName:
        jj_consume_token(IT_SortName);
                        sink=N_Embedded(sink, env);
                                                       {if (true) return sink;}
        break;
      case MT_Constructor:
      case IT_Constructor:
      case T_DASH:
      case T_UPPER:
      case T_CON:
        sink = N_Constructor(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[209] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_SortName");
    }
  }

/** <em>FragmentName$WithEOF</em> ::= <em>FragmentName</em> EOF . */
  final public net.sf.crsx.Sink N_FragmentName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_FragmentName$WithEOF");
    try {
   token_source.SwitchTo(RE);
      sink = N_FragmentName(sink, env);
      jj_consume_token(0);
                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_FragmentName$WithEOF");
    }
  }

/**
 * <em>FragmentName</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
  final public net.sf.crsx.Sink N_FragmentName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_FragmentName");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_FragmentName:
        t = jj_consume_token(MT_FragmentName);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_53:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[210] = jj_gen;
              break label_53;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[211] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_FragmentName:
        jj_consume_token(IT_FragmentName);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case MT_Constructor:
      case IT_Constructor:
      case T_DASH:
      case T_UPPER:
      case T_CON:
        sink = N_Constructor(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[212] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_FragmentName");
    }
  }

/** <em>FragmentRef$WithEOF</em> ::= <em>FragmentRef</em> EOF . */
  final public net.sf.crsx.Sink N_FragmentRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_FragmentRef$WithEOF");
    try {
   token_source.SwitchTo(DEFAULT);
      sink = N_FragmentRef(sink, env);
      jj_consume_token(0);
                                                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_FragmentRef$WithEOF");
    }
  }

/**
 * <em>FragmentRef</em> ::=   <a href="#T_FRAGMENT_REF">FRAGMENT_REF</a><font color="red">$:unembed</font> 
 */
  final public net.sf.crsx.Sink N_FragmentRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_FragmentRef");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_FragmentRef:
        t = jj_consume_token(MT_FragmentRef);
                            sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_54:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[213] = jj_gen;
              break label_54;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[214] = jj_gen;
          ;
        }
                                                                                                                                                                         {if (true) return sink.endMetaApplication();}
        break;
      case IT_FragmentRef:
        jj_consume_token(IT_FragmentRef);
                           sink=N_Embedded(sink, env);
                                                          {if (true) return sink;}
        break;
      case T_FRAGMENT_REF:
        t = jj_consume_token(T_FRAGMENT_REF);
                sink = sink .start(makeTConstructor(sink, t, unembed(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[215] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_FragmentRef");
    }
  }

/** <em>AttributeName$WithEOF</em> ::= <em>AttributeName</em> EOF . */
  final public net.sf.crsx.Sink N_AttributeName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeName$WithEOF");
    try {
      sink = N_AttributeName(sink, env);
      jj_consume_token(0);
                                         {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeName$WithEOF");
    }
  }

/**
 * <em>AttributeName</em> ::=  <a href="#N_Literal">&lang;Literal&rang;</a>   <br>
 *  |  <a href="#N_Variable">&lang;Variable&rang;</a>   <br>
 *  |  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
  final public net.sf.crsx.Sink N_AttributeName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_AttributeName");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_AttributeName:
        t = jj_consume_token(MT_AttributeName);
                              sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_55:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[216] = jj_gen;
              break label_55;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[217] = jj_gen;
          ;
        }
                                                                                                                                                                           {if (true) return sink.endMetaApplication();}
        break;
      case IT_AttributeName:
        jj_consume_token(IT_AttributeName);
                             sink=N_Embedded(sink, env);
                                                            {if (true) return sink;}
        break;
      case MT_Literal:
      case IT_Literal:
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case MT_String:
      case IT_String:
      case T_DIGIT:
      case T_NATURAL:
      case T_UNNATURAL:
      case T_STRING:
        sink = N_Literal(sink, env);
         {if (true) return sink;}
        break;
      case MT_Variable:
      case IT_Variable:
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
        sink = N_Variable(sink, env);
         {if (true) return sink;}
        break;
      case MT_Constructor:
      case IT_Constructor:
      case T_DASH:
      case T_UPPER:
      case T_CON:
        sink = N_Constructor(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[218] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_AttributeName");
    }
  }

/** <em>Constructor$WithEOF</em> ::= <em>Constructor</em> EOF . */
  final public net.sf.crsx.Sink N_Constructor$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Constructor$WithEOF");
    try {
      sink = N_Constructor(sink, env);
      jj_consume_token(0);
                                       {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Constructor$WithEOF");
    }
  }

/**
 * <em>Constructor</em> ::=  (   <a href="#T_UPPER">UPPER</a><font color="red">$</font>  |   <a href="#T_DASH">DASH</a><font color="red">$</font>  |   <a href="#T_CON">CON</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_Constructor(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Constructor");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Constructor:
        t = jj_consume_token(MT_Constructor);
                            sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_56:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[219] = jj_gen;
              break label_56;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[220] = jj_gen;
          ;
        }
                                                                                                                                                                         {if (true) return sink.endMetaApplication();}
        break;
      case IT_Constructor:
        jj_consume_token(IT_Constructor);
                           sink=N_Embedded(sink, env);
                                                          {if (true) return sink;}
        break;
      case T_DASH:
      case T_UPPER:
      case T_CON:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_UPPER:
          t = jj_consume_token(T_UPPER);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_DASH:
          t = jj_consume_token(T_DASH);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_CON:
          t = jj_consume_token(T_CON);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[221] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[222] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Constructor");
    }
  }

/** <em>Variable$WithEOF</em> ::= <em>Variable</em> EOF . */
  final public net.sf.crsx.Sink N_Variable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Variable$WithEOF");
    try {
      sink = N_Variable(sink, env);
      jj_consume_token(0);
                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Variable$WithEOF");
    }
  }

/**
 * <em>Variable</em> ::=  (   <a href="#T_LOWER">LOWER</a><font color="red">$</font>  |   <a href="#T_VAR">VAR</a><font color="red">$</font>  |   <a href="#T_MODULE">MODULE</a><font color="red">$</font>  |   <a href="#T_SORT">SORT</a><font color="red">$</font>  |   <a href="#T_DATA">DATA</a><font color="red">$</font>  |   <a href="#T_STATIC">STATIC</a><font color="red">$</font>  |   <a href="#T_SYMBOL">SYMBOL</a><font color="red">$</font>  |   <a href="#T_SCHEME">SCHEME</a><font color="red">$</font>  |   <a href="#T_AUTOMATIC">AUTOMATIC</a><font color="red">$</font>  |   <a href="#T_ATTRIBUTE">ATTRIBUTE</a><font color="red">$</font>  |   <a href="#T_COMPOSE">COMPOSE</a><font color="red">$</font>  |   <a href="#T_SUGAR">SUGAR</a><font color="red">$</font>  |   <a href="#T_RULE">RULE</a><font color="red">$</font>  |   <a href="#T_PRIORITY">PRIORITY</a><font color="red">$</font>  |   <a href="#T_DEFAULT">DEFAULT</a><font color="red">$</font>  |   <a href="#T_SPACE">SPACE</a><font color="red">$</font>  |   <a href="#T_IMPORT">IMPORT</a><font color="red">$</font>  |   <a href="#T_TOKEN">TOKEN</a><font color="red">$</font>  |   <a href="#T_FRAGMENT">FRAGMENT</a><font color="red">$</font>  |   <a href="#T_NESTED">NESTED</a><font color="red">$</font>  |   <a href="#T_TAG">TAG</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_Variable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Variable");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Variable:
        t = jj_consume_token(MT_Variable);
                         sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_57:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[223] = jj_gen;
              break label_57;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[224] = jj_gen;
          ;
        }
                                                                                                                                                                      {if (true) return sink.endMetaApplication();}
        break;
      case IT_Variable:
        jj_consume_token(IT_Variable);
                        sink=N_Embedded(sink, env);
                                                       {if (true) return sink;}
        break;
      case T_LOWER:
      case T_MODULE:
      case T_SORT:
      case T_DATA:
      case T_SCHEME:
      case T_AUTOMATIC:
      case T_SYMBOL:
      case T_STATIC:
      case T_ATTRIBUTE:
      case T_COMPOSE:
      case T_SUGAR:
      case T_RULE:
      case T_PRIORITY:
      case T_DEFAULT:
      case T_IMPORT:
      case T_TAG:
      case T_SPACE:
      case T_TOKEN:
      case T_FRAGMENT:
      case T_NESTED:
      case T_VAR:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_LOWER:
          t = jj_consume_token(T_LOWER);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_VAR:
          t = jj_consume_token(T_VAR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_MODULE:
          t = jj_consume_token(T_MODULE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_SORT:
          t = jj_consume_token(T_SORT);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_DATA:
          t = jj_consume_token(T_DATA);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_STATIC:
          t = jj_consume_token(T_STATIC);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_SYMBOL:
          t = jj_consume_token(T_SYMBOL);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_SCHEME:
          t = jj_consume_token(T_SCHEME);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_AUTOMATIC:
          t = jj_consume_token(T_AUTOMATIC);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_ATTRIBUTE:
          t = jj_consume_token(T_ATTRIBUTE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_COMPOSE:
          t = jj_consume_token(T_COMPOSE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_SUGAR:
          t = jj_consume_token(T_SUGAR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_RULE:
          t = jj_consume_token(T_RULE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_PRIORITY:
          t = jj_consume_token(T_PRIORITY);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_DEFAULT:
          t = jj_consume_token(T_DEFAULT);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_SPACE:
          t = jj_consume_token(T_SPACE);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_IMPORT:
          t = jj_consume_token(T_IMPORT);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_TOKEN:
          t = jj_consume_token(T_TOKEN);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_FRAGMENT:
          t = jj_consume_token(T_FRAGMENT);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_NESTED:
          t = jj_consume_token(T_NESTED);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_TAG:
          t = jj_consume_token(T_TAG);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[225] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[226] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Variable");
    }
  }

/** <em>MetaVariable$WithEOF</em> ::= <em>MetaVariable</em> EOF . */
  final public net.sf.crsx.Sink N_MetaVariable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_MetaVariable$WithEOF");
    try {
      sink = N_MetaVariable(sink, env);
      jj_consume_token(0);
                                        {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_MetaVariable$WithEOF");
    }
  }

/**
 * <em>MetaVariable</em> ::=  (   <a href="#T_META">META</a><font color="red">$</font>  |   <a href="#T_HASH">HASH</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_MetaVariable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_MetaVariable");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_MetaVariable:
        t = jj_consume_token(MT_MetaVariable);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_58:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[227] = jj_gen;
              break label_58;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[228] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_MetaVariable:
        jj_consume_token(IT_MetaVariable);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case T_HASH:
      case T_META:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_META:
          t = jj_consume_token(T_META);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_HASH:
          t = jj_consume_token(T_HASH);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[229] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[230] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_MetaVariable");
    }
  }

/**
 * <em>Separator</em> ::=  (   <a href="#T_BAR">BAR</a><font color="red">$</font>  |   <a href="#T_SEMI">SEMI</a><font color="red">$</font>  |   <a href="#T_COMMA">COMMA</a><font color="red">$</font>  |   <a href="#T_COLON">COLON</a><font color="red">$</font>  |   <a href="#T_STAR">STAR</a><font color="red">$</font>  |   <a href="#T_DOT">DOT</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_Separator(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Separator");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Separator:
        t = jj_consume_token(MT_Separator);
                          sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_59:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[231] = jj_gen;
              break label_59;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[232] = jj_gen;
          ;
        }
                                                                                                                                                                       {if (true) return sink.endMetaApplication();}
        break;
      case IT_Separator:
        jj_consume_token(IT_Separator);
                         sink=N_Embedded(sink, env);
                                                        {if (true) return sink;}
        break;
      case T_SEMI:
      case T_BAR:
      case T_STAR:
      case T_DOT:
      case T_COLON:
      case T_COMMA:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_BAR:
          t = jj_consume_token(T_BAR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_SEMI:
          t = jj_consume_token(T_SEMI);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_COMMA:
          t = jj_consume_token(T_COMMA);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_COLON:
          t = jj_consume_token(T_COLON);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_STAR:
          t = jj_consume_token(T_STAR);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_DOT:
          t = jj_consume_token(T_DOT);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[233] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[234] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Separator");
    }
  }

/** <em>Literal$WithEOF</em> ::= <em>Literal</em> EOF . */
  final public net.sf.crsx.Sink N_Literal$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Literal$WithEOF");
    try {
      sink = N_Literal(sink, env);
      jj_consume_token(0);
                                   {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Literal$WithEOF");
    }
  }

/**
 * <em>Literal</em> ::=  <a href="#N_String">&lang;String&rang;</a>   <br>
 *  |  <a href="#N_Number">&lang;Number&rang;</a>  
 */
  final public net.sf.crsx.Sink N_Literal(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Literal");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Literal:
        t = jj_consume_token(MT_Literal);
                        sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_60:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[235] = jj_gen;
              break label_60;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[236] = jj_gen;
          ;
        }
                                                                                                                                                                     {if (true) return sink.endMetaApplication();}
        break;
      case IT_Literal:
        jj_consume_token(IT_Literal);
                       sink=N_Embedded(sink, env);
                                                      {if (true) return sink;}
        break;
      case MT_String:
      case IT_String:
      case T_STRING:
        sink = N_String(sink, env);
         {if (true) return sink;}
        break;
      case MT_Number:
      case IT_Number:
      case MT_Natural:
      case IT_Natural:
      case T_DIGIT:
      case T_NATURAL:
      case T_UNNATURAL:
        sink = N_Number(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[237] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Literal");
    }
  }

/**
 * <em>Number</em> ::=  <a href="#N_Natural">&lang;Natural&rang;</a>   <br>
 *  |   <a href="#T_UNNATURAL">UNNATURAL</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_Number(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Number");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Number:
        t = jj_consume_token(MT_Number);
                       sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_61:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[238] = jj_gen;
              break label_61;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[239] = jj_gen;
          ;
        }
                                                                                                                                                                    {if (true) return sink.endMetaApplication();}
        break;
      case IT_Number:
        jj_consume_token(IT_Number);
                      sink=N_Embedded(sink, env);
                                                     {if (true) return sink;}
        break;
      case MT_Natural:
      case IT_Natural:
      case T_DIGIT:
      case T_NATURAL:
        sink = N_Natural(sink, env);
         {if (true) return sink;}
        break;
      case T_UNNATURAL:
        t = jj_consume_token(T_UNNATURAL);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[240] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Number");
    }
  }

/**
 * <em>Natural</em> ::=   <a href="#T_DIGIT">DIGIT</a><font color="red">$</font>  <br>
 *  |   <a href="#T_NATURAL">NATURAL</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_Natural(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Natural");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Natural:
        t = jj_consume_token(MT_Natural);
                        sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_62:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[241] = jj_gen;
              break label_62;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[242] = jj_gen;
          ;
        }
                                                                                                                                                                     {if (true) return sink.endMetaApplication();}
        break;
      case IT_Natural:
        jj_consume_token(IT_Natural);
                       sink=N_Embedded(sink, env);
                                                      {if (true) return sink;}
        break;
      case T_DIGIT:
        t = jj_consume_token(T_DIGIT);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      case T_NATURAL:
        t = jj_consume_token(T_NATURAL);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[243] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Natural");
    }
  }

/**
 * <em>String</em> ::=   <a href="#T_STRING">STRING</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_String(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_String");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_String:
        t = jj_consume_token(MT_String);
                       sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_63:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[244] = jj_gen;
              break label_63;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[245] = jj_gen;
          ;
        }
                                                                                                                                                                    {if (true) return sink.endMetaApplication();}
        break;
      case IT_String:
        jj_consume_token(IT_String);
                      sink=N_Embedded(sink, env);
                                                     {if (true) return sink;}
        break;
      case T_STRING:
        t = jj_consume_token(T_STRING);
                sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[246] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_String");
    }
  }

/** <em>Word$WithEOF</em> ::= <em>Word</em> EOF . */
  final public net.sf.crsx.Sink N_Word$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Word$WithEOF");
    try {
   token_source.SwitchTo(DEFAULT);
      sink = N_Word(sink, env);
      jj_consume_token(0);
                                                                  {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Word$WithEOF");
    }
  }

/**
 * <em>Word</em> ::=  (   <a href="#T_UPPER">UPPER</a><font color="red">$</font>  |   <a href="#T_DASH">DASH</a><font color="red">$</font>  |   <a href="#T_CON">CON</a><font color="red">$</font>  |   <a href="#T_WORD">WORD</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_Word(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Word");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_Word:
        t = jj_consume_token(MT_Word);
                     sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_64:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[247] = jj_gen;
              break label_64;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[248] = jj_gen;
          ;
        }
                                                                                                                                                                  {if (true) return sink.endMetaApplication();}
        break;
      case IT_Word:
        jj_consume_token(IT_Word);
                    sink=N_Embedded(sink, env);
                                                   {if (true) return sink;}
        break;
      case T_DASH:
      case T_UPPER:
      case T_CON:
      case T_WORD:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_UPPER:
          t = jj_consume_token(T_UPPER);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_DASH:
          t = jj_consume_token(T_DASH);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_CON:
          t = jj_consume_token(T_CON);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_WORD:
          t = jj_consume_token(T_WORD);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[249] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[250] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Word");
    }
  }

/** <em>RegExpClass$WithEOF</em> ::= <em>RegExpClass</em> EOF . */
  final public net.sf.crsx.Sink N_RegExpClass$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpClass$WithEOF");
    try {
   token_source.SwitchTo(RE);
      sink = N_RegExpClass(sink, env);
      jj_consume_token(0);
                                                                    {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpClass$WithEOF");
    }
  }

/**
 * <em>RegExpClass</em> ::=   <a href="#T_CHAR_CLASS">CHAR_CLASS</a><font color="red">$$:unembed:{rawCC}</font> 
 */
  final public net.sf.crsx.Sink N_RegExpClass(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_RegExpClass");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_RegExpClass:
        t = jj_consume_token(MT_RegExpClass);
                            sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_65:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[251] = jj_gen;
              break label_65;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[252] = jj_gen;
          ;
        }
                                                                                                                                                                         {if (true) return sink.endMetaApplication();}
        break;
      case IT_RegExpClass:
        jj_consume_token(IT_RegExpClass);
                           sink=N_Embedded(sink, env);
                                                          {if (true) return sink;}
        break;
      case T_CHAR_CLASS:
        t = jj_consume_token(T_CHAR_CLASS);
                try {sink = factory.parser(factory).parse(sink, "rawCC", new java.io.StringReader(unembed(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
         {if (true) return sink;}
        break;
      default:
        jj_la1[253] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_RegExpClass");
    }
  }

/** <em>CC$WithEOF</em> ::= <em>CC</em> EOF . */
  final public net.sf.crsx.Sink N_CC$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC$WithEOF");
    try {
   token_source.SwitchTo(CC);
      sink = N_CC(sink, env);
      jj_consume_token(0);
                                                           {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC$WithEOF");
    }
  }

/**
 * <em>CC</em> ::=  <a href="#N_CC_RangesTop">&lang;CC_RangesTop&rang;</a>  
 */
  final public net.sf.crsx.Sink N_CC(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_CC:
        t = jj_consume_token(MT_CC);
                   sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_66:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[254] = jj_gen;
              break label_66;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[255] = jj_gen;
          ;
        }
                                                                                                                                                                {if (true) return sink.endMetaApplication();}
        break;
      case IT_CC:
        jj_consume_token(IT_CC);
                  sink=N_Embedded(sink, env);
                                                 {if (true) return sink;}
        break;
      case MT_CC_RangesTop:
      case IT_CC_RangesTop:
      case MT_CC_FirstRangeStartChar:
      case IT_CC_FirstRangeStartChar:
      case T_CC_NOT:
      case T_CC_RBRACKET:
      case T_CC_DASH:
      case T_CC_OTHER:
        sink = N_CC_RangesTop(sink, env);
         {if (true) return sink;}
        break;
      default:
        jj_la1[256] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC");
    }
  }

/** <em>CC_RangesTop$WithEOF</em> ::= <em>CC_RangesTop</em> EOF . */
  final public net.sf.crsx.Sink N_CC_RangesTop$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_RangesTop$WithEOF");
    try {
   token_source.SwitchTo(CC);
      sink = N_CC_RangesTop(sink, env);
      jj_consume_token(0);
                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_RangesTop$WithEOF");
    }
  }

/**
 * <em>CC_RangesTop</em> ::=  <font color="red">{RegExpClassNot}</font><font color="red">:raw</font>    <a href="#T_CC_NOT">CC_NOT</a>   <a href="#N_CC_FirstRangeStartChar">&lang;CC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>   <br>
 *  |  <a href="#N_CC_FirstRangeStartChar">&lang;CC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>  
 */
  final public net.sf.crsx.Sink N_CC_RangesTop(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_RangesTop");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.Sink bs__lo = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_CC_RangesTop:
        t = jj_consume_token(MT_CC_RangesTop);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_67:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[257] = jj_gen;
              break label_67;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[258] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_CC_RangesTop:
        jj_consume_token(IT_CC_RangesTop);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case T_CC_NOT:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassNot"), null)) ;
        jj_consume_token(T_CC_NOT);
                bs__lo = b__lo.sink();
        N_CC_FirstRangeStartChar(bs__lo, env);
                s1 = b1.sink();
                s1 .copy(b__lo, true) ;
        sink = N_CC_RangeTail(sink, env, b1);
                {if (true) return sink .end() ;}
        break;
      case MT_CC_FirstRangeStartChar:
      case IT_CC_FirstRangeStartChar:
      case T_CC_RBRACKET:
      case T_CC_DASH:
      case T_CC_OTHER:
                bs__lo = b__lo.sink();
        N_CC_FirstRangeStartChar(bs__lo, env);
                s1 = b1.sink();
                s1 .copy(b__lo, true) ;
        sink = N_CC_RangeTail(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[259] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_RangesTop");
    }
  }

/** <em>CC_Ranges$WithEOF</em> ::= <em>CC_Ranges</em> EOF . */
  final public net.sf.crsx.Sink N_CC_Ranges$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_Ranges$WithEOF");
    try {
   token_source.SwitchTo(CC);
      sink = N_CC_Ranges(sink, env);
      jj_consume_token(0);
                                                                  {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_Ranges$WithEOF");
    }
  }

/**
 * <em>CC_Ranges</em> ::=  <a href="#N_CC_RangeChar">&lang;CC_RangeChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassDone}</font><font color="red">:raw</font> 
 */
  final public net.sf.crsx.Sink N_CC_Ranges(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_Ranges");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.Sink bs__lo = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_CC_Ranges:
        t = jj_consume_token(MT_CC_Ranges);
                          sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_68:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[260] = jj_gen;
              break label_68;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[261] = jj_gen;
          ;
        }
                                                                                                                                                                       {if (true) return sink.endMetaApplication();}
        break;
      case IT_CC_Ranges:
        jj_consume_token(IT_CC_Ranges);
                         sink=N_Embedded(sink, env);
                                                        {if (true) return sink;}
        break;
      case MT_CC_RangeChar:
      case IT_CC_RangeChar:
      case T_CC_NOT:
      case T_CC_DASH:
      case T_CC_OTHER:
                bs__lo = b__lo.sink();
        N_CC_RangeChar(bs__lo, env);
                s1 = b1.sink();
                s1 .copy(b__lo, true) ;
        sink = N_CC_RangeTail(sink, env, b1);
         {if (true) return sink;}
        break;
      default:
        jj_la1[262] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassDone"), null)) ;
                {if (true) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_Ranges");
    }
  }

/**
 * <em>CC_RangeTail</em> ::=   <a href="#T_CC_DASH">CC_DASH</a>   (  <font color="red">{RegExpClassRange}</font><font color="red">:raw</font>   <font color="red">{{#lo}}</font>   <a href="#N_CC_RangeChar">&lang;CC_RangeChar&rang;</a>    <a href="#N_CC_Ranges">&lang;CC_Ranges&rang;</a>   |  <font color="red">{RegExpClassChar}</font><font color="red">:raw</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:raw</font>  )  <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:raw</font>   <font color="red">{{#lo}}</font>   <a href="#N_CC_NonDashRangeStartChar">&lang;CC_NonDashRangeStartChar&rang;</a> <font color="red">:#lo2</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo2&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:raw</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:raw</font> 
 */
  final public net.sf.crsx.Sink N_CC_RangeTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__lo) throws ParseException {
    trace_call("N_CC_RangeTail");
    try {
        Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs__lo2 = null;
        net.sf.crsx.util.Buffer b__lo2 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_CC_RangeTail:
        t = jj_consume_token(MT_CC_RangeTail);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_69:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[263] = jj_gen;
              break label_69;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[264] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_CC_RangeTail:
        jj_consume_token(IT_CC_RangeTail);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case T_CC_DASH:
        jj_consume_token(T_CC_DASH);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MT_CC_RangeChar:
        case IT_CC_RangeChar:
        case T_CC_NOT:
        case T_CC_DASH:
        case T_CC_OTHER:
                        sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassRange"), null)) ;
                        sink = sink .copy(b__lo, false) ;
          sink = N_CC_RangeChar(sink, env);
          sink = N_CC_Ranges(sink, env);
                        sink = sink .end() ;
          break;
        default:
          jj_la1[265] = jj_gen;
                        sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassChar"), null)) ;
                        sink = sink .copy(b__lo, false) ;
                        sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassDone"), null)) ;
                        sink = sink .end().end() ;
        }
         {if (true) return sink;}
        break;
      case MT_CC_NonDashRangeStartChar:
      case IT_CC_NonDashRangeStartChar:
      case T_CC_NOT:
      case T_CC_OTHER:
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassChar"), null)) ;
                sink = sink .copy(b__lo, false) ;
                bs__lo2 = b__lo2.sink();
        N_CC_NonDashRangeStartChar(bs__lo2, env);
                s1 = b1.sink();
                s1 .copy(b__lo2, true) ;
        sink = N_CC_RangeTail(sink, env, b1);
                {if (true) return sink .end() ;}
        break;
      default:
        jj_la1[266] = jj_gen;
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassChar"), null)) ;
                sink = sink .copy(b__lo, false) ;
                sink = sink .start(makeTConstructor(sink, t, raw("RegExpClassDone"), null)) ;
                {if (true) return sink .end().end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_RangeTail");
    }
  }

/** <em>CC_FirstRangeStartChar$WithEOF</em> ::= <em>CC_FirstRangeStartChar</em> EOF . */
  final public net.sf.crsx.Sink N_CC_FirstRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_FirstRangeStartChar$WithEOF");
    try {
   token_source.SwitchTo(CC);
      sink = N_CC_FirstRangeStartChar(sink, env);
      jj_consume_token(0);
                                                                               {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_FirstRangeStartChar$WithEOF");
    }
  }

/**
 * <em>CC_FirstRangeStartChar</em> ::=  (   <a href="#T_CC_RBRACKET">CC_RBRACKET</a><font color="red">$</font>  |   <a href="#T_CC_DASH">CC_DASH</a><font color="red">$</font>  |   <a href="#T_CC_OTHER">CC_OTHER</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_CC_FirstRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_FirstRangeStartChar");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_CC_FirstRangeStartChar:
        t = jj_consume_token(MT_CC_FirstRangeStartChar);
                                       sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_70:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[267] = jj_gen;
              break label_70;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[268] = jj_gen;
          ;
        }
                                                                                                                                                                                    {if (true) return sink.endMetaApplication();}
        break;
      case IT_CC_FirstRangeStartChar:
        jj_consume_token(IT_CC_FirstRangeStartChar);
                                      sink=N_Embedded(sink, env);
                                                                     {if (true) return sink;}
        break;
      case T_CC_RBRACKET:
      case T_CC_DASH:
      case T_CC_OTHER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_CC_RBRACKET:
          t = jj_consume_token(T_CC_RBRACKET);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_CC_DASH:
          t = jj_consume_token(T_CC_DASH);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_CC_OTHER:
          t = jj_consume_token(T_CC_OTHER);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[269] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[270] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_FirstRangeStartChar");
    }
  }

/** <em>CC_NonDashRangeStartChar$WithEOF</em> ::= <em>CC_NonDashRangeStartChar</em> EOF . */
  final public net.sf.crsx.Sink N_CC_NonDashRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_NonDashRangeStartChar$WithEOF");
    try {
   token_source.SwitchTo(CC);
      sink = N_CC_NonDashRangeStartChar(sink, env);
      jj_consume_token(0);
                                                                                 {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_NonDashRangeStartChar$WithEOF");
    }
  }

/**
 * <em>CC_NonDashRangeStartChar</em> ::=  (   <a href="#T_CC_NOT">CC_NOT</a><font color="red">$</font>  |   <a href="#T_CC_OTHER">CC_OTHER</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_CC_NonDashRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_NonDashRangeStartChar");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_CC_NonDashRangeStartChar:
        t = jj_consume_token(MT_CC_NonDashRangeStartChar);
                                         sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_71:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[271] = jj_gen;
              break label_71;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[272] = jj_gen;
          ;
        }
                                                                                                                                                                                      {if (true) return sink.endMetaApplication();}
        break;
      case IT_CC_NonDashRangeStartChar:
        jj_consume_token(IT_CC_NonDashRangeStartChar);
                                        sink=N_Embedded(sink, env);
                                                                       {if (true) return sink;}
        break;
      case T_CC_NOT:
      case T_CC_OTHER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_CC_NOT:
          t = jj_consume_token(T_CC_NOT);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_CC_OTHER:
          t = jj_consume_token(T_CC_OTHER);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[273] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[274] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_NonDashRangeStartChar");
    }
  }

/** <em>CC_RangeChar$WithEOF</em> ::= <em>CC_RangeChar</em> EOF . */
  final public net.sf.crsx.Sink N_CC_RangeChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_RangeChar$WithEOF");
    try {
   token_source.SwitchTo(CC);
      sink = N_CC_RangeChar(sink, env);
      jj_consume_token(0);
                                                                     {if (true) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_RangeChar$WithEOF");
    }
  }

/**
 * <em>CC_RangeChar</em> ::=  (   <a href="#T_CC_NOT">CC_NOT</a><font color="red">$</font>  |   <a href="#T_CC_DASH">CC_DASH</a><font color="red">$</font>  |   <a href="#T_CC_OTHER">CC_OTHER</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_CC_RangeChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_CC_RangeChar");
    try {
        Token t = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MT_CC_RangeChar:
        t = jj_consume_token(MT_CC_RangeChar);
                             sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 3:
          jj_consume_token(3);
          sink = N_SortParam(sink, env);
          label_72:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 4:
              ;
              break;
            default:
              jj_la1[275] = jj_gen;
              break label_72;
            }
            jj_consume_token(4);
            sink = N_SortParam(sink, env);
          }
          jj_consume_token(5);
          break;
        default:
          jj_la1[276] = jj_gen;
          ;
        }
                                                                                                                                                                          {if (true) return sink.endMetaApplication();}
        break;
      case IT_CC_RangeChar:
        jj_consume_token(IT_CC_RangeChar);
                            sink=N_Embedded(sink, env);
                                                           {if (true) return sink;}
        break;
      case T_CC_NOT:
      case T_CC_DASH:
      case T_CC_OTHER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_CC_NOT:
          t = jj_consume_token(T_CC_NOT);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_CC_DASH:
          t = jj_consume_token(T_CC_DASH);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        case T_CC_OTHER:
          t = jj_consume_token(T_CC_OTHER);
                        sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
                        sink = sink .end() ;
          break;
        default:
          jj_la1[277] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         {if (true) return sink;}
        break;
      default:
        jj_la1[278] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_CC_RangeChar");
    }
  }

  /** Generated Token Manager. */
  public RawTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[279];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
      jj_la1_init_6();
      jj_la1_init_7();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x10,0x8,0xc6,0x10,0x8,0xc0,0x10,0x8,0xcc0,0x300,0x10,0x8,0x0,0x0,0x0,0x0,0xcc0,0x10,0x8,0x0,0x3000,0x10,0x8,0xc000,0x10,0x8,0x3cf0000,0x10,0x8,0x3cc0000,0x10,0x8,0xc00000,0x0,0x300000,0x10,0x8,0xc00000,0x10,0x8,0x3c00000,0x10,0x8,0x0,0xc000000,0x10,0x8,0xf0000000,0x10,0x8,0xc0000000,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0xc,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0x300,0xc0,0x0,0x0,0xccc3c00,0x0,0x0,0x300,0x0,0x0,0x0,0xccc3c00,0x0,0x0,0x3c000,0x0,0xccc3000,0x0,0x0,0x0,0x3c000,0x0,0x0,0x30000,0x0,0x0,0xccc0000,0x0,0x0,0xcf00000,0x0,0x0,0xcc00000,0x0,0x0,0x3000000,0x0,0x0,0xc000000,0x0,0x0,0x30000000,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x30,0xc,0x0,0x0,0x30,0x0,0x0,0x0,0x0,0xc3c0,0x0,0x0,0x0,0x300,0x0,0x0,0x3c00,0x3c00,0x0,0x0,0x3003c00,0x0,0xf3000,0xf3000,0x0,0xf3000,0xf3000,0x0,0x0,0x3003c00,0x0,0x3000,0x0,0x0,0xf3000,0xf3000,0x0,0xf3000,0xf3000,0x0,0x0,0xc000,0x0,0x0,0x0,0xf3000,0x0,0x0,0x300000,0xc00000,0xc3000,0x0,0x0,0x300000,0x0,0x0,0x0,0xc00000,0x0,0x0,0x0,0x3003c00,0x0,0x0,0xc000000,0x0,0x0,0xc0000000,0x30000000,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0c00000,0x0,0x0,0x0,0xc0c000,0x0,0xc0c000,0x0,0xc0c00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000,0x0,0x0,0xc0000,0x0,0x0,0x30000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000,0x0,0x0,0x0,0x0,0x0,0x0,0x3000000,0x0,0x0,0x3000000,0x0,0x0,0x0,0xc0c000,0x0,0x0,0x3000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc00000,0x0,0x0,0x0,0x3c0c000,0x0,0x0,0xc00000,0x0,0x0,0x0,0x3c0c000,0x0,0x0,0x3000000,0x0,0x3c0c000,0x0,0x0,0x0,0x3000000,0x0,0x0,0x3000000,0x0,0x0,0x3c0c000,0x0,0x0,0x3c0c000,0x0,0x0,0x3c0c000,0x0,0x0,0xc000000,0x0,0x0,0x3000000,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0c00000,0x0,0x0,0x0,0x0,0x0,0x0,0xcfc00000,0xcfc00000,0x0,0x0,0xcfc00000,0x0,0xcfc00000,0xcfc00000,0x0,0xcfc00000,0xcfc00000,0x0,0xfc00000,0xcfc00000,0x0,0xccc00000,0x0,0x0,0xcfc00000,0xcfc00000,0x0,0xcfc00000,0xcfc00000,0x0,0xc00000,0xc0c00000,0x0,0x0,0x0,0xcfc00000,0x0,0x0,0x3000000,0x3000000,0xcfc00000,0x0,0x0,0x3000000,0x0,0x0,0x0,0x3000000,0x0,0x0,0x0,0xcfc00000,0x0,0x0,0xc0,0x0,0x0,0x3,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0xcfc00000,0xc,0x0,0x0,0x30,0x0,0x0,0xc0,0x0,0x0,0x3c03000,0x0,0x0,0xc0c000,0x0,0x0,0xc30000,0x0,0x0,0xc0000,0x0,0x0,0xc3f00000,0x0,0x0,0x0,0xc00000,0x0,0x0,0x0,0x3000000,0x0,0x0,0x0,0xc000000,0x0,0x0,0x0,0x30000000,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f0,0x0,0x0,0x3f0,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0xf0,0x0,0x0,0x3f0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x68000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003f,0x0,0x0,0x0,0x0,0x0,0x0,0x200003f,0x200003f,0x0,0x0,0x200003f,0x0,0x200003f,0x200003f,0x0,0x200003f,0x200003f,0x0,0x2000000,0x200003f,0x0,0x200003f,0x0,0x0,0x200003f,0x200003f,0x0,0x200003f,0x200003f,0x0,0x2000000,0x200003f,0x0,0x0,0x0,0x200003f,0x0,0x0,0x0,0x0,0x200003f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003f,0x0,0x0,0x68000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003f,0x0,0x0,0x0,0x20000000,0x0,0x0,0x40000000,0x0,0x0,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x0,0x0,0xf,0x0,0x0,0xc,0x0,0x0,0x30,0x0,0x0,0x0,0xc0,0x0,0x0,0x300,0x0,0x0,0xc3c00,0x0,0x0,0xc3000,0x0,0x0,0xc0c000,0x0,0x0,0xc00000,0x330000,0x0,0x0,0x0,0xc0000,0x0,0x0,0x0,0x300000,0x0,0x0,0x0,0xc00000,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x4000000,0x0,0x0,0x4000000,0x0,0x0,0xec00403,0x0,0x0,0x0,0x2400000,0x4,0x2400000,0x0,0xec00403,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x2400104,0x0,0x0,0x2400104,0x0,0x0,0x2408313,0x80,0x70,0x0,0x0,0x2400000,0x0,0x0,0x2400104,0x0,0x0,0xa00,0x404,0x0,0x0,0xfd000000,0x0,0x0,0xfd000000,0x0,0x0,0x8000,0x2400000,0x0,0x0,0xfd000000,0x0,0x0,0x2,0x0,0x0,0x80000000,0x10000000,0xb2440000,0x2,0x0,0x0,0xff402004,0x4,0x0,0x2400000,0x0,0x0,0x8000,0xff402004,0x0,0x0,0xfd000000,0x2000,0xff402004,0x0,0x0,0x8000,0xfd000000,0x0,0x0,0xfd000000,0x0,0x0,0xff400004,0x0,0x0,0xff400004,0x0,0x0,0xff400004,0x0,0x0,0x1000,0x0,0x0,0xfd000000,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x80000,0x0,0x0,0x200,0x20000,0x2c00000,0x0,0x0,0x0,0x0,0x0,0x0,0xffc01000,0xffc01000,0x0,0x0,0xffc01000,0x2000,0xffc03000,0xffc03000,0x2004,0xffc03000,0xffc03000,0x2004,0xff401000,0xffc01000,0x2000,0x2c01000,0x0,0x0,0xffc03000,0xffc03000,0x2004,0xffc03000,0xffc03000,0x2004,0x2400000,0x2c00000,0x0,0x0,0x8000,0xffc03000,0x0,0x0,0xfd000100,0xfd000000,0xffc03000,0x0,0x0,0xfd000000,0x0,0x0,0x8000,0xfd000000,0x0,0x0,0x8000,0xffc01000,0x0,0x0,0x0,0x0,0x0,0xc0000,0x0,0x0,0x0,0xc0000,0x0,0x0,0xc0000,0xc0000,0x0,0x0,0xa00,0xffd01000,0x404,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff400000,0x0,0x0,0x2400000,0x0,0x0,0x2400000,0x0,0x0,0x0,0x0,0x0,0xffc00000,0x0,0x0,0x2400000,0x2400000,0x0,0x0,0xfd000000,0xfd000000,0x0,0x0,0x1000,0x1000,0x0,0x0,0x8313,0x8313,0x0,0x0,0x800000,0x0,0x0,0x800000,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x2400000,0x2400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_6() {
      jj_la1_6 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x688ef2,0x0,0x0,0x0,0x8000,0x0,0x8800,0x10,0x688ef2,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x32448000,0x0,0x0,0x32448000,0x0,0x0,0x10408000,0x0,0x0,0x0,0x0,0x10408000,0x0,0x0,0x32448000,0x0,0x0,0x0,0x0,0x0,0x0,0x5fff,0x0,0x0,0x5fff,0x0,0x0,0x0,0x8000,0x0,0x0,0x5fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8009,0x0,0x0,0x0,0xdfff,0x0,0x0,0x8000,0x0,0x0,0x0,0xdfff,0x0,0x0,0x5fff,0x0,0xdfff,0x0,0x0,0x0,0x5fff,0x0,0x0,0x5fff,0x0,0x0,0xdfff,0x0,0x0,0xdfff,0x0,0x0,0xdfff,0x0,0x0,0x2000,0x0,0x0,0x5fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x688060,0x0,0x0,0x60,0x0,0x0,0x0,0x68ffff,0x68ffff,0x0,0x0,0x68ffff,0x0,0x68ffff,0x68ffff,0x0,0x68ffff,0x68ffff,0x0,0xffff,0x68ffff,0x0,0x68a000,0x0,0x0,0x68ffff,0x68ffff,0x0,0x68ffff,0x68ffff,0x0,0x8000,0x688000,0x0,0x0,0x0,0x68ffff,0x0,0x0,0x5fff,0x5fff,0x68ffff,0x0,0x0,0x5fff,0x0,0x0,0x0,0x5fff,0x0,0x0,0x0,0x68ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x68ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40dfff,0x0,0x0,0x8000,0x0,0x0,0x8000,0x0,0x0,0x40000,0x0,0x0,0x68dfff,0x0,0x0,0x8000,0x8000,0x0,0x0,0x5fff,0x5fff,0x0,0x0,0x2000,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x680000,0x0,0x0,0x280000,0x0,0x0,0x80000,0x0,0x0,0x400000,0x0,0x0,0x10008000,0x10008000,0x0,0x0,0x20000000,0x0,0x0,0xc0000000,0x0,0x0,0xc0000000,0x0,0x0,0x40000000,0x0,0x0,0x40000000,0x40000000,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x40000000,0x40000000,0x0,0x0,0x40000000,0x40000000,};
   }
   private static void jj_la1_init_7() {
      jj_la1_7 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x3,0x0,0x0,0x3,0x3,0x0,0x0,0x2,0x2,0x0,0x0,0x3,0x3,};
   }

  /** Constructor with InputStream. */
  public Raw(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Raw(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new RawTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 279; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 279; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Raw(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new RawTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 279; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 279; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Raw(RawTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 279; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(RawTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 279; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[226];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 279; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 226; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}

// Copyright (c) 2010, 2014 IBM Corporation.
// $Id: crsx.h,v 3.64 2014/02/05 23:02:01 krisrose Exp $
#ifndef _CRSX_H
# define _CRSX_H
#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
// HEADER FILE WITH SORT-INDEPENDENT DECLARATIONS FOR GENERATING CRSX TERMS IN C
//
// Include this header file with programs that include fragments generated by rules.crs.
///////////////////////////////////////////////////////////////////////////////////////////////////

// Includes.
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <assert.h>
#include <sys/types.h>
#include <alloca.h>
#include <ctype.h>
#include <math.h>

//#define DEBUG
//#define CRSXPROF

// All the pointer types declared forward.
typedef struct _Context *Context;
typedef struct _Variable *Variable;
typedef struct _Term *Term;
typedef struct _VariableUse *VariableUse;
typedef struct _Construction *Construction;
typedef struct _Literal *Literal;
typedef struct _ConstructionDescriptor *ConstructionDescriptor;
typedef struct _SortDescriptor *SortDescriptor;
typedef struct _Sink *Sink;
typedef struct _SubstitutionFrame *SubstitutionFrame;
typedef struct _NamedPropertyLink *NamedPropertyLink;
typedef struct _VariablePropertyLink *VariablePropertyLink;
typedef struct _Variables *Variables;
typedef struct _VariableSet *VariableSet;
typedef struct _VariableSetLink *VariableSetLink;
typedef struct _VariableMap *VariableMap;
typedef struct _VariableMapLink *VariableMapLink;
typedef struct _VariableNameMapLink *VariableNameMapLink;
typedef struct _Hashset* Hashset;
typedef struct _Hashset2* Hashset2;
typedef struct _Pair* Pair;

#define FREEVARS
//#define WEAKENINGS


///////////////////////////////////////////////////////////////////////////////////////////////////
// IDIOMS

// Context.
//
// Defaults to having no content but can be extended as desired because main functions and data
// structures propagate a pointer to "the context" but never create any or access the content.
//
struct _Context
{
    unsigned int stamp;   // satisfy old C compilers and provide variable identity
    Hashset2 stringPool;  // Set of char*
};

//#define DEBUG

// Debugging!
//
#ifdef DEBUG
# ifndef DEBUGENV
#  define DEBUGENV(NAME,CMD) if (getenv(NAME)) CMD
# endif
# ifndef DEBUGF
#  define DEBUGF(CONTEXT,...) printf(__VA_ARGS__)
# endif
# ifndef DEBUGT
#  define DEBUGT(CONTEXT,NESTING,TERM) ppt(CONTEXT, NESTING, TERM)
# endif
# ifndef DEBUGX
#  define DEBUGX(X) X
# endif
# define CRSX_CHECK(CONTEXT,TERM) check(CONTEXT,TERM)
#else
# ifndef DEBUGENV
#  define DEBUGENV(NAME,CMD) noop()
# endif
# ifndef DEBUGF
#  define DEBUGF(CONTEXT,FMT,...) noop()
# endif
# ifndef DEBUGT
#  define DEBUGT(CONTEXT,PREFIX,TERM) noop()
# endif
# ifndef DEBUGX
#  define DEBUGX(X) noop()
# endif
# define CRSX_CHECK(CONTEXT,TERM) noop()
#endif
#ifndef DEBUGRULE
# define DEBUGRULE(CONTEXT,RULE) DEBUGF(CONTEXT, "//%s\n", RULE)
#endif

// Memory allocation.
//
// Usage:
//   struct MyStruct *p = ALLOCATE(context, sizeof(struct MyStruct));
//   struct MyStruct *localp = ALLOCA(context, sizeof(struct MyStruct)); // Use when localp cannot escape from the scope!
//   char *text = ALLOCATENF(context, max_size, "%s%d", some_string, some_int); // like snprintf
//   char *text = GLOBAL(context, "Existing String That Should Be Available Globally!");
// 
// The second form is only guaranteed to be available until the END OF THE CURRENT FRAME.
// 
// Define these before loading this header to not use naive defaults.
// The 'context' pointer will be passed as type Context with the value passed in as the initial Context.
// Allocated space may or may not be explicitly released.
//
// By default the macros map to the standard malloc(3) and alloca(3) functions.
//
#ifndef ALLOCATE
# define ALLOCATE(CONTEXT,SIZE) crsx_allocate((Context)CONTEXT,SIZE)
  extern void *crsx_allocate(Context context, size_t size);
#endif
//
#ifndef CALLOCATE
# define CALLOCATE(CONTEXT,SIZE) crsx_callocate((Context)CONTEXT,SIZE)
  extern void *crsx_callocate(Context context, size_t size);
#endif
//
#ifndef ALLOCATENF
# define ALLOCATENF(CONTEXT,MAXSIZE,...) stringnf(CONTEXT, MAXSIZE, __VA_ARGS__)
#endif
//
#ifndef REALLOCATE
# define REALLOCATE(CONTEXT,POINTER,SIZE) crsx_reallocate((Context)CONTEXT, POINTER, SIZE)
  extern void *crsx_reallocate(Context context, void *pointer, size_t size);
#endif
//
#ifndef FREE
# define FREE(CONTEXT,POINTER) crsx_free((Context)CONTEXT, POINTER)
  extern void crsx_free(Context context, void *pointer);
#endif
//
#ifndef ALLOCA
# define ALLOCA(CONTEXT,SIZE) alloca(SIZE)
#endif
//
#ifndef GLOBAL
# define GLOBAL(CONTEXT,STRING) makeString(CONTEXT,STRING)
#endif

// STRING HELPERS.
//
// Note that all the string operations assume "zero-avoiding UTF-8", which is
// * Strings contain UTF-8 encoded Unicode without any '\0' bytes.
// * The U+0000 code point is encoded as 0xC0 0x80.
// * Internal utility functions use *byte* size and index parameters.

// FORMAT backs up $[Format, format, ...].
//
#ifndef FORMAT
# define FORMAT_BUFFER_SIZE 5000
# define FORMAT(CONTEXT,KIND,...) stringnf(CONTEXT, FORMAT_BUFFER_SIZE, __VA_ARGS__)
  // Low level formatting by default ignores KIND parameter!
#endif

// ALLOCATE a formatted string constant up to the specified maximum size.
// (Uses an internal ALLOCA to size followed by an ALLOCATE to the actual size.)
extern char *stringnf(Context context, const size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));

// ALLOCATE copy of existing string on heap.
extern char *makeString(Context context, const char *src);

// ALLOCATE copy of substring of existing string.
extern char *makeSubstring(Context context, const char *src, size_t first, size_t length);

// ALLOCATE strings corresponding to the $[Escape], $[Rescape], and $[Mangle], primitives. Does not deallocate src/term.
extern char *makeEscaped(Context context, const char *src);
extern char *makeRescaped(Context context, const char *src);
extern char *makeMangled(Context context, const char *src);
extern char *makeEncodePoint(Context context, unsigned int code);

// Hash code for term.
#define HASH_CODE(CONTEXT, TERM) termHashCode(CONTEXT, TERM, NULL)
typedef struct _VariableLink *VariableLink;
struct _VariableLink { VariableLink next; Variable variable; };
extern long long termHashCode(Context context, Term term, VariableLink deBruijn);

// Failure.
//
// ERRORF backs up $[Error[KIND], format, ...].
// NOTE: all internal errors use KIND=Crsx (no quotes).
//
#ifndef ERRORF
# define ERRORF(CONTEXT,KIND,...) errorf(CONTEXT, __VA_ARGS__)
  // Low level error reporting; by default ignores KIND parameter!
#endif
extern void *errorf(Context context, char *format, ...) __attribute__((format(printf, 2, 3)));

//
#ifndef FORGIVABLEERRORF
# define FORGIVABLEERRORF(CONTEXT,KIND,...) errorf(CONTEXT, __VA_ARGS__)
#endif

//
#ifndef CHECKF
# define CHECKF(CONTEXT,TEST,OK,KIND,...) (({ if (!(TEST)) ERRORF(CONTEXT,KIND,__VA_ARGS__); }), OK)
  // Low level error reporting; by default ignores KIND parameter!
#endif

//
// TRACEF backs up $[Trace[KIND], ...] for system level tracing.
//
#ifndef TRACEF
# define TRACEF(CONTEXT,KIND,...) FPRINTF(CONTEXT, STDERR, __VA_ARGS__)
  // By default just prints the message and ignores KIND parameter!
#endif
extern void *errorf(Context context, char *format, ...) __attribute__((format(printf, 2, 3)));

// MatchRegex support
#define MATCHREGEX(regex, string) matchRegex(regex, string)
extern int matchRegex(char* regex, char* str);

// Split string using regex and send list of strings to sink
#define SEND_SPLIT(string, regex, sink) sendSplit(string, regex, sink)
extern void sendSplit(char* str, char* regex, Sink sink);

// TryCall support
#ifndef CRSXTRY
# define CRSXTRY do { jmp_buf ex_buf__; if( !setjmp(ex_buf__) ) {
# define CRSXCATCH(x) } else {
# define CRSXTRYEND } } while(0)
# define CRSXEXCEPTION(x) ""
#endif

// Hook to check for substitution overflow.
//
#ifndef CHECK_METASUBSTITUTE_SIZE
# define CHECK_METASUBSTITUTE_SIZE(context,metaSubstituteSize) permitUnusedLong(metaSubstituteSize)
#endif

// I/O.
//
// Mimic stdio(3) idioms; by default maps to the corresponding stdio(3) functions and macros.
//
#ifndef STDOUT
# define STDOUT stdout
#endif
//
#ifndef STDERR
# define STDERR stderr
#endif
//
#ifndef PRINTF
# define PRINTF(CONTEXT,...) FPRINTF(CONTEXT, STDOUT, __VA_ARGS__)
#endif
//
#ifndef FPRINTF
# define FPRINTF(CONTEXT,OUT,...) fprintf(OUT, __VA_ARGS__)
#endif

// Persistence layer.
//
// Permit saving of terms that can later be loaded.
//
#ifndef SAVE_TERM
# define SAVE_TERM(CONTEXT,NAME,TERM) saveTerm(CONTEXT, NAME, TERM)
#endif
extern int saveTerm(Context context, char *name, Term term);
//
// Note: the (parse+)load functions are defined in crsx_scan.l
//
#ifndef LOAD_TERM
# define LOAD_TERM(SINK,CAT,NAME) loadTerm(SINK, NAME)
#endif
#ifndef SCAN_TERM
# define SCAN_TERM(SINK,CAT,TEXT) scanTerm(SINK, TEXT)
#endif
extern int loadTerm(Sink sink, char *name);
extern int readTerm(Sink sink, FILE *input);
extern int scanTerm(Sink sink, const char *text);
//
// Persistence helpers using stdio(3) FILE streams.
//
#ifndef FOPEN_IN
# define FOPEN_IN(CONTEXT,NAME) fopen_in(CONTEXT, NAME)
#endif
extern FILE* fopen_in(Context context, char *name);
//
#ifndef FOPEN_OUT
# define FOPEN_OUT(CONTEXT,NAME) fopen_out(CONTEXT, NAME)
#endif
extern FILE* fopen_out(Context context, char *name);

// Assertions.
//
#ifndef ASSERT
# define ASSERT(CONTEXT,TEST) assert(TEST)
#endif

// List construction symbols.
//
extern struct _ConstructionDescriptor descriptor_M__sCons;
extern struct _ConstructionDescriptor descriptor_M__sNil;

///////////////////////////////////////////////////////////////////////////////////////////////////
// BitSet forward declarations

#ifndef MAKE_SET_BITS
typedef unsigned long long BITS;
#endif

typedef struct _BitSet {
	unsigned size; // Number of bits
	BITS* bits;
} BitSet;
typedef struct _BitSet* BitSetP;


///////////////////////////////////////////////////////////////////////////////////////////////////
// TERMS

// Term traversal.
//
// Usage:
//   int arity = ARITY(term);
//   int subtermBinderRank = RANK(term,index);
//   Variable binder = BINDER(term,index,binderindex);  assert( index<arity && binderindex<RANK(term,index) )
//   BINDER(term,index,binderindex) = variable;
//   Term subterm = SUB(term,index);
//   SUB(term,index) = subterm;
//   NAMED_PROPERTY(construction,name) is the term bound to the property char *name in term, or NULL
//   VARIABLE_PROPERTY(construction,varable) is the term bound to the property Variable variable in term, or NULL
//
// These macros support the usual CRSX Term data model for constructions:
// - ARITY(term) is the number of subterms of the term (even 0 for variable uses).
// - RANK(term,index) is the number of variables bound for the index'th subterm
// - BINDERS(term,i) is the array of variables bound for the i'th subterm
// - BINDER(term,i,b) is the same as BINDERS(term,i)[b] but with index checking
// - SUB(term,index) is the actual index'th subterm
// - NAMED_PROPERTY(construction,name) is the term bound to the char *name in term, or NULL
// - VARIABLE_PROPERTY(construction,variable) is the term bound to the Variable variable in term, or NULL
// Note that SUB and BINDER can be used as lvalues.
//
// For any term.
#define ARITY(T) (IS_VARIABLE_USE(T) ? 0 : (T)->descriptor->arity)
#define IS_VARIABLE_USE(T) ((T)->descriptor == NULL)
#define IS_CONSTRUCTION(T) ((T)->descriptor != NULL)
#define IS_FUNCTION(T) (IS_CONSTRUCTION(T) && TAG(T) == 0)
#define IS_DATA(T) (IS_CONSTRUCTION(T) && TAG(T) > 0)
#define IS_LITERAL(T) (IS_DATA(T) && !SORT(T))
#define IS_CONTAINER(T) (IS_DATA(T) && SORT(T))

// Tests: normal form and function that cannot currently step.
#define IS_NF(T) (IS_VARIABLE_USE(T) || asConstruction(T)->nf)
#define IS_NOSTEP(T) (IS_VARIABLE_USE(T) || asConstruction(T)->nostep)

#define IS_CLOSED(T) (!IS_VARIABLE_USE(T) && !asConstruction(T)->fvs);

// For variable use terms.
#define VARIABLE(T) (asVariableUse(T)->variable)

// For construction terms:
#define SORT(T) ((T)->descriptor->sort)
#define TAG(T) ((T)->descriptor->sortoffset)
#define SUB(T,I) (*(c_subp(asConstruction(T),I)))
#define RANK(T,I) c_rank(asConstruction(T),I)
#define BINDERS(T,I) c_binders(asConstruction(T),I)
#define BINDER(T,I,BI) BINDERS(T,I)[BI]

#define DPROPERTY(N,V,P) c_property(N,V,P)
#define PROPERTY_P(T,P) DPROPERTY(asConstruction(T)->namedProperties, asConstruction(T)->variableProperties, P)
#define NAMED_PROPERTY_P(T,N) c_namedProperty(asConstruction(T)->namedProperties, N)
#define VARIABLE_PROPERTY_P(T,V) c_variableProperty(asConstruction(T)->variableProperties, V)
#define NAMED_PROPERTIES(T) (asConstruction(T)->namedProperties)
#define VARIABLE_PROPERTIES(T) (asConstruction(T)->variableProperties)

#define SYMBOL(T) (IS_VARIABLE_USE(T) ? VARIABLE(T)->name : c_name(asConstruction(T)))
#define TEXT(T) c_name(asConstruction(T))
#define LONGLONG(T) atoll(c_name(asConstruction(T)))
#define DOUBLE(T) atof(c_name(asConstruction(T)))
#define LENGTH(T) strlen(TEXT(T))

#define PROPERTY(T,P) c_deref(PROPERTY_P(T,P))
#define NAMED_PROPERTY(T,N)  c_deref(NAMED_PROPERTY_P(T,N))
#define VARIABLE_PROPERTY(T,V)  c_deref(VARIABLE_PROPERTY_P(T,V))

static inline Term c_deref(Term *p) { return (p ? *p : (Term)0); }

// Dummies to prevent warnings...
static inline int noop(void) { return 0; }
static inline void permitUnusedTerm(Term t) {}
static inline void permitUnusedTermP(Term *p) {}
static inline void permitUnusedInt(int i) {}
static inline void permitUnusedLong(long l) {}
static inline void permitUnusedVariable(Variable v) {}

// Representation.

// All term structures start with a pointer to a descriptor.
struct _Term
{
    ConstructionDescriptor descriptor; // of the term or NULL for variables
    ssize_t nr; // number of references to this term (node)
#ifdef CRSXPROF
    size_t marker; // counter helper for graph traversal.
#endif
};
// Pick Variable set representation

//#define SET_VSL

// VariableSetLink based

#ifdef SET_VSL

#define VARIABLESET VariableSetLink

#define LINK_VARIABLESET(C,S) LINK_VariableSetLink(C,S)
#define UNLINK_VARIABLESET(C,S) UNLINK_VariableSetLink(C,S)

#define VARIABLESET_REMOVEALL(C,S,V,L) removeAllL(C,S,V,L)
#define VARIABLESET_MERGEALL(C,S1,S2) mergeAllL(C,S1,S2)
#define VARIABLESET_ADDVARIABLE(C,S,V) addVariableL(C,S,V)
#define VARIABLESET_CONTAINS(S,V) containsL(S,V)
#define VARIABLESET_CLEAR(C,S) clearL(C,S)
#define VARIABLESET_MINUS(C,S,O) minusL(C,S,O)
#define VARIABLESET_PRINTF(C,O,S) printfL(C,O,S)
#define VARIABLESET_ISEMPTY(S) (S == NULL)
#define VARIABLESET_COUNT(S) countL(S)

#else

// Hash set based

#define VARIABLESET Hashset

#define LINK_VARIABLESET(C,S) LINK_Hashset(C,S)
#define UNLINK_VARIABLESET(C,S) UNLINK_Hashset(C,S)

#define VARIABLESET_REMOVEALL(C,S,V,L) removeAllHS(C,S,V,L)
#define VARIABLESET_MERGEALL(C,S1,S2) mergeAllHS(C,S1,S2)
#define VARIABLESET_ADDVARIABLE(C,S,V) addVariableHS(C,S,V)
#define VARIABLESET_CONTAINS(S,V) containsHS(S,V)
#define VARIABLESET_CLEAR(C,S) clearHS(C,S)
#define VARIABLESET_MINUS(C,S,O) minusHS(C,S,O)
#define VARIABLESET_PRINTF(C,O,S) printfHS(C,O,S)
#define VARIABLESET_ISEMPTY(S) ((S)== NULL || ((S) != AllFreeVariables && (S)->nitems == 0))
#define VARIABLESET_COUNT(S) ((S)== NULL ? 0 : (S)->nitems)
#define VARIABLESET_ADDVARIABLESOF(C, VS, S, CO, P) (addVariablesOfHS(C, VS, S, CO, P))

//#define VARIABLESET Hashset2
//
//#define LINK_VARIABLESET(C,S) linkHS2(S)
//#define UNLINK_VARIABLESET(C,S) unlinkHS2(C,S)
//
//#define VARIABLESET_REMOVEALL(C,S,V,L) removeAllHS2(C,S,(void**)V,L)
//#define VARIABLESET_MERGEALL(C,S1,S2) mergeAllHS2(C,S1,S2)
//#define VARIABLESET_ADDVARIABLE(C,S,V) addHS2(C,S,(void*)V)
//#define VARIABLESET_CONTAINS(S,V) containsHS2(S,(void*)V)
//#define VARIABLESET_CLEAR(C,S) clearHS2(C,S)
//#define VARIABLESET_MINUS(C,S,O) minusHS2(C,S,O)
//#define VARIABLESET_PRINTF(C,O,S) noop()
//#define VARIABLESET_ISEMPTY(S) ((S)== NULL || (S)->size == 0)
//#define VARIABLESET_COUNT(S) ((S)== NULL ? 0 : (S)->size)
//#define VARIABLESET_ADDVARIABLESOF(C, VS, S, CO, P) (addVariablesOfHS2(C, VS, S, CO, P))

#endif

// Reference counting: ALWAYS use these when storing or eliminating Term values.
//
// The following are the rules:
// * Every function and macro parameter of type Term is assumed to consume one reference to the term.
// * Every function parameter of type Term* is assumed to maintain the references to the term.
// * a new term created by BUFFER_TERM comes fully internally linked, and with one link to the top node.
// * a special case is the step() function which ONLY consumes the link it is passed if it returns true.
//
#define LINK_COUNT(T) ((T)->nr)
#define LINK(C,T) linkTerm(C, T)
extern Term linkTerm(Context context, Term term);

#define UNLINKSET(CONTEXT,T,V) ((--LINK_COUNT(T) ? T : freeTerm(CONTEXT,T)), (T)=V)
#define UNLINK(CONTEXT, T) (T=unlinkTerm(CONTEXT,T))
#define UNLINK_SUB(CONTEXT, T, I) UNLINK(CONTEXT, SUB(T, I))
extern void freeTerm(Context context, Term term);

static inline Term unlinkTerm(Context context, Term t)
{
	if (t->nr <= 0)
		assert(t->nr > 0);

	if ((--LINK_COUNT(t)) == 0)
	{
		freeTerm(context,t);
		return NULL;
	}
	return t;
}

// Variable added for variable use subterm.
struct _VariableUse
{
    struct _Term term; // extends Term but with term.descriptor==NULL
    Variable variable; // never NULL
};

// Construction has properties, weakenings, subterms, and binders (obtained by casting).
struct _Construction
{
    struct _Term term; // extends _Term with term.descriptor!=NULL

    // TODO: merge into 1 field
    unsigned int nf : 1; // whether subterm known to be normal form
    unsigned int nostep : 1; // whether function construction subterm known to not currently be steppable

    NamedPropertyLink namedProperties; // named properties. First link always contains set of free variables (unless all properties are closed)
    VariablePropertyLink variableProperties; // variable properties. First link always contains set of free variables (never closed)
#ifdef WEAKENINGS
    VariableSetLink weakenings; // free binders known to not occur in subterm (including properties)
#endif
#ifdef FREEVARS
    VARIABLESET fvs;  // free variables known to occur in subterm (excluding properties)
    VARIABLESET nfvs; // free variables known to occur in named properties (on this construction and subterms)
    VARIABLESET vfvs; // free variables known to occur in variable properties (on this construction and subterms)
#endif
    Term sub[]; // subterms -- actual size is ARITY(term)
    // Variable binder[]; // binders -- actual size is term->descriptor->binderoffset[ARITY(term)]
};

#ifdef FREEVARS

// Helper computing free variables from child terms.
extern void propagateFreeVariables(Context context, Term term);

extern VARIABLESET AllFreeVariables;

#endif

// Helper adding modified location properties.
extern void passLocationProperties(Context context, Term locTerm, Term term);

// For constants and basic constructors.
struct _ConstantConstruction
{
    struct _Construction construction; // extends Construction
};

struct _Literal // only strings
{
    struct _Construction construction; // extends Construction but with .term.sort==NULL
    const char *text;
};

// Construction term internals.
//
// Description of specific construction:
// - The construction has arity subterms
// - The n'th subterm (from 0) scopes binders binderoffset[n] up to (but not including) binderoffset[n+1]
// - The sub and binder functions return individual subterm and binder
// - Finally, provides the mechanism for accessing the properties of associated terms.
//
struct _ConstructionDescriptor
{
    SortDescriptor sort; // result sort for descriptor (NULL for polymorphic constructors)
    int sortoffset; // current descriptor tag offset in sort (>0 for data, 0 for functions)
    int arity; // number of subterms
    int size; // sizeof instances of the constructor
    int *binderoffset; // offset in binder list of first binder for each argument; for length = arity+1
    char *(*name)(Term term); // of descriptor
    int (*step)(Sink sink, Term term); // rewrite the term to get closer to a top level data descriptor and return whether an updated term was sent to sink
};

//#define CRSX_CHECK_SORT(CONTEXT,T,SORT) ASSERT(CONTEXT, IS_VARIABLE_USE(T) || !(T)->descriptor->sort  ||  (T)->descriptor->sort == (SORT))
#define CRSX_CHECK_SORT(CONTEXT,T,SORT) noop()

// Casting helpers.
//static inline VariableUse asVariableUse(Term term) { return (VariableUse) term; }
#define asVariableUse(term) ((VariableUse) term)
//static inline Construction asConstruction(Term term) { return (Construction) term; }
#define asConstruction(term) ((Construction) term)
//static inline Literal asLiteral(Term term) { return (Literal) term; }
#define asLiteral(term) ((Literal) term)

// Construction helpers.
//static inline char *c_name(Construction c) {ConstructionDescriptor d = c->term.descriptor; return d->name(&(c->term)); }
#define c_name(c)      (c->term.descriptor->name(&(c->term)))
// Does *not* create a new reference
#define c_subp(c,i)    (&(c->sub[i]))

//static inline Variable *c_binders(Construction c, int i) { ConstructionDescriptor d = c->term.descriptor; int a = d->arity; Variable *bs = (Variable *) &(c->sub[a]); return &(bs[d->binderoffset[i]]); }
#define c_binders(c,i) (&(((Variable *) &(c->sub[c->term.descriptor->arity]))[c->term.descriptor->binderoffset[i]]))
//static inline int c_rank(Construction c, int i) { ConstructionDescriptor d = c->term.descriptor; return (d->binderoffset[i+1] - d->binderoffset[i]); }
#define c_rank(c,i)    (c->term.descriptor->binderoffset[i+1] - c->term.descriptor->binderoffset[i])

// Constant descriptors used for literals.

// Use when arity is zero.
extern int noBinderOffsets[];
extern Term *noSub(Term term, int n);
extern Variable *noBinders(Term term, int n);

// Generic components of ConstructionDescriptors.
extern char *dataName(Term term);
extern int dataStep(Sink sink, Term term);

// Description of sort.
//
struct _SortDescriptor
{
    char *name; // of sort
    ConstructionDescriptor *constructors; // NULL-terminated array of data constructors
    char **constructorNames; // NULL-terminated array of corresponding data constructor names
    char **constructorInternalNames; // NULL-terminated array of corresponding internal data constructor names (for START and END macro *generation*)
    SortDescriptor previous;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// VARIABLES

// Creating a globally unique variable.
//
// Usage:
//   Variable variable = MAKE_*_VARIABLE(context, "name_candidate");
//
// Variables are compared as pointers with ==.  The name is a guideline and may be ignored.
//
#define MAKE_BOUND_PROMISCUOUS_VARIABLE(context,v) makeVariable(context,v,1,0)
#define MAKE_FRESH_PROMISCUOUS_VARIABLE(context,v) makeVariable(context,v,0,0)
#define MAKE_BOUND_LINEAR_VARIABLE(context,v) makeVariable(context,v,1,1)
#define MAKE_FRESH_LINEAR_VARIABLE(context,v) makeVariable(context,v,0,1)
//
struct _Variable
{
    char *name; // name...neither guaranteed to be globally unique nor the same as originally provided
    unsigned int linear : 1; // whether this variable is linear
    unsigned int bound : 1; // whether this variable is bound
#ifdef BFREEVARS
    unsigned hash;
#endif
};
extern Variable makeVariable(Context context, char *name, unsigned int bound, unsigned int linear);

#define IS_BOUND(v) ((v)->bound)
#define IS_LINEAR(v) ((v)->linear)

// Used when reusing bound variables as fresh or different bound variables.
#define UNBIND(variable) (variable)->bound = 0
#define REBIND(variable) (variable)->bound = 1

extern void setVariableBaseName(Context context, Variable variable, char *newbase);

/////////////////////////////////////////////////////////////////////////////////
// Literal allocation.

extern Term makeStringLiteral(Context context, const char *text);

///////////////////////////////////////////////////////////////////////////////////////////////////
// CREATING TERMS
//
// Term creation events.
//
// Usage:
//   Sink sink = ...;
//   START(sink,constructorName);
//   END(sink,constructorName);
//   USE(sink,variable);
//   BINDS(sink,rank,variableArray);
//
//   LITERAL(sink,text);
//   LITERALF(sink,fmt,...);
//   LITERALNF(sink,size,fmt,...);
//
//   ADD_PROPERTY_REF(sink,term);
//   ADD_PROPERTY_NAMED(sink,name,term);
//   ADD_PROPERTY_VARIABLE(sink,variable,term);
//   ADD_PROPERTY_WEAKEN(sink,variable);
//   PROPERTIES_RESET(sink);
//
//   WEAKEN(sink,variable);
//
//   COPY(sink,term);
//
// where in each case the sink is obtained with one of the methods described below,
// the constructorName is a MANGLED constructor name defined by the RulesCompiler output, and
// all Variable arguments must be made with one of the MAKE_*_VARIABLE variants.
//
// The events do the following:
// - START(sink,constructorName): Emit start event for construction with constructor with (mangled*)
//      constructorName.
// - END(sink,constructorName): Emit end event for construction started with START(sink,constructorName).
// - LITERAL(sink,text): Emit start and end event for unsorted constant construction with text as (unmangled) constructor
// - LITERALU(sink,text): Variant ('unsafe') for constant or pre-ALLOCATEd text.
// - LITERALF(sink,fmt,...): Same as LITERAL except the string is composed safely using vsnprintf(3) (using a large stack-allocated temp buffer).
// - LITERALNF(sink,maxsize,fmt,...): Same as LITERAL except the string is composed using vsnprintf(3).
// - USE(sink,v): Emit variable use event for previously allocated Variable v.
// - BINDS(sink,rank,vs): Emit binder event for previously allocated array Variable vs[rank] (which is copied and thus can be automatic).
// - ADD_PROPERTY_REF(sink,term): copy properties from term into the next START. Term reference is *NOT* transferred
// - ADD_PROPERTY_NAMED(sink,name,term): add named property with value into the next START. Term reference is transferred
// - ADD_PROPERTY_VARIABLE(sink,variable,term): add variable property with value into the next START. Term reference is transferred
//   ADD_PROPERTY_WEAKEN(sink,variable): add the specified variables list to the list of impossible free variables in properties with next START.
// - COPY(sink,term): copies the term to the sink.
//
// Note: Properties events are given "inside-out" so typically like this
//   ADD_PROPERTY_REF(sink,x); ADD_PROPERTY_WEAKEN(sink,var_not_in_x); ADD_PROPERTY_VAIRABLE(sink,var_not_in_x,value);...
//
// Furthermore, each event returns 1 except if it is known that no other events sent to the sink will
// have any affect, where 0 is returned instead (permits using &&-chains for event creation).
//
#define START(sink,c) ((sink) ? ((Sink)(sink))->start(sink, &descriptor##c) : NULL)
#define END(sink,c) ((sink) ? ((Sink)(sink))->end(sink, &descriptor##c) : NULL)
#define USE(sink,variable) ((sink) ? ((Sink)(sink))->use(sink, variable) : NULL)
#define BINDS(sink,rank,binders) ((sink) ? ((Sink)(sink))->binds(sink, rank, binders) : NULL)

#define COPY(sink,term) ((sink) ? ((Sink)(sink))->copy(sink, term) : NULL)
#define COPYC(sink,term,ccount) COPY(sink,term)

#define LITERALU(sink,text) ((sink) ? ((Sink)(sink))->literal(sink, text) : NULL)
//#define LITERAL(sink,text) LITERALU(sink, GLOBAL((sink)->context, text))
#define LITERAL(sink,text) LITERALU(sink, text)

#define LITERALF_SIZE_LIMIT 10000
#define LITERALF(sink,...) LITERALU(sink,ALLOCATENF((sink)->context, (size_t) LITERALF_SIZE_LIMIT, __VA_ARGS__))
#define LITERALNF(sink,maxsize,...) LITERALU(sink, ALLOCATENF((sink)->context, maxsize, __VA_ARGS__))

#define ADD_PROPERTIES(sink,namedProperties,variableProperties) ((Sink)(sink))->properties(sink,namedProperties,variableProperties)
#define ADD_PROPERTY_REF(sink,construction) ((Sink)(sink))->propertyRef(sink, asConstruction(construction))
#define ADD_PROPERTY(sink,P,value) (IS_VARIABLE_USE(P) ? ADD_PROPERTY_VARIABLE(sink, VARIABLE(P), value) : ADD_PROPERTY_NAMED(sink, SYMBOL(P), value))
#define ADD_PROPERTY_NAMED(sink,name,value) ((Sink)(sink))->propertyNamed(sink, name, value)
#define ADD_PROPERTY_VARIABLE(sink,variable,value) ((Sink)(sink))->propertyVariable(sink, variable, value)
#define ADD_PROPERTY_WEAKEN(sink,variable) ((Sink)(sink))->propertyWeaken(sink, variable)
#define PROPERTIES_RESET(sink) ((Sink)(sink))->propertiesReset(sink)

#define WEAKEN(sink,variable) ((Sink)(sink))->weaken(sink, variable)

#define WEAKENINGS_OF(sink,term) weakenings_of(sink, term)
#define WEAKENINGS_COPY(context,source,target) weakenings_copy(context, source, target)
extern void weakenings_of(Sink sink, Term term);
extern void weakenings_copy(Context context, Term source, Term target);

// A Sink is a generic event handler for capturing terms.
//
typedef enum { SINK_UNDEFINED, SINK_IS_BUFFER, SINK_IS_SHOW } SinkKind;
struct _Sink
{
    SinkKind kind;  // the kind of Sink...to permit sanity checks before casts.
    Context context; // context used for internal allocations
    Term (*term)(Sink sink); // Extract the term of the captured (and possibly step'd) term

    Sink (*start)(Sink sink, ConstructionDescriptor descriptor); // start event
    Sink (*end)(Sink sink, ConstructionDescriptor descriptor); // end event
    Sink (*literal)(Sink sink, const char *text); // literal event. Text reference is *not* transferred
    Sink (*use)(Sink sink, Variable variable); // use event
    Sink (*binds)(Sink sink, int rank, Variable binds[]); // binds event
    Sink (*copy)(Sink sink, Term term); // copy term as event(s)

    Sink (*weakeningRef)(Sink sink, Construction construction); // base weakenings for next START
    Sink (*weaken)(Sink sink, Variable variable); // weaken following term to *not* permit variable

    Sink (*propertyRef)(Sink sink, Construction construction); // base properties for next START
    Sink (*properties)(Sink sink, NamedPropertyLink namedProperties, VariablePropertyLink variableProperties); // base properties for next START

    Sink (*propertyNamed)(Sink sink, const char *name, Term term); // add named property to next START
    Sink (*propertyVariable)(Sink sink, Variable variable, Term term); // add variable property to next START
    Sink (*propertyWeaken)(Sink sink, Variable variable); // add properties weakening to *preceding* properties for next START
    Sink (*propertiesReset)(Sink sink); // reset property state
};

#define SINK_IS_BUFFER(sink) (((Sink)(sink))->kind == SINK_IS_BUFFER)

#define BUFFER_SEGMENT_SIZE 127

typedef struct _Buffer *Buffer;
typedef struct _BufferEntry *BufferEntry;
typedef struct _BufferSegment *BufferSegment;
struct _Buffer
{
    struct _Sink sink; // the sink (including the kind, embedded FIRST to allow casting)
    Term term; // the term collected by the buffer (after it is done)
    BufferSegment first; // the first segment; all allocated segments available through segment ->next chain TODO: include first segment here!
    BufferSegment last; // the last segment (with top of stack in it) or NULL when empty
    int lastTop; // index of top entry (in last segment) or <0 when empty
    VariableSetLink pendingWeakenings; // weakenings for next START (NOTE: cannot be shared)
    NamedPropertyLink pendingNamedProperties; // named properties for next START (NOTE: cannot be shared)
    VariablePropertyLink pendingVariableProperties; // variable properties for next START (NOTE: cannot be shared)
#ifdef FREEVARS
    VARIABLESET pendingNamedPropertiesFreeVars; // Free variables to insert before a batch of new named properties
    VARIABLESET pendingVariablePropertiesFreeVars; // Free variables to insert before a batch of new variable properties
#endif
    unsigned free : 1; // whether the buffer structure itself should be freed
};
struct _BufferEntry
{
    Term term; // allocated partial construction
    int index; // subterm we are working on
#ifdef FREEVARS
    VARIABLESET freeVars; // subterm free variables
#endif
};
struct _BufferSegment
{
    BufferSegment previous, next; // previous and next buffer segment (NULL for first/last)
    struct _BufferEntry entry[BUFFER_SEGMENT_SIZE];
};


// Create a buffer to accumulate a term.
// Extract built term from buffer, once it has finished.
// Free the buffer.
//
// Usage:
//   Sink sink = MAKE_BUFFER(context); //allocated buffer of dynamic size
//   Term result = BUFFER_TERM(sink); //sink was created previuosly by MAKE_BUFFER...ONLY USE ONCE
//   FREE_BUFFER(sink);
//
#ifndef MAKE_BUFFER
#define MAKE_BUFFER(context) initBuffer(context, (Buffer) ALLOCATE(context, sizeof(struct _Buffer)), 1)
#endif
#ifndef BUFFER_TERM
#define BUFFER_TERM(sink) bufferTerm(sink)
#endif
#ifndef FREE_BUFFER
#define FREE_BUFFER(sink) freeBuffer(sink)
#endif
extern Sink initBuffer(Context context, Buffer buffer, int free);
extern Term bufferTerm(Sink sink);
extern void freeBuffer(Sink sink);
//
#ifndef ALLOCA_BUFFER
//#define ALLOCA_BUFFER(context) initBuffer(context, (Buffer) ALLOCA(context, sizeof(struct _Buffer)), 0)
#define ALLOCA_BUFFER(context) initBuffer(context, (Buffer) ALLOCATE(context, sizeof(struct _Buffer)), 1)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
// EVALUATION
//
// Usage:
//   FORCE(context, term); // term MUST BE LValue
//   NORMALIZE(context, termp);

#ifndef FORCE
# define FORCE(CONTEXT,T) (T = (IS_NOSTEP(T) ? (T) : force(CONTEXT, T)))
#endif
#ifndef NORMALIZE
# define NORMALIZE(CONTEXT,T) normalize(CONTEXT, &T)
#endif
extern Term force(Context context, Term term);
extern void normalize(Context context, Term *termp);

// Obsolete:
#ifndef COMPUTE
# define COMPUTE(CONTEXT,T) (T = (IS_NF(T) ? (T) : compute(CONTEXT,T)))
#endif
extern Term compute(Context context, Term term);

///////////////////////////////////////////////////////////////////////////////////////////////////
// SUBSTITUTE
//
// Usage:
// - SUBSTITUTE(sink,T,frame) sends a copy of term T to the sink except as substituted by frame;
//   Note that T must be an lvalue.

struct _SubstitutionFrame
{
    SubstitutionFrame parent;  // parent frame (or NULL)
    int parentCount;           // number of variable-substitute pairs in all parent frames
    int count;                 // number of variable-substitute pairs in this frame
    Variable *variables;       // count redex variables to substitute, in order
    Term *substitutes;         // count redex subterms to substitute for variables, in order
    int* renamings;            // Whether substitute is caused by a binder renaming.
};

#define RENAME_ALL ((int*) 1)

#ifndef SUBSTITUTE
# define SUBSTITUTE(sink,term,substitution) metaSubstitute(sink, term, substitution)
#endif
extern void metaSubstitute(Sink sink, Term term, SubstitutionFrame substitution);

///////////////////////////////////////////////////////////////////////////////////////////////////
// PROPERTIES


extern Term *c_namedProperty(NamedPropertyLink link, char *name);
extern Term *c_variableProperty(VariablePropertyLink link, Variable variable);
static inline Term *c_property(NamedPropertyLink namedProperties, VariablePropertyLink varProperties, Term key)
{
    return (IS_VARIABLE_USE(key) ? c_variableProperty(varProperties, VARIABLE(key)) : c_namedProperty(namedProperties, SYMBOL(key)));
}

struct _NamedPropertyLink
{
    NamedPropertyLink link;
    int nr;
    const char* name;
    union {
        Term term; // when name != NULL
        Variable weakening; // when name == NULL - indicates context-bound variable known to not occur
    } u;
#ifdef CRSXPROF
    size_t marker; // counter helper for graph traversal.
#endif
};
#define LINK_NamedPropertyLink(C,L) linkNamedPropertyLink(C,L)
extern NamedPropertyLink linkNamedPropertyLink(Context context, NamedPropertyLink link);

#define UNLINKSET_NamedPropertyLink(CONTEXT,L,V) (({if (L) --(L)->nr;}), L=V)

// Property list is not closed when the first element is a list of free variable
#define IS_PROPERTY_CLOSED(P) ((P)->name != NULL)

#ifdef FREEVARS

static inline VARIABLESET namedPropertyFreeVars(NamedPropertyLink link)
{
	if (link && !link->name)
		return (VARIABLESET) link->u.weakening;

	return NULL;
}

#endif

extern NamedPropertyLink UNLINK_NamedPropertyLink(Context context, NamedPropertyLink link);

struct _VariablePropertyLink
{
    VariablePropertyLink link;
    int nr;
    Variable variable;
    union {
        Term term; // when variable != NULL
        Variable weakening; // when variable == NULL - indicates context-bound variable known to not occur
    } u;
#ifdef CRSXPROF
    size_t marker; // counter helper for graph traversal.
#endif
};


#ifdef FREEVARS

static inline VARIABLESET variablePropertyFreeVars(VariablePropertyLink link)
{
	if (link && !link->variable)
		return (VARIABLESET) link->u.weakening;

	return NULL;
}

#endif


static inline VariablePropertyLink LINK_VariablePropertyLink(Context context, VariablePropertyLink link) { if (link) ++(link->nr); return link; };
#define UNLINKSET_VariablePropertyLink(CONTEXT,L,V) (({if (L) --(L)->nr;}), L=V)

extern VariablePropertyLink UNLINK_VariablePropertyLink(Context context, VariablePropertyLink link);

///////////////////////////////////////////////////////////////////////////////////////////////////
// CONSTANT SET OF VARIABLES.

struct _Variables
{
    size_t size;
    Variable variables[]; // of length count
};
// Create fixes size variable array; seeds array by copying pointers from originals.
extern Variables variablesMake(Context context, size_t size, Variable originals[]);
// Check whether array contains a variable.
extern int variablesContain(Variables vs, Variable v);

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERIC VARIABLE SETS AND MAPS

struct _VariableSet
{
    VariableSetLink link;
    Context context;
};

struct _VariableSetLink
{
	unsigned nr; // Number of references. Used for copy-and-write.
    VariableSetLink link;
    Variable variable;
};

static inline VariableSetLink LINK_VariableSetLink(Context context, VariableSetLink link)
{
	if (link)
	{
		assert(link->nr > 0);

		++(link->nr);
		return link;
	}
	return NULL;
};

extern VariableSetLink UNLINK_VariableSetLink(Context context, VariableSetLink link);

// Make variable set.
extern VariableSet makeVariableSet(Context context);
// Add variable to set; returns 1 if variable actually added.
extern int addVariable(VariableSet set, Variable variable);
// Check whether set contains a variable.
extern int containsVariable(VariableSet set, Variable variable);
// Release variable set.
extern void freeVariableSet(VariableSet set);

// Check whether variable array contains a variable.
extern int containsAL(Variable* vars, int len, Variable variable);

// Copy-on-write linked list set

// Copy variable set.
extern VariableSetLink copyL(Context context, VariableSetLink set);
// Count variable set links.
extern unsigned countL(VariableSetLink set);
// Add variable to set. Create new set if needed.
extern VariableSetLink addVariableL(Context context, VariableSetLink set, Variable variable);
// Check whether set contains a variable.
extern int containsL(VariableSetLink set, Variable variable);
// Check whether set contains a variable of given name. Debugging use only
extern int containsNameL(VariableSetLink link, char* name);
// Check whether variable links list contains a variable and returns the link (no ref transferred), or NULL
extern VariableSetLink variableSetLinkFor(VariableSetLink link, Variable variable);
// Merge the two sets. Both references are transferred.
extern VariableSetLink mergeAllL(Context context, VariableSetLink first, VariableSetLink second);
// Remove all variables contains in other from set. 'set' reference is transferred. 'other' is not transferred.
extern VariableSetLink minusL(Context context, VariableSetLink set, VariableSetLink other);
// Remove all given variables from set. 'set' reference is transferred.
extern VariableSetLink removeAllL(Context context, VariableSetLink set, Variable* vars, int len);
// Compute intersection
extern VariableSetLink intersectL(Context context, VariableSetLink set, VariableSetLink other);
// Compute intersection
extern VariableSetLink intersectGL(Context context, VariableSetLink set, VariableSetLink other, VariableSetLink* removed);
// Clear set
extern VariableSetLink clearL(Context context, VariableSetLink set);
// Print out set
extern void printfL(Context context, FILE* out, VariableSetLink set);


// Copy-on-write hash set

struct _Hashset {
	unsigned nr;
#ifdef CRSXPROF
	size_t marker;
#endif
    size_t nbits;
    size_t mask;

    size_t capacity;
    size_t *items;
    size_t nitems;
};

typedef struct _LinkedList2* LinkedList2;

struct _LinkedList2 {
	void *entry;
	LinkedList2 next;
};

struct _Pair {
	void* key;
	void* value;
};


struct _Hashset2
{
	size_t nr;		// Number of references
	size_t nbits;	// Number of bits for nslots
	size_t nslots;	// Number of entry slots. Always nbits ^ 2
	size_t size;	// Number of entries

	LinkedList2 *entries;	// Array of entries. Size of array = nslots
};

// Increment reference count
static inline Hashset2 linkHS2(Hashset2 set)
{
	if (set) ++(set->nr); return set;
}
// Decrement reference count
extern Hashset2 unlinkHS2(Context context, Hashset2 set);
// Allocate set
extern Hashset2 makeHS2(Context context, int numbits);
// Copy set.
extern Hashset2 copyHS2(Context context, Hashset2 set);
// Add entry to set. Create new set if needed.
extern Hashset2 addHS2(Context context, Hashset2 set, void* entry);
// Add value of given string key to set. Create new set if needed.
extern Hashset2 addValueHS2(Context context, Hashset2 set, const char* key, void* value);
// Get value for given string key
extern void* getValuePtrHS2(Hashset2 set, const char* key);
// Add value of given pointer key to set. Create new set if needed.
extern Hashset2 addKeyPtrValueHS2(Context context, Hashset2 set, void* key, void* value);
// Get value for given pointer key
extern void* getKeyPtrValuePtrHS2(Hashset2 set, void* key);
// Remove entry to set.
extern Hashset2 removeHS2(Context context, Hashset2 set, void* entry);
// Check whether set contains the given entry.
extern int containsHS2(Hashset2 set, void* entry);
// Merge the two sets. Both references are transferred.
extern Hashset2 mergeAllHS2(Context context, Hashset2 first, Hashset2 second);
// Remove all entrios contains in other from set. 'set' reference is transferred. 'other' is not transferred.
extern Hashset2 minusHS2(Context context, Hashset2 set, Hashset2 other);
// Remove all given entries from set. 'set' reference is transferred.
extern Hashset2 removeAllHS2(Context context, Hashset2 set, void** vars, ssize_t len);
// Clear set
extern Hashset2 clearHS2(Context context, Hashset2 set);
// Enumerate set as old-fashioned VariableSet
extern void addVariablesOfHS2(Context context, VariableSet vars, Hashset2 set, int constrained, VariablePropertyLink props);


static inline Hashset LINK_Hashset(Context context, Hashset set) { if (set && set != AllFreeVariables) ++(set->nr); return set; };
extern Hashset UNLINK_Hashset(Context context, Hashset set);

// Allocation variable set.
extern Hashset makeHS(Context context);
// Copy variable set.
extern Hashset copyHS(Context context, Hashset set);
// Add variable to set. Create new set if needed.
extern Hashset addVariableHS(Context context, Hashset set, Variable variable);
// Remove variable from set. 'set' reference is transferred.
extern Hashset removeVariableHS(Context context, Hashset set, Variable var);
// Check whether set contains a variable.
extern int containsHS(Hashset set, Variable variable);
// Merge the two sets. Both references are transferred.
extern Hashset mergeAllHS(Context context, Hashset first, Hashset second);
// Remove all variables contains in other from set. 'set' reference is transferred. 'other' is not transferred.
extern Hashset minusHS(Context context, Hashset set, Hashset other);
// Remove all given variables from set. 'set' reference is transferred.
extern Hashset removeAllHS(Context context, Hashset set, Variable* vars, int len);
// Clear set
extern Hashset clearHS(Context context, Hashset set);
// Enumerate set as old-fashioned VariableSet
extern void addVariablesOfHS(Context context, VariableSet vars, Hashset set, int constrained, VariablePropertyLink props);
// Print out set
extern void printfHS(Context context, FILE* out, Hashset set);


struct _VariableSet2
{
	Context context;
    size_t flags; 	/** See below */

    union
    {
    	struct _Hashset2 hash;
    } set;
};


// Link-list based map

struct _VariableMap
{
    VariableMapLink link;
    Context context;
};
struct _VariableMapLink
{
    VariableMapLink link;
    Variable key;
    Variable value;
};
// Create variable map.
extern VariableMap makeVariableMap(Context context);
// Add mapping.
extern void addVariableMap(VariableMap map, Variable key, Variable value);
// Lookup the variable in the map, and return the name or NULL if none.
extern Variable lookupVariable(VariableMap map, Variable variable);
// Pop the latest n entries added to the variable map.
extern void popVariableMap(VariableMap map, int n);
// Release variable map.
extern void freeVariableMap(VariableMap map);

struct _VariableNameMapLink
{
    VariableNameMapLink link;
    char *key;
    Variable value;
};
// Add link.
extern VariableNameMapLink addNameMapLink(Context context, VariableNameMapLink parent, char *name, Variable variable);
// Search stack of links.
extern Variable lookupNameLink(VariableNameMapLink link, char *name);
// Free entire stack (but not the linked values).
extern void freeVariableNameMapLinks(Context context, VariableNameMapLink link);

///////////////////////////////////////////////////////////////////////////////////////////////////
// PRINTING

extern void printTerm(Context context, Term term);
extern void printTermWithIndent(Context context, Term term);
extern void fprintTerm(Context context, FILE* out, Term term);
extern void fprintTermWithIndent(Context context, FILE* out, Term term);
extern void printTermFullWithIndent(Context context, Term term);
extern void ppt(Context context, int nesting, Term term);
extern void pt(Context context, Term term);

extern void fprintTermTop(Context context, FILE* out, Term term, int depth, VariableSet encountered, Hashset2 used, int indent, int *positionp, int includeprops, int debug);
extern void fprintFreeVars(Context context, FILE* out, VARIABLESET freeVars);

extern char* fprintNamedProperties(Context context, FILE* out, NamedPropertyLink namedProperties, char* sep, int depth, VariableSet encountered, Hashset2 used, int indent, int *positionp, int debug, int max);
extern char* fprintVariableProperties(Context context, FILE* out, VariablePropertyLink variableProperties, char* sep, int depth, VariableSet encountered, Hashset2 used, int indent, int *positionp, int debug, int max);

extern void printCTerm(Context context, Term term);

///////////////////////////////////////////////////////////////////////////////////////////////////
// AUXILIARY SORT STRUCTURES

// Last sort descriptor in ->previous chain.
extern SortDescriptor lastSortDescriptor;

// Structure for generated lookup function.
struct _SymbolDescriptor
{
    char* symbol;
    ConstructionDescriptor descriptor;
};
typedef struct _SymbolDescriptor *SymbolDescriptor;

// Special macro for crsx_scan.l: see sample Makefile for how to generate the required symbol table!
#ifndef LOOKUP_DESCRIPTOR 
# define LOOKUP_DESCRIPTOR(context,name) lookupSymbolTableDescriptor(context, symbolDescriptorTable, symbolDescriptorCount, name)
  extern size_t symbolDescriptorCount;
  extern struct _SymbolDescriptor symbolDescriptorTable[];
#endif
extern ConstructionDescriptor lookupSymbolTableDescriptor(Context context, SymbolDescriptor table, size_t size, const char *symbol);

///////////////////////////////////////////////////////////////////////////////////////////////////
// MISCELLANEOUS

// Add all free variables in term to free set. If constrained set then only include variables included in props.
extern VariableSet makeFreeVariableSet(Context context, Term term, SortDescriptor sort, int constrained, VariablePropertyLink props);

// Check if two terms are equal module renaming of bound variables.
extern int deepEqual(Context context, Term term1, Term term2);

// Check that a term structure is well defined and return the size.
extern int check(Context context, Term term);

// Check free variable set is correct
void checkFreeVariables(Context context, Term term);


// Truth values.
extern const char *True;
extern const char *False;

// Empty list.
extern const char *Nil;

///////////////////////////////////////////////////////////////////////////////////////////////////
// BIT SET MANAGEMENT

#ifndef MAKE_SET_BITS

#define BITS_MAX_SIZE (sizeof(BITS)*8)
#define NO_BITS 0ULL
#define ONE_BITS 1ULL
#define MAKE_BITS(context,size) CHECKF(context, (size) <= BITS_MAX_SIZE, NO_BITS, Msg, "Nested Variable Overflow", XSLJIT_XJOOM, NULL, NULL, NULL, "")
#define MAKE_SET_BITS(context,size) CHECKF(context, (size) <= BITS_MAX_SIZE, ((~NO_BITS) >> (BITS_MAX_SIZE - (size))), Msg, "Nested Variable Overflow", XSLJIT_XJOOM, NULL, NULL, NULL, "")
#define COPY_BITS(context,bitset,size) CHECKF(context, (size) <= BITS_MAX_SIZE, bitset, Msg, "Nested Variable Overflow", XSLJIT_XJOOM, NULL, NULL, NULL, "")
#define ADD_BITS(bitset,bitset2) ((bitset) |= (bitset2))
#define MASK_BITS(bitset,bitset2) ((bitset) &= (bitset2))
#define BIT(bitset,index) (((bitset) >> (index)) & ONE_BITS)
#define ANY_BITS(bitset) ((bitset) != NO_BITS)
#define AND_BITS(bitset1,bitset2) ((bitset1)&(bitset2))
#define OR_BITS(bitset1,bitset2) ((bitset1)|(bitset2))
#define XOR_BITS(bitset1,bitset2) ((bitset1)^(bitset2))
#define SET_BIT(bitset,index) ((bitset) |= (ONE_BITS << (index)))
#define CLEAR_BIT(bitset,index) ((bitset) &= ~(ONE_BITS << (index)))
#define FREE_BITS(context,bitset) noop()

#endif


#define ASIZE(size) ((size / BITS_MAX_SIZE) + 1)
#define BSIZE(size) (size % BITS_MAX_SIZE)
#define AINDEX(index) (index / BITS_MAX_SIZE)
#define BINDEX(index) (index % BITS_MAX_SIZE)

#define MAKE_SET_LBITS(context, bitset, size) (bitset)->bits = ALLOCA(context, ASIZE(size)*sizeof(BITS)); makeSetBits(bitset, size)
#define COPY_LBITS(context, dst, size, src) (dst)->bits = ALLOCA(context, ASIZE(size)*sizeof(BITS)); copyBits(context, dst, size, src)
#define MASK_LBITS(bitset,bitset2) maskBits(bitset,bitset2)
#define LBIT(bitset,index) lbit(bitset, index)
#define ANY_LBITS(bitset) anyBits(bitset)
#define SET_LBIT(bitset,index) setBit(bitset, index)
#define CLEAR_LBIT(bitset,index) clearBit(bitset, index)
#define FREE_LBITS(context,bitset) noop()

static inline unsigned lbit(BitSetP bitset, unsigned index)
{
	return bitset->bits[AINDEX(index)] >> (BINDEX(index) & ONE_BITS);
}

static inline void setBit(BitSetP bitset, unsigned index)
{
	assert(index < bitset->size);

	unsigned ai = AINDEX(index);
	unsigned bi = BINDEX(index);
	BITS newbits = bitset->bits[ai] | (ONE_BITS << bi);
	bitset->bits[ai] = newbits;
}

static inline void clearBit(BitSetP bitset, unsigned index)
{
	assert(index < bitset->size);

	unsigned ai = AINDEX(index);
	unsigned bi = BINDEX(index);
	BITS newbits = bitset->bits[ai] & (~(ONE_BITS << bi));
	bitset->bits[ai] = newbits;
}

static inline void makeSetBits(BitSetP bitset, unsigned size)
{
	// Set all bits
	bitset->size = size;
	const int asize = ASIZE(size);

	int i = asize - 2;
	for (; i >= 0; i --)
		bitset->bits[i] = (~NO_BITS);

	bitset->bits[asize - 1] = (~NO_BITS) >> (BITS_MAX_SIZE - (BSIZE(size)));
}

static inline void copyBits(Context context, BitSetP dst, unsigned size, BitSetP src)
{
	assert(size >= src->size);

	dst->size = size;
	memset((void*)dst->bits, 0, ASIZE(size)*sizeof(BITS));
	memcpy((void*)dst->bits, (void*)src->bits, ASIZE(src->size)*sizeof(BITS));
}

static inline void maskBits(BitSetP bitset1, BitSetP bitset2)
{
	int i = ASIZE(bitset1->size) - 1;
	for (; i >= 0; i --)
		bitset1->bits[i] &= bitset2->bits[i];
}

static inline int anyBits(BitSetP bitset)
{
	int i = ASIZE(bitset->size) - 1;
	for (; i >= 0; i --)
		if (bitset->bits[i]) return 1;
	return 0;
}

// Bitset set

// Allocate variable set.
extern void makeB(Context context, BitSetP bitset, unsigned size);
// Copy variable set.
extern void copyB(BitSetP src, BitSetP dst);
// Add variable to set. Create new set if needed.
extern void addVariableB(BitSetP set, Variable variable);
// Check whether set contains a variable. Might return false positive (variable might actually not in the set)
extern int containsB(BitSetP set, Variable variable);
// Merge the two sets.
extern void mergeAllB(BitSetP first, BitSetP second);

///////////////////////////////////////////////////////////////////////////////////////////////////
// STACK OF MEMORY-MANAGED SEGMENTS
//
// Usage:
//   SETUP_STACK_TYPE(T)
//
// Expands to declarations of a new type of pointer, TStack, with the following static functions:
//
// TStack makeTStack(Context) - create empty stack of T elements
// int emptyTStack(TStack)    - whether the stack is empty
// void pushT(TStack, T)      - push a T element onto a stack
// T* topT(TStack)            - pointer to the top element of non-empty stack
// void popT(TStack)          - pop the top element off non-empty stack
// void freeTStack(TStack)    - free the entire stack

#ifndef STACK_SEGMENT_SIZE
# define STACK_SEGMENT_SIZE 63
#endif
#define SETUP_STACK_TYPE(TYPE)                                                                          \
                                                                                                        \
  typedef struct _##TYPE##Stack *TYPE##Stack;                                                           \
  typedef struct _##TYPE##StackSegment *TYPE##StackSegment;                                             \
                                                                                                        \
  struct _##TYPE##Stack { Context context; TYPE##StackSegment last; int top; };                         \
  struct _##TYPE##StackSegment { TYPE##StackSegment previous; TYPE entry[STACK_SEGMENT_SIZE]; };        \
                                                                                                        \
  static TYPE##Stack make##TYPE##Stack(Context context)                                                 \
  {                                                                                                     \
      TYPE##Stack stack = ALLOCATE(context, sizeof(struct _##TYPE##Stack));                             \
      stack->context = context;                                                                         \
      stack->last = NULL;                                                                               \
      stack->top = -1;                                                                                  \
      return stack;                                                                                     \
  }                                                                                                     \
                                                                                                        \
  static int empty##TYPE##Stack(TYPE##Stack stack)                                                      \
  {                                                                                                     \
      return !stack->last;                                                                              \
  }                                                                                                     \
                                                                                                        \
  static void push##TYPE(TYPE##Stack stack, TYPE value)                                                 \
  {                                                                                                     \
      ++stack->top;                                                                                     \
      if (!stack->last || stack->top >= STACK_SEGMENT_SIZE)                                             \
      {                                                                                                 \
          TYPE##StackSegment segment = ALLOCATE(stack->context, sizeof(struct _##TYPE##StackSegment));  \
          segment->previous = stack->last;                                                              \
          stack->last = segment;                                                                        \
          stack->top = 0;                                                                               \
      }                                                                                                 \
      stack->last->entry[stack->top] = value;                                                           \
  }                                                                                                     \
                                                                                                        \
  static void pop##TYPE(TYPE##Stack stack)                                                              \
  {                                                                                                     \
      --stack->top;                                                                                     \
      if (stack->top < 0 && stack->last)                                                                \
      {                                                                                                 \
          TYPE##StackSegment segment = stack->last;                                                     \
          stack->last = segment->previous;                                                              \
          FREE(stack->context, segment);                                                                \
          if (stack->last)                                                                              \
              stack->top = STACK_SEGMENT_SIZE-1;                                                        \
      }                                                                                                 \
  }                                                                                                     \
                                                                                                        \
  static TYPE *top##TYPE(TYPE##Stack stack)                                                             \
  {                                                                                                     \
      return &stack->last->entry[stack->top];                                                           \
  }                                                                                                     \
                                                                                                        \
  static void free##TYPE##Stack(TYPE##Stack stack)                                                      \
  {                                                                                                     \
      TYPE##StackSegment last = stack->last;                                                            \
      while (last)                                                                                      \
      {                                                                                                 \
          TYPE##StackSegment previous = last->previous;                                                 \
          FREE(stack->context, last);                                                                   \
          last = previous;                                                                              \
      }                                                                                                 \
      FREE(stack->context, stack);                                                                      \
  }

///////////////////////////////////////////////////////////////////////////////////////////////////
// QUEUES OF MEMORY-MANAGED SEGMENTS
//
// Usage:
//   SETUP_QUEUE_TYPE(T)
//
// Expands to declarations of a new type of pointer, TQueue, with the following static functions:
//
// TQueue makeTQueue(Context) - create empty queue of T elements
// void addT(TQueue, T)       - add a T element onto a queue
// T* headT(TQueue)           - pointer to the head element of the queue
// void nextT(TQueue)         - discard the head element off the queue
// void freeTQueue(TQueue)    - free the entire queue

// The state of a TQueue q is determined as follows:
// - if q->first is NULL then the queue is empty; implies that so is q->last and that both q->hd and q->tl are negative.
// - if q->first is not NULL then the queue contains the entries from q->first->entry[q->hd] through q->last->entry[q->tl] (inclusive).

#define QUEUE_SEGMENT_SIZE 127
#define SETUP_QUEUE_TYPE(TYPE)                                                                            \
                                                                                                          \
  typedef struct _##TYPE##Queue *TYPE##Queue;                                                             \
  typedef struct _##TYPE##QueueSegment * TYPE##QueueSegment;                                              \
                                                                                                          \
  struct _##TYPE##Queue { Context context; TYPE##QueueSegment first, last; int hd, tl; };                 \
  struct _##TYPE##QueueSegment { TYPE##QueueSegment next; TYPE entry[QUEUE_SEGMENT_SIZE]; };              \
                                                                                                          \
  static TYPE##Queue make##TYPE##Queue(Context context)                                                   \
  {                                                                                                       \
      TYPE##Queue q = ALLOCATE(context, sizeof(struct _##TYPE##Queue));                                   \
      q->context = context;                                                                               \
      q->first = q->last = NULL;                                                                          \
      q->hd = q->tl = -1;                                                                                 \
      return queue;                                                                                       \
  }                                                                                                       \
                                                                                                          \
  static int empty##TYPE##Queue(TYPE##Queue queue)                                                        \
  {                                                                                                       \
      return !queue->first;                                                                               \
  }                                                                                                       \
                                                                                                          \
  static void add##TYPE(TYPE##Queue queue, TYPE value)                                                    \
  {                                                                                                       \
      ++queue->tl;                                                                                        \
      if (!queue->first || queue->tl >= QUEUE_SEGMENT_SIZE)                                               \
      {                                                                                                   \
          TYPE##QueueSegment segment = ALLOCATE(queue->context, sizeof(struct _##TYPE##QueueSegment));    \
          if (!queue->first)                                                                              \
          {                                                                                               \
              queue->first = segment;                                                                     \
              queue->hd = 0;                                                                              \
          }                                                                                               \
          else                                                                                            \
          {                                                                                               \
              queue->last->next = segment;                                                                \
          }                                                                                               \
          queue->last = segment;                                                                          \
          queue->tl = 0;                                                                                  \
      }                                                                                                   \
      queue->last->entry[queue->tl] = value;                                                              \
  }                                                                                                       \
                                                                                                          \
  static TYPE *head##TYPE(TYPE##Queue queue)                                                              \
  {                                                                                                       \
      ASSERT(context, !queue->first);                                                                     \
      return queue->first->entry[queue->hd];                                                              \
  }                                                                                                       \
                                                                                                          \
  static void next##TYPE(TYPE##Queue queue)                                                               \
  {                                                                                                       \
      ASSERT(context, !queue->first);                                                                     \
      ++queue->hd;                                                                                        \
      if (queue->first == queue->last && queue->hd > queue->tl)                                           \
      {                                                                                                   \
          FREE(queue->context, queue->first);                                                             \
          q->first = q->last = NULL;                                                                      \
          q->hd = q->tl = -1;                                                                             \
      }                                                                                                   \
      else if (queue->first != queue->last && queue->hd >= QUEUE_SEGMENT_SIZE)                            \
      {                                                                                                   \
          TYPE##QueueSegment next = queue->first->next;                                                   \
          FREE(queue->context, queue->first);                                                             \
          queue->first = next;                                                                            \
          queue->hd = 0;                                                                                  \
      }                                                                                                   \
  }                                                                                                       \
                                                                                                          \
  static void free##TYPE##Queue(TYPE##Queue queue)                                                        \
  {                                                                                                       \
      TYPE##QueueSegment first = queue->first;                                                            \
      while (first)                                                                                       \
      {                                                                                                   \
          TYPE##QueueSegment next = first->next;                                                          \
          FREE(queue->context, first);                                                                    \
          first = next;                                                                                   \
      }                                                                                                   \
      FREE(queue->context, queue);                                                                        \
  }

#ifdef __cplusplus
}
#endif

#endif
///////////////////////////////////////////////////////////////////////////////////////////////////

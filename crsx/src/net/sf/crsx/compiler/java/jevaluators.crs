// Copyright © 2012 IBM Corporation
// $Id: jevaluators.crs,v 3.7 2013/08/05 17:55:55 villardl Exp $

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERATE C FUNCTION BODY FRAGMENT FROM EVALUATOR $[PRIMITIVE,...]
//
// Every PRIMITIVE evaluator $Primitive in ../defs.crs needs several variants: 
//
// * {#env} E-send[PRIMITIVE, ARGUMENT_TERMS, sink] - send computed term to sink
// * {#env} E-set[PRIMITIVE, ARGUMENT_TERMS, sink, variable] - set Term variable
// * {#env} E-set-ref[PRIMITIVE, ARGUMENT_TERMS, sink, variable] - set Term reference variable
// * {#env} E-set-bool[PRIMITIVE, ARGUMENT_TERMS, sink, variable] - set boolean (int) variable
// * {#env} E-set-int[PRIMITIVE, ARGUMENT_TERMS, sink, variable] - set integer (long long) variable
// * {#env} E-set-num[PRIMITIVE, ARGUMENT_TERMS, sink, variable] - set generic numeric (double) variable
// * {#env} E-set-string[PRIMITIVE, ARGUMENT_TERMS, sink, variable] - set allocated string (char*) variable
// * {#env} E-set-string-local[PRIMITIVE, ARGUMENT_TERMS, sink, variable] - set local volatile string (char*) variable
//
// In each case, the ARGUMENT_TERMS has *all* the subterms, including the original PRIMITIVE subterm.
// The generated value is sent to the sink for E-send and assigned to the variable for the rest.
// We group the evaluator primitive implementations by their principal value type.
//
// In addition, pattern-permitted primitives have
// 
// * {#env} E-Pattern[PRIMITIVE, PATTERNS, sink, term, ok.CONTINUATION[ok]]
//
///////////////////////////////////////////////////////////////////////////////////////////////////

EVAL[(


///////////////////////////////////////////////////////////////////////////////////////////////////
// UTILITIES

// Simple casts from term.
//
-[Discard[#sink]]:
E-term-to-string[#sink, #term, #variable] → %n⟪«#variable» = SYMBOL(«#term»);
⟫;

-[Discard[#sink]]:
E-term-to-int[#sink, #term, #variable] → %n⟪«#variable» = LONGLONG(«#term»);
⟫;

-[Discard[#sink]]:
E-term-to-num[#sink, #term, #variable] → %n⟪«#variable» = DOUBLE(«#term»);
⟫;

// Simple casts from string.
//
-[Discard[#sink]]:
E-string-to-set[#sink, #str, #variable] → %n⟪«#variable» = makeStringLiteral(«#str»);
⟫;

-[Discard[#sink]]:
E-string-to-bool[#sink, #str, #variable] → %n⟪«#variable» = !«#str».isEmpty();
⟫;

-[Discard[#sink]]:
E-string-to-int[#sink, #str, #variable] → %n⟪«#variable» = Integer.parseInt(«#str»);
⟫;

-[Discard[#sink]]:
E-string-to-num[#sink, #str, #variable] → %n⟪«#variable» = Double.parseDouble(«#str»);
⟫;

// Simple casts from bool.
//
-[Discard[#sink]]:
E-bool-to-int[#sink, #bool, #variable] → %n⟪«#variable» =  «#bool» ? 1l : 0l;
⟫;

-[Discard[#sink]]:
E-bool-to-num[#sink, #bool, #variable] → %n⟪«#variable» = «#bool» ? 1.0 : 0.0;
⟫;

-[Discard[#sink]]:
E-bool-to-string[#sink, #bool, #variable] → %n⟪«#variable» = («#bool» ? "$True" : "");
⟫;

// Simple casts from integers.
//
-[Discard[#sink]]:
E-int-to-bool[#sink, #int, #variable] → %n⟪«#variable» = («#int» != 0);
⟫;

-[Discard[#sink]]:
E-int-to-num[#sink, #int, #variable] → %n⟪«#variable» = (double) «#int»;
⟫;

// Simple casts from numeric.
//
-[Discard[#sink]]:
E-num-to-bool[#sink, #num, #variable] → %n⟪«#variable» = («#num» != 0e0);
⟫;

-[Discard[#sink]]:
E-num-to-num[#sink, #num, #variable] → %n⟪«#variable» =«#num» ; 
⟫;

// Optional argument.
//
               {#env}E-optional[(),      ok arg.#Tail[ok,arg]] → {#env}#Tail[OK, EVALUATOR["Null", (LITERAL["Null", SORT["$String", ()]];)]] ;
-[Copy[#Arg]]: {#env}E-optional[(#Arg;), ok arg.#Tail[ok,arg]] → {#env}#Tail[OK, #Arg] ;

               {#env}E-optional-nil[(),      ok arg.#Tail[ok,arg]] → {#env}#Tail[OK, EVALUATOR["Nil", (LITERAL["Nil", SORT["$String", ()]];)]] ;
-[Copy[#Arg]]: {#env}E-optional-nil[(#Arg;), ok arg.#Tail[ok,arg]] → {#env}#Tail[OK, #Arg] ;


///////////////////////////////////////////////////////////////////////////////////////////////////
// NULL PRIMITIVE
//
Null-send[Discard[#Name,#sink]]:             {#env}E-send[E_Null, (#Name;), #sink] → %n⟪⟫ ;
Null-set[Discard[#Name,#sink]]:              {#env}E-set[E_Null, (#Name;), #sink, #variable] → %n⟪«#variable» = null;⟫;
Null-set-ref[Discard[#Name,#sink]]:          {#env}E-set-ref[E_Null, (#Name;), #sink, #variable] → %n⟪«#variable» = null;⟫;
Null-set-bool[Discard[#Name,#sink]]:         {#env}E-set-bool[E_Null, (#Name;), #sink, #variable] → %n⟪«#variable» = 0;⟫;
Null-set-int[Discard[#Name,#sink]]:          {#env}E-set-int[E_Null, (#Name;), #sink, #variable] → %n⟪«#variable» = 0l;⟫;
Null-set-num[Discard[#Name,#sink]]:          {#env}E-set-num[E_Null, (#Name;), #sink, #variable] → %n⟪«#variable» = 0.0;⟫;
Null-set-string[Discard[#Name,#sink]]:       {#env}E-set-string[E_Null, (#Name;), #sink, #variable] → %n⟪«#variable» = null;⟫;
Null-set-string-local[Discard[#Name,#sink]]: {#env}E-set-string-local[E_Null, (#Name;), #sink, #variable] → %n⟪«#variable» = null;⟫;

///////////////////////////////////////////////////////////////////////////////////////////////////
// STREAMING TERM-VALUED EVALUATORS

// Primitives defined using E-send.
//
$Meta[(
  -[Meta,Lax]:
  SEND_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:,##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-send-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-send-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-send-to-bool[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-int"]: {#env} E-set-int[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-send-to-int[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-send-to-num[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-send-to-string[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string-local"]: {#env} E-set-string-local[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-send-to-string[##PRIMITIVE, #Args, #sink, #variable];
  );
)];

-[Fresh[buf], Free[sink]]:
{#env}E-send-to-set[#Primitive, #Args, sink, #variable] → %n⟪{⟦ Sink «buf» = new BufferSink();
«{#env}E-send[#Primitive, #Args, buf]»«#variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»); ⟧}
⟫;

-[Fresh[str], Free[sink]]:
{#env}E-send-to-bool[#Primitive, #Args, sink, #variable] → %n⟪{⟦ String «str»;
«{#env}E-send-to-string[#Primitive, #Args, sink, str]»«{#env}E-string-to-bool[sink, str, #variable]» ⟧}
⟫;

-[Fresh[str], Free[sink]]:
{#env}E-send-to-int[#Primitive, #Args, sink, #variable] → %n⟪{⟦ String «str»;
«{#env}E-send-to-string[#Primitive, #Args, sink, str]»«{#env}E-string-to-int[sink, str, #variable]» ⟧}
⟫;

-[Fresh[str], Free[sink]]:
{#env}E-send-to-num[#Primitive, #Args, sink, #variable] → %n⟪{⟦ String «str»;
«{#env}E-send-to-string[#Primitive, #Args, sink, str]»«{#env}E-string-to-num[sink, str, #variable]» ⟧}
⟫;

-[Fresh[term], Free[sink]]:
{#env}E-send-to-string[#Primitive, #Args, sink, #variable] → %n⟪{⟦ Term «term»;
«{#env}E-send-to-set[#Primitive, #Args, sink, term]»«{#env}E-term-to-string[sink, term, #variable]» ⟧}
⟫;

// $[LoadTerm, #url] parses the URL and returns the term.
//
SEND_PRIMITIVE[E_LoadTerm];

Send-LoadTerm[Free[sink],Discard[#Name],Copy[#Url]]:
{#env} E-send[E_LoadTerm, (#Name; #Url;), sink]
→
{#env} T-argument-string[#Url, sink, url.%n⟪LOAD_TERM(«sink», «url»);
⟫]
;

// $[Nil] is synonymous with sending nothing.
//
SEND_PRIMITIVE[E_Nil];

Send-Nil[Discard[#Name,#sink]]:
{#env} E-send[E_Nil, (#Name;), #sink]
→
%n⟪⟫
;

// $[FreeVariables[sortname], t]
//
SEND_PRIMITIVE[E_FreeVariables];

// Without environment.
Send-FreeVariables[Discard[#Name],Free[sink],Fresh[fvs,term,link]]:
{#env} E-send[E_FreeVariables, (CONSTRUCTION[#Name, (ARGUMENT[(), CONSTRUCTION[#SortName, ()]]; )]; #Term;), sink]
→
%n⟪{⟦ Term «term»;
« {#env} T-set[#Term, sink, term] »
VariableSet «fvs» = makeFreeVariableSet(«term», «Sort[#SortName]», false, null);
VariableSetLink «link»;
for («link» = «fvs».link; «link» != null; «link» = «link».link) {⟦START(«sink», «Descriptor["$Cons"]»); 
USE(«sink», «link».variable);⟧
}
START(«sink», «Descriptor["$Nil"]»); END(«sink», «Descriptor["$Nil"]»);
for («link» = «fvs».link; «link» != null; «link» = «link».link) { END(«sink», «Descriptor["$Cons"]»); }
freeVariableSet(«fvs»);⟧
}
⟫
;

// With environment.
Send-FreeVariables-Constrained[Discard[#Name],Free[sink],Fresh[fvs,term,link]]:
{#env}E-send[E_FreeVariables, (PROPERTY-REF[#Ref, CONSTRUCTION[#Name, (ARGUMENT[(), CONSTRUCTION[#SortName, ()]]; )]]; #Term;), sink]
→
%n⟪{⟦ Term «term»;
« {#env} T-set[#Term, sink, term] »VariableSet «fvs» = makeFreeVariableSet(«term», «Sort[#SortName]», true, «{#env}E-VariableProperties[$[:,"MetaVar$",#Ref]]»);
VariableSetLink «link»;
for («link» = «fvs».link; «link» != null; «link» = «link».link) { START(«sink», «Descriptor["$Cons"]»); USE(«sink», «link».variable); }
START(«sink», «Descriptor["$Nil"]»); END(«sink», «Descriptor["$Nil"]»);
for («link» = «fvs».link; «link» != null; «link» = «link».link) { END(«sink», «Descriptor["$Cons"]»); }
freeVariableSet(«fvs»);⟧
}
⟫
;

// $[UnionVariables[sortname], vs1, vs2]

SEND_PRIMITIVE[E_UnionVariables];

Send-UnionVariables[Discard[#Name,#SortName],Free[sink],Fresh[list,vs,v,link,next]]:
{#env} E-send[E_UnionVariables, (CONSTRUCTION[#Name, (ARGUMENT[(), CONSTRUCTION[#SortName, ()]]; )]; #List1; #List2;), sink]
→
%n⟪{⟦ Term «list»; VariableSet «vs» = makeVariableSet(); VariableSetLink «link»;
« {#env} T-set[#List1, sink, list] »while ("$Cons".equals(SYMBOL(«list»))) {⟦ Variable «v» = VARIABLE(SUB(«list»,0)); 
if (addVariable(«vs»,«v»)) {⟦ START(«sink», «Descriptor["$Cons"]»); 
USE(«sink», «v»); ⟧
}
Term «next» = LINK(SUB(«list»,1));
UNLINK(«list»);
«list» = «next»; ⟧
}
UNLINK(«list»);
« {#env} T-set[#List2, sink, list] »while ("$Cons".equals(SYMBOL(«list»))) {⟦ Variable «v» = VARIABLE(SUB(«list»,0)); 
if (addVariable(«vs»,«v»)) {⟦ START(«sink», «Descriptor["$Cons"]»); 
USE(«sink», «v»); ⟧
} 
Term «next» = LINK(SUB(«list»,1));
UNLINK(«list»);
«list» = «next»; ⟧
}
UNLINK(«list»);
START(«sink», «Descriptor["$Nil"]»); END(«sink», «Descriptor["$Nil"]»);
for («link» = «vs».link; «link» != null; «link» = «link».link) END(«sink», «Descriptor["$Cons"]»);
freeVariableSet(«vs»);⟧
}
⟫
;

// $[IntersectVariables[sortname], vs1, vs2]

SEND_PRIMITIVE[E_IntersectVariables];

Send-IntersectVariables[Discard[#Name,#SortName],Free[sink],Fresh[list,vs,v,size,next]]:
{#env} E-send[E_IntersectVariables, (CONSTRUCTION[#Name, (ARGUMENT[(), CONSTRUCTION[#SortName, ()]]; )]; #List1; #List2;), sink]
→
%n⟪{⟦ Term «list»; VariableSet «vs» = makeVariableSet(); int «size» = 0;
« {#env} T-set[#List1, sink, list] »while ("$Cons".equals(SYMBOL(«list»))) {⟦ Variable «v» = VARIABLE(SUB(«list»,0)); 
addVariable(«vs»,«v»); 
Term «next» = LINK(SUB(«list»,1));
UNLINK(«list»);
«list» = «next»;⟧
}
UNLINK(«list»);
« {#env} T-set[#List2, sink, list] »while ("$Cons".equals(SYMBOL(«list»))) {⟦ Variable «v» = VARIABLE(SUB(«list»,0)); 
if (containsVariable(«vs»,«v»)) {⟦ START(«sink», «Descriptor["$Cons"]»); 
USE(«sink», «v»); 
++«size»; ⟧} 
Term «next» = LINK(SUB(«list»,1));
UNLINK(«list»);
«list» = «next»; ⟧
}
UNLINK(«list»);
START(«sink», «Descriptor["$Nil"]»); END(«sink», «Descriptor["$Nil"]»);
while («size»-- > 0)  END(«sink», «Descriptor["$Cons"]»);
freeVariableSet(«vs»);⟧
}
⟫
;

// $[ExceptVariables[sortname], vs1, vs2]

SEND_PRIMITIVE[E_ExceptVariables];

Send-ExceptVariables[Discard[#Name,#SortName],Free[sink],Fresh[list1,list2,vs,v,size,next]]:
{#env} E-send[E_ExceptVariables, (CONSTRUCTION[#Name, (ARGUMENT[(), CONSTRUCTION[#SortName, ()]]; )]; #List1; #List2;), sink]
→
%n⟪{⟦ Term «list1», «list2»; VariableSet «vs» = makeVariableSet(); int «size» = 0;
« {#env} T-set[#List1, sink, list1] »« {#env} T-set[#List2, sink, list2] »while ("$Cons".equals(SYMBOL(«list2»))) {⟦ Variable «v» = VARIABLE(SUB(«list2»,0)); 
addVariable(«vs»,«v»);
Term «next» = LINK(SUB(«list2»,1));
UNLINK(«list2»);
«list2» = «next»;⟧
}
UNLINK(«list2»);
while ("$Cons".equals(SYMBOL(«list1»))) {⟦ Variable «v» = VARIABLE(SUB(«list1»,0)); 
if (!containsVariable(«vs»,«v»)) {⟦ addVariable(«vs»,«v»); 
START(«sink», «Descriptor["$Cons"]»); 
USE(«sink», «v»); 
++«size»; ⟧} 
Term «next» = LINK(SUB(«list1»,1));
UNLINK(«list1»);
«list1» = «next»;⟧
}
UNLINK(«list1»);
START(«sink», «Descriptor["$Nil"]»); END(«sink», «Descriptor["$Nil"]»);
while («size»-- > 0)  END(«sink», «Descriptor["$Cons"]»);
freeVariableSet(«vs»);⟧
}
⟫
;


///////////////////////////////////////////////////////////////////////////////////////////////////
// SET TERM-VALUED EVALUATORS

// Primitives for term functions defined using E-set-ref.
//
$Meta[(
  -[Meta,Lax]:
  SET_REF_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:,##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #sink] → {#env}E-set-ref-to-send[##PRIMITIVE, #Args, #sink];
    $[:,##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-ref-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-ref-to-bool[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-int"]: {#env} E-set-int[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-ref-to-int[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-ref-to-num[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-ref-to-string[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string-local"]: {#env} E-set-string-local[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-ref-to-string[##PRIMITIVE, #Args, #sink, #variable];
  );
)];

-[Fresh[term], Free[sink]]:
{#env}E-set-ref-to-send[#Primitive, #Args, sink] → %n⟪{⟦ Term «term»;
«{#env}E-set-ref[#Primitive, #Args, sink, term]»COPY(«sink», «term»); /*CONSERVATIVE*/ ⟧}
⟫;

-[Fresh[buf], Free[sink]]:
{#env}E-set-ref-to-set[#Primitive, #Args, sink, #variable] → %n⟪{⟦ Sink «buf» = new BufferSink();
« {#env}E-set-ref-to-send[#Primitive, #Args, buf] »«#variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»); ⟧}
⟫;

-[Fresh[str], Free[sink]]:
{#env}E-set-ref-to-bool[#Primitive, #Args, sink, #variable] → %n⟪{⟦ String «str»;
«{#env}E-set-ref-to-string[#Primitive, #Args, sink, str]»«{#env}E-string-to-bool[sink, str, #variable]» ⟧}
⟫;

-[Fresh[str], Free[sink]]:
{#env}E-set-ref-to-int[#Primitive, #Args, sink, #variable] → %n⟪{⟦ String «str»;
«{#env}E-set-ref-to-string[#Primitive, #Args, sink, str]»«{#env}E-string-to-int[sink, str, #variable]» ⟧}
⟫;

-[Fresh[str], Free[sink]]:
{#env}E-set-ref-to-num[#Primitive, #Args, sink, #variable] → %n⟪{⟦ String «str»;
«{#env}E-set-ref-to-string[#Primitive, #Args, sink, str]»«{#env}E-string-to-num[sink, str, #variable]» ⟧}
⟫;

-[Fresh[term], Free[sink]]:
{#env}E-set-ref-to-string[#Primitive, #Args, sink, #variable] → %n⟪{⟦ Term «term»;
«{#env}E-set-ref[#Primitive, #Args, sink, term]»«{#env}E-term-to-string[sink, term, #variable]» ⟧}
⟫;

// $[{#env}Get, name[, default]] return property or variable from the environment (either the properties in #env on Get or the global one).
//
SET_REF_PRIMITIVE[E_Get];

Set-Get[Fresh[key, pp], Free[sink], Copy[#property], Discard[#Name]]
:
{#env}E-set-ref[E_Get, (PROPERTY-REF[#Ref, #Name]; #Key; #Defaults), sink, #property]
→
%n⟪{⟦ Term «key»;
«{#env}T-set-ref[#Key, sink, key]»Term «pp» = «{#env}E-Get-Property[$[:,"MetaVar$",#Ref], key]»;
if («pp» != null) «#property» = LINK(«pp»);
else {⟦«{#env}E-optional-nil[#Defaults, ok arg.T-then-set-ref[ok, arg, sink, #property]]»⟧}⟧
}
⟫;

Set-Term-Get-Global[Fresh[value], Free[sink], Discard[#_Ref,#_Name,#Name], Copy[#Key,#property]]
:
{#env}E-set-ref[E_Get, ($[NotMatch,PROPERTY-REF[#_Ref, #_Name],#Name]; #Key; #Defaults), sink, #property]
→
{#env} T-argument-string[#Key, sink, key. %n⟪{⟦ String «value» = System.getenv(«key»);
if («value» != null) «#property» = makeStringLiteral(«value»);
else {⟦«{#env}E-optional-nil[#Defaults, ok arg.T-then-set-ref[ok, arg, sink, #property]]»⟧}⟧
}
⟫]
;

// $[{#env}GetRef, name[, default]] return immutable property or variable from environment
//
SET_REF_PRIMITIVE[E_GetRef];

Set-GetRef[Fresh[key, pp], Free[sink], Copy[#property], Discard[#Name]]
:
{#env}E-set-ref[E_GetRef, (PROPERTY-REF[#Ref, #Name]; #Key; #Defaults), sink, #property]
→
%n⟪{⟦ Term «key»;
«{#env}T-set-ref[#Key, sink, key]»Term «pp» = «{#env}E-Get-Property[$[:,"MetaVar$",#Ref], key]»;
if («pp» != null) «#property» = LINK(«pp»);
else {⟦«{#env}E-optional-nil[#Defaults, ok arg.T-then-set-ref[ok, arg, sink, #property]]»⟧}⟧
}
⟫;

-[Free[key, namedP, varP], Discard[#RefCookie], Comparable[#RefCookie]]
:
{#env; #RefCookie: PP[namedP, varP]}
E-Get-Property[#RefCookie, key]
→
%n⟪DPROPERTY(«namedP», «varP», «key»)⟫;

-[Free[namedP, varP], Discard[#RefCookie], Comparable[#RefCookie]]
:
{#env; #RefCookie: PP[namedP, varP]}
E-VariableProperties[#RefCookie]
→
%n⟪«varP»⟫;



///////////////////////////////////////////////////////////////////////////////////////////////////
// BOOLEAN PRIMITIVES

// Helpers for boolean functions using E-set-bool.
//
$Meta[(
  -[Meta,Lax]:
  BOOL_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:,##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #sink] → {#env}E-send-bool[##PRIMITIVE, #Args, #sink];
    $[:,##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-bool-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-bool-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-int"]: {#env} E-set-int[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-bool-to-int[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-bool-to-num[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-bool-to-string[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string-local"]: {#env} E-set-string-local[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-bool-to-string[##PRIMITIVE, #Args, #sink, #variable];
  );
)];

Send-Bool[Fresh[bool], Free[sink]]:
{#env}E-send-bool[#Primitive, #Args, sink] → %n⟪{⟦ boolean «bool»;
«{#env}E-set-bool[#Primitive, #Args, sink, bool]»if («bool») { START(«sink», «Descriptor["$True"]»); END(«sink», «Descriptor["$True"]»); }
else { START(«sink», «Descriptor["$False"]»); END(«sink», «Descriptor["$False"]»); } ⟧
}
⟫;
// TODO: reference $True and $False...

Set-Bool-To-Set[Fresh[buf], Free[sink, variable]]:
{#env}E-set-bool-to-set[#Primitive, #Args, sink, variable] → %n⟪{⟦ Sink «buf» = MAKE_BUFFER();
«{#env}E-send-bool[#Primitive, #Args, buf]»«variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»); ⟧}
⟫;

Set-Bool-To-Int[Fresh[bool], Free[sink, variable]]:
{#env}E-set-bool-to-int[#Primitive, #Args, sink, variable] → %n⟪{⟦ boolean «bool»;
«{#env}E-set-bool[#Primitive, #Args, sink, bool]»«{#env}E-bool-to-int[sink, bool, variable]» ⟧}
⟫;

Set-Bool-To-Num[Fresh[bool], Free[sink, variable]]:
{#env}E-set-bool-to-num[#Primitive, #Args, sink, variable] → %n⟪{⟦ boolean «bool»;
«{#env}E-set-bool[#Primitive, #Args, sink, bool]»«{#env}E-bool-to-num[sink, bool, variable]» ⟧}
⟫;

Set-Bool-To-String[Fresh[bool], Free[sink, variable]]:
{#env}E-set-bool-to-string[#Primitive, #Args, sink, variable] → %n⟪{⟦ boolean «bool»;
«{#env}E-set-bool[#Primitive, #Args, sink, bool]»«{#env}E-bool-to-string[sink, bool, variable]» ⟧}
⟫;

// Generic infix comparison forms...
Set-Bool-InfixOp-Term[Fresh[n1, n2], Free[sink, bool]]:
{#env}E-set-bool-op[#Op, #Term1, #Term2, sink, bool] → %n⟪{⟦ double «n1», «n2»;
«{#env}T-set-num[#Term1, sink, n1]»«{#env}T-set-num[#Term2, sink, n2]»«bool» = («n1» «#Op» «n2»); ⟧}
⟫;

// $[SameVariable, #1, #2] test equality of #1, #2, as variables, result is boolean.
//
BOOL_PRIMITIVE[E_SameVariable];

Set-Bool-SameVariable-Term[Fresh[t1, t2], Free[sink, bool], Discard[#Name]]:
{#env}E-set-bool[E_SameVariable, (#Name; #Term1; #Term2;), sink, bool] → %n⟪{⟦ Term «t1», «t2»;
« {#env} T-set[#Term1, sink, t1] »« {#env} T-set[#Term2, sink, t2] »«bool» = (VARIABLE(«t1») == VARIABLE(«t2»)); UNLINK(«t1»); UNLINK(«t2»); ⟧}

⟫;

// $[LesserVariable, #1, #2] test order of #1, #2, as alphaorder, result is boolean.
//
BOOL_PRIMITIVE[E_LesserVariable];

Set-Bool-LesserVariable-Term[Fresh[t1, t2], Free[sink, bool], Discard[#Name]]:
{#env}E-set-bool[E_LesserVariable, (#Name; #Term1; #Term2;), sink, bool] → %n⟪{⟦ Term «t1», «t2»;
« {#env} T-set[#Term1, sink, t1] »« {#env} T-set[#Term2, sink, t2] »«bool» = SYMBOL(«t1»).compare(SYMBOL(«t2»))) < 0;
UNLINK(«t1»); UNLINK(«t2»); ⟧}
⟫;

// $[Equal, #1, #2] test equality of #1, #2, as strings, result is boolean.
//
BOOL_PRIMITIVE[E_Equal];

Set-Bool-Equal-Term[Free[sink, bool], Discard[#Name]]:
{#env} E-set-bool[E_Equal, (#Name; #Term1; #Term2;), sink, bool]
→
{#env} T-argument-string[#Term1, sink, s1.{#env} T-argument-string[#Term2, sink, s2.%n⟪«bool» = «s1».equals(«s2»);
⟫]]
;

// $[NotEqual, #1, #2] test inequality of #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_NotEqual];

Set-Bool-NotEqual-Term[Free[sink, bool], Discard[#Name]]:
{#env} E-set-bool[E_NotEqual, (#Name; #Term1; #Term2;), sink, bool]
→
{#env} T-argument-string[#Term1, sink, s1.{#env} T-argument-string[#Term2, sink, s2.%n⟪«bool» = !«s1».equals(«s2»);
⟫]]
;

// $[NumericEqual, #1, #2] test equality of #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_NumericEqual];

Set-Bool-NumericEqual[Discard[#Name]]:
{#env}E-set-bool[E_NumericEqual, (#Name; #Term1; #Term2;), #sink, #bool] →  {#env}E-set-bool-op[%n⟪ == ⟫, #Term1, #Term2, #sink, #bool];

// $[LessThan, #1, #2] for constant numbers #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_LessThan];

Set-Bool-LessThan[Discard[#Name]]:
{#env}E-set-bool[E_LessThan, (#Name; #Term1; #Term2;), #sink, #bool] → {#env}E-set-bool-op[%n⟪ < ⟫, #Term1, #Term2, #sink, #bool];

// $[GreaterThan, #1, #2] for constant numbers #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_GreaterThan];

Set-Bool-GreaterThan[Discard[#Name]]:
{#env}E-set-bool[E_GreaterThan, (#Name; #Term1; #Term2;), #sink, #bool] → {#env}E-set-bool-op[%n⟪ > ⟫, #Term1, #Term2, #sink, #bool];

// $[LessThanOrEqual, #1, #2] for constant numbers #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_LessThanOrEqual];

Set-Bool-LessThanOrEqual[Discard[#Name]]:
{#env}E-set-bool[E_LessThanOrEqual, (#Name; #Term1; #Term2;), #sink, #bool] → {#env}E-set-bool-op[%n⟪ <= ⟫, #Term1, #Term2, #sink, #bool];

// $[GreaterThanOrEqual, #1, #2] for constant numbers #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_GreaterThanOrEqual];

Set-Bool-GreaterThanOrEqual[Discard[#Name]]:
{#env}E-set-bool[E_GreaterThanOrEqual, (#Name; #Term1; #Term2;), #sink, #bool] → {#env}E-set-bool-op[%n⟪ >= ⟫, #Term1, #Term2, #sink, #bool];

// $[Contains, #1, #2] returns whether constant #1 contains the substring constant #2.
//
BOOL_PRIMITIVE[E_Contains];

Set-Bool-Contains[Free[bool, sink], Discard[#Name]]:
{#env}E-set-bool[E_Contains, (#Name; #String; #Substring;), sink, bool]
→
{#env} T-argument-string[#String, sink, s1.{#env} T-argument-string[#Substring, sink, s2.%n⟪«bool» = «s1».contains(«s2»);
⟫]]
;

// $[StartsWith, STRING, SUBSTRING]
//
BOOL_PRIMITIVE[E_StartsWith];

Set-Bool-StartsWith[Fresh[s2], Free[bool, sink], Discard[#Name]]:
{#env}E-set-bool[E_StartsWith, (#Name; #String; #Substring;), sink, bool]
→
{#env} T-argument-string[#String, sink, s1.%n⟪{⟦ String «s2»;
« {#env}T-set-string-local[#Substring, sink, s2] »«bool» = «s1».startsWith(«s2»); ⟧}
⟫]
;

// $[EndsWith, #1, #2] returns whether constant #1 ends with the substring constant #2.
//
BOOL_PRIMITIVE[E_EndsWith];

Set-Bool-EndsWith[Fresh[s1, s2, offset], Free[bool, sink], Discard[#Name]]:
{#env}E-set-bool[E_EndsWith, (#Name; #String; #Substring;), sink, bool]
→
%n⟪{⟦ String «s1», «s2»;
«{#env}T-set-string-local[#String, sink, s1]»«{#env}T-set-string-local[#Substring, sink, s2]»
«bool» = «s1».endsWith(«s2»); ⟧}
⟫;

// $[BitSubSetEq, #i1, #i2] is $True or $Nil depending on whether all bits in #i1 are also in #i2. 
//
BOOL_PRIMITIVE[E_BitSubSetEq];

Set-Bool-BitSubSetEq[Fresh[i1, i2], Free[bool, sink], Discard[#Name]]:
{#env}E-set-bool[E_BitSubSetEq, (#Name; #Left; #Right;), sink, bool]
→
%n⟪{⟦ long «i1», «i2»;
«{#env}T-set-int[#Left, sink, i1]»«{#env}T-set-int[#Right, sink, i2]»«bool» = («i1»&(~«i2»)) != 0; ⟧}
⟫;

// $[MatchRegex, #regex, #p], for constant #regex, is match pattern that only matches constants that fit the regular expression #regex and also match #p.
//   Can also be used as evaluator where it returns the boolean result of whether */// $[BitSubSetEq, #i1, #i2] is $True or $Nil depending on whether all bits in #i1 are also in #i2. 

BOOL_PRIMITIVE[E_MatchRegex];

Set-Bool-MatchRegex[Fresh[s1, s2], Free[bool, sink], Discard[#Name]]:
{#env}E-set-bool[E_MatchRegex, (#Name; #Regex; #Str;), sink, bool]
→
%n⟪{⟦String «s1», «s2»;
«{#env}T-set-string-local[#Regex, sink, s1]»«{#env}T-set-string-local[#Str, sink, s2]»«bool» = MATCHREGEX(«s1», «s2»); ⟧}
⟫;


///////////////////////////////////////////////////////////////////////////////////////////////////
// INTEGER PRIMITIVES

// Helpers for integer (long long) functions using E-set-int.
//
$Meta[(
  -[Meta,Lax]:
  INT_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:,##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #sink] → {#env}E-send-int[##PRIMITIVE, #Args, #sink];
    $[:,##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-int-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-int-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-int-to-bool[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-int-to-num[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-int-to-string[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string-local"]: {#env} E-set-string-local[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-int-to-string-local[##PRIMITIVE, #Args, #sink, #variable];
  );
)];

Send-Int[Fresh[int], Free[sink]]:
{#env}E-send-int[#Primitive, #Args, sink] → %n⟪{⟦ long «int»;
«{#env}E-set-int[#Primitive, #Args, sink, int]»LITERALNF(«sink», «int»); ⟧}
⟫;

Set-Int-To-Set[Fresh[buf], Free[sink, variable]]:
{#env}E-set-int-to-set[#Primitive, #Args, sink, variable] → %n⟪{⟦ Sink «buf» = MAKE_BUFFER();
«{#env}E-send-int[#Primitive, #Args, buf]»«variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»); ⟧}
⟫;

Set-Int-To-Bool[Fresh[int], Free[sink, variable]]:
{#env}E-set-int-to-bool[#Primitive, #Args, sink, variable] → %n⟪{⟦ long «int»;
«{#env}E-set-int[#Primitive, #Args, sink, int]»«variable» = («int» != 0); ⟧}
⟫;

Set-Int-To-Num[Fresh[int], Free[sink, variable]]:
{#env}E-set-int-to-num[#Primitive, #Args, sink, variable] → %n⟪{⟦ long «int»;
«{#env}E-set-int[#Primitive, #Args, sink, int]»«variable» = (double) «int»; ⟧}
⟫;

Set-Int-To-String[Fresh[int], Free[sink, variable]]:
{#env}E-set-int-to-string[#Primitive, #Args, sink, variable] → %n⟪{⟦ long «int»;
«{#env}E-set-int[#Primitive, #Args, sink, int]»«variable» = ALLOCATENF(«int»); ⟧}
⟫;

Set-Int-To-String-Local[Fresh[int], Free[sink, variable]]:
{#env}E-set-int-to-string-local[#Primitive, #Args, sink, variable] → %n⟪long «int»;
«{#env}E-set-int[#Primitive, #Args, sink, int]»«variable» = Long.toString(«int»);
⟫;

// Generic infix binary operator forms...
Set-Int-Op[Fresh[i1, i2], Free[int, sink]]: 
{#env}E-set-int-op[#Op, #Left, #Right, sink, int] → %n⟪{⟦ long «i1», «i2»;
«{#env}T-set-int[#Left, sink, i1]»«{#env}T-set-int[#Right, sink, i2]»«int» = «i1» «#Op» «i2»; ⟧}
⟫;

Set-Num-Op[Fresh[n1, n2], Free[num, sink]]: 
{#env}E-set-num-op[#Op, #Left, #Right, sink, num] → %n⟪{⟦ double «n1», «n2»;
«{#env}T-set-num[#Left, sink, n1]»«{#env}T-set-num[#Right, sink, n2]»«num» = «n1» «#Op» «n2»; ⟧}
⟫;

// $[Length, #1] returns the number of characters in constant #1.
//
INT_PRIMITIVE[E_Length];

Set-Int-Length[Free[int, sink], Discard[#Name]]:
{#env}E-set-int[E_Length, (#Name; #String;), sink, int]
→
{#env} T-argument-string[#String, sink, s.%n⟪«int» = «s».length();
⟫]
;

// $[Absolute,#n] corresponds to the integer with hex digits #hex.
//
INT_PRIMITIVE[E_Absolute];

Set-Int-Absolute[Free[int, sink], Discard[#Name]]:
{#env}E-set-int[E_Absolute, (#Name; #Number;), sink, int]
→
%n⟪« {#env} T-set-int[#Number, sink, int] »if («int» < 0l) «int» = -«int»;
⟫
;


// $[Decimal,#dec] corresponds to the integer with hex digits #hex.
//
INT_PRIMITIVE[E_Decimal];

Set-Int-Decimal-Literal[Free[int, sink], Discard[#Name, #Sort]]: 
{#env}E-set-int[E_Decimal, (#Name; LITERAL[#String, SORT[#Sort, ()]];), sink, int] → %n⟪«int» = «TOKEN[#String]»l;
⟫;

Set-Int-Decimal[Fresh[decimal ], Free[num, sink], Discard[#Name, #_String, #_Sort]]:
{#env}E-set-int[E_Decimal, (#Name; $[NotMatch,LITERAL[#_String, #_Sort],#Decimal];), sink, num] → %n⟪{⟦ char *«decimal »;
«{#env}T-set-string-local[#Decimal, sink, decimal ]» try {⟦ «num» = Long.decode(«decimal»); ⟧}
catch (NumberFormatException e) {⟦
ERRORF(Crsx, "Illegally formatted $[Decimal,'%s']\n", «decimal »);⟧⟧}
⟫;

// $[Hex,#hex] corresponds to the integer with hex digits #hex.
//
INT_PRIMITIVE[E_Hex];

Set-Int-Hex-Literal[Free[int, sink], Discard[#Name, #Sort]]: 
{#env}E-set-int[E_Hex, (#Name; LITERAL[#String, SORT[#Sort, ()]];), sink, int] → %n⟪«int» = 0x«TOKEN[#String]»l;
⟫;

Set-Int-Hex[Fresh[hex], Free[num, sink], Discard[#Name, #_String, #_Sort]]:
{#env}E-set-int[E_Hex, (#Name; $[NotMatch,LITERAL[#_String, #_Sort],#Hex];), sink, num] → %n⟪{⟦ String «hex»;
«{#env}T-set-string-local[#Hex, sink, hex]» try {⟦ «num» = Long.decode(«hex»); ⟧} 
catch (NumberFormatException e) {⟦
ERRORF(Crsx, "Illegally formatted " + «hex»);⟧⟧}
⟫;

// $[BitAnd, #i1, #i2] is the integer with the bits common to #i1 and #i2.
//
INT_PRIMITIVE[E_BitAnd];

Set-Int-BitAnd[Discard[#Name]]: 
{#env}E-set-int[E_BitAnd, (#Name; #Left; #Right;), #sink, #num] → {#env}E-set-int-op[%n⟪&⟫, #Left, #Right, #sink, #num];

// $[BitOr, #i1, #i2] is the integer with the bits in either #i1 and/or #i2.
//
INT_PRIMITIVE[E_BitOr];

Set-Int-BitOr[Discard[#Name]]: 
{#env}E-set-int[E_BitOr, (#Name; #Left; #Right;), #sink, #num] → {#env}E-set-int-op[%n⟪|⟫, #Left, #Right, #sink, #num];

// $[BitXor, #i1, #i2] is the integer with the bits in precisely one of #i1 and #i2.
//
INT_PRIMITIVE[E_BitXOr];

Set-Int-BitXOr[Discard[#Name]]: 
{#env}E-set-int[E_BitXOr, (#Name; #Left; #Right;), #sink, #num] → {#env}E-set-int-op[%n⟪^⟫, #Left, #Right, #sink, #num];

// $[BitNot, #i] is the integer with the opposite bits of #i.
//
INT_PRIMITIVE[E_BitNot];

Set-Int-BitNot[Fresh[i1], Free[num, sink], Discard[#Name]]: 
{#env}E-set-int[E_BitNot, (#Name; #Arg;), sink, num] → %n⟪{⟦ long «i1»;
«{#env}T-set-int[#Arg, sink, i1]»«num» = ~«i1»; ⟧}
⟫;

// $[BitMinus, #i1, #i2] is the integer with the bits in #i1 which are not in #i2.
//
INT_PRIMITIVE[E_BitMinus];

Set-Int-BitMinus[Fresh[i1, i2], Free[num, sink], Discard[#Name]]: 
{#env}E-set-int[E_BitMinus, (#Name; #Left; #Right;), sink, num] → %n⟪{⟦ long «i1», «i2»;
«{#env}T-set-int[#Left, sink, i1]»«{#env}T-set-int[#Right, sink, i2]»«num» = «i1» &(~«i2»); ⟧}
⟫;


///////////////////////////////////////////////////////////////////////////////////////////////////
// NUMERIC PRIMITIVES

// Helpers for numeric (double or long long) functions using E-set-num.

$Meta[(
  -[Meta,Lax]:
  NUM_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:,##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #sink] → {#env}E-send-num[##PRIMITIVE, #Args, #sink];
    $[:,##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-num-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-num-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-num-to-bool[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-num-to-string[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-string-local"]: {#env} E-set-string-local[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-num-to-string-local[##PRIMITIVE, #Args, #sink, #variable];
  );
)];

Send-Num[Fresh[num], Free[sink]]:
{#env}E-send-num[#Primitive, #Args, sink] → %n⟪{⟦ double «num»;
«{#env}E-set-num[#Primitive, #Args, sink, num]»LITERALNF(«sink», «num»); ⟧}
⟫;

Set-Num-To-Set[Fresh[buf], Free[sink, variable]]:
{#env}E-set-num-to-set[#Primitive, #Args, sink, variable] → %n⟪{⟦ Sink «buf» = MAKE_BUFFER();
«{#env}E-send-num[#Primitive, #Args, buf]»«variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»); ⟧}
⟫;

Set-Num-To-Bool[Fresh[num], Free[sink, variable]]:
{#env}E-set-num-to-bool[#Primitive, #Args, sink, variable] → %n⟪{⟦ double «num»;
«{#env}E-set-num[#Primitive, #Args, sink, num]»«variable» = («num» != 0d); ⟧}
⟫;

Set-Num-To-String[Fresh[num], Free[sink, variable]]:
{#env}E-set-num-to-string[#Primitive, #Args, sink, variable] → %n⟪{⟦ double «num»;
«{#env}E-set-num[#Primitive, #Args, sink, num]»«variable» = Double.toString(«num»); ⟧}
⟫;

Set-Num-To-String-Local[Fresh[num,str], Free[sink, variable]]:
{#env}E-set-num-to-string-local[#Primitive, #Args, sink, variable] → %n⟪double «num»;
«{#env}E-set-num[#Primitive, #Args, sink, num]»«variable» = Double.toString(«num»);
⟫;

// Helpers for n-ary operations.
-[Discard[#Op,#sink,#num]]:
{#env}E-set-num-fold-op[#Op, (), #sink, #num] → %n⟪⟫;

-[Free[sink,num],Copy[#Op],Fresh[tmp]]:
{#env}E-set-num-fold-op[#Op, (#Arg1;#Args), sink, num] → %n⟪{⟦ double «tmp»;
«{#env}T-set-num[#Arg1, sink, tmp]»«num» «#Op» «tmp»; ⟧}
«{#env}E-set-num-fold-op[#Op, #Args, sink, num]»⟫;

-[Discard[#Op,#sink,#int]]:
{#env}E-set-int-fold-op[#Op, (), #sink, #int] → %n⟪⟫;

-[Free[sink,int],Copy[#Op],Fresh[tmp]]:
{#env}E-set-int-fold-op[#Op, (#Arg1;#Args), sink, int] → %n⟪{⟦ long «tmp»;
«{#env}T-set-int[#Arg1, sink, tmp]»«int» «#Op» «tmp»; ⟧}
«{#env}E-set-int-fold-op[#Op, #Args, sink, int]»⟫;

// $[Plus,#1,...]
//
NUM_PRIMITIVE[E_Plus];

Set-Num-Plus[Free[sink,num], Discard[#Name]]: 
{#env}E-set-num[E_Plus, (#Name; #Arg1; #Args), sink, num] → %n⟪«{#env}T-set-num[#Arg1, sink, num]»«{#env}E-set-num-fold-op[%n⟨+=⟩, #Args, sink, num]»⟫;

Set-Int-Plus[Free[sink,int], Discard[#Name]]: 
{#env}E-set-int[E_Plus, (#Name; #Arg1; #Args), sink, int] → %n⟪«{#env}T-set-int[#Arg1, sink, int]»«{#env}E-set-int-fold-op[%n⟨+=⟩, #Args, sink, int]»⟫;

// $[Times,#1,...]
//
NUM_PRIMITIVE[E_Times];

Set-Num-Times[Free[sink,num], Discard[#Name]]: 
{#env}E-set-num[E_Times, (#Name; #Arg1; #Args), sink, num] → %n⟪«{#env}T-set-num[#Arg1, sink, num]»«{#env}E-set-num-fold-op[%n⟨*=⟩, #Args, sink, num]»⟫;

Set-Int-Times[Free[sink,int], Discard[#Name]]: 
{#env}E-set-int[E_Times, (#Name; #Arg1; #Args), sink, int] → %n⟪«{#env}T-set-int[#Arg1, sink, int]»«{#env}E-set-int-fold-op[%n⟨*=⟩, #Args, sink, int]»⟫;

// $[Minus, #1, #2]
//
NUM_PRIMITIVE[E_Minus];

Set-Num-Minus[Discard[#Name]]: 
{#env}E-set-num[E_Minus, (#Name; #Left; #Right;), #sink, #num] → {#env}E-set-num-op[%n⟪-⟫, #Left, #Right, #sink, #num];

Set-Int-Minus[Discard[#Name]]: 
{#env}E-set-int[E_Minus, (#Name; #Left; #Right;), #sink, #num] → {#env}E-set-int-op[%n⟪-⟫, #Left, #Right, #sink, #num];

// $[Div, #1, #2]
//
Set-Num-Div[Discard[#Name]]: 
{#env}E-set-num[E_Div, (#Name; #Left; #Right;), #sink, #num] → {#env}E-set-num-op[%n⟪/⟫, #Left, #Right, #sink, #num];

Set-Int-Div[Discard[#Name]]: 
{#env}E-set-int[E_Div, (#Name; #Left; #Right;), #sink, #int] → {#env}E-set-int-op[%n⟪/⟫, #Left, #Right, #sink, #int];

// $[Mod, #1, #2]
//
Set-Num-Mod[Discard[#Name]]: 
{#env}E-set-num[E_Mod, (#Name; #Left; #Right;), #sink, #num] → {#env}E-set-int-op[%n⟪%⟫, #Left, #Right, #sink, #num];

Set-Int-Mod[Discard[#Name]]: 
{#env}E-set-int[E_Mod, (#Name; #Left; #Right;), #sink, #int] → {#env}E-set-int-op[%n⟪%⟫, #Left, #Right, #sink, #int];


///////////////////////////////////////////////////////////////////////////////////////////////////
// STRING EVALUATORS

// Primitives defined using E-set-string and -local.

$Meta[(
  -[Meta,Lax]:
  STRING_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:,##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #sink] → {#env}E-send-string[##PRIMITIVE, #Args, #sink];
    $[:,##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-string-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-string-to-set[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-string-to-bool[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-int"]: {#env} E-set-int[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-string-to-int[##PRIMITIVE, #Args, #sink, #variable];
    $[:,##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #sink, #variable] → {#env}E-set-string-to-num[##PRIMITIVE, #Args, #sink, #variable];
  );
)];

Send-String[Fresh[str], Free[sink]]:
{#env}E-send-string[#Primitive, #Args, sink] → %n⟪{⟦ String «str»;
« {#env}E-set-string[#Primitive, #Args, sink, str] »LITERALU(«sink», «str»); ⟧}
⟫;

Set-String-To-Set[Fresh[str], Free[sink, variable]]:
{#env}E-set-string-to-set[#Primitive, #Args, sink, variable] → %n⟪{⟦ String «str»;
«{#env} E-set-string-local[#Primitive, #Args, sink, str]»«variable» = makeStringLiteral(«str»); ⟧}
⟫;

Set-String-To-Bool[Fresh[str,buf], Free[sink, variable]]:
{#env}E-set-string-to-bool[#Primitive, #Args, sink, variable] → %n⟪{⟦ String «str»;
«{#env}E-set-string-local[#Primitive, #Args, sink, str]»«E-string-to-bool[]»; ⟧}
⟫;

Set-String-To-Int[Fresh[str,buf], Free[sink, variable]]:
{#env}E-set-string-to-int[#Primitive, #Args, sink, variable] → %n⟪{⟦ String «str»;
«{#env}E-set-string-local[#Primitive, #Args, sink, str]»«variable» = Long.valueOf(«str»); ⟧}
⟫;

Set-String-To-Num[Fresh[str,buf], Free[sink, variable]]:
{#env}E-set-string-to-num[#Primitive, #Args, sink, variable] → %n⟪{⟦ String «str»;
«{#env}E-set-string-local[#Primitive, #Args, sink, str]»«variable» = Double.valueOf(«str»); ⟧}
⟫;

// $[:, #1, #2, ...] corresponds to the literal with constructor named as the concatenation of the string value of the arguments.
//
STRING_PRIMITIVE[E_Concat] ;

Set-String-Concat[Fresh[builder], Free[sink, str], Discard[#Name], Copy[#Terms]]:
{#env}E-set-string[E_Concat, (#Name; #Terms), sink, str] → %n⟪{⟦ StringBuilder «builder» = new StringBuilder();
«{#env}E-concat[#Terms, builder, sink, str]»⟧ }
⟫;

Set-String-Concat-Local[Fresh[builder], Free[sink, str], Discard[#Name], Copy[#Terms]]:
{#env}E-set-string-local[E_Concat, (#Name; #Terms), sink, str] → %n⟪StringBuilder «builder» = new StringBuilder();
«{#env}E-concat[#Terms, builder, sink, str]»⟫
;

// Helper to collect string fragments and concatenate.
-[Free[builder, sink, str]]:
{#env}E-concat[(#Term; #Terms), builder, sink, str]
→
{#env} T-argument-string[#Term, sink, s.%n⟪«builder».append(«s»);
«{#env}E-concat[#Terms, builder, sink,  str]»⟫]
;

-[Free[builder, sink, str], Fresh[p]]:
{#env}E-concat[(), builder, sink, str]→ %n⟪«str» = «builder».toString();
⟫;

// $[BeforeFirst, #string, #separator[, #fallback]] is the constructor named as #string except all characters from the 
// first occurrence of #separator are omitted.
//
STRING_PRIMITIVE[E_BeforeFirst] ;

Set-String-BeforeFirst[Fresh[s1, s2, p], Free[sink, str], Discard[#Name], Copy[#String, #Sep]]:
{#env}E-set-string[E_BeforeFirst, (#Name; #String; #Sep;), sink, str] → %n⟪{⟦String «s1», «s2»;
«{#env}T-set-string-local[#String, sink, s1]»«{#env}T-set-string-local[#Sep, sink, s2]»int «p» = «s1».indexOf(«s2»);
«str» = («p» == -1 ? "" : «s1».substring(0, «p»)); ⟧}
⟫;
// TODO: fallback version.

{#env} E-set-string-local[E_BeforeFirst, #Args, #sink, #variable] → {#env}E-set-string[E_BeforeFirst, #Args, #sink, #variable];

// $[AfterFirst, #string, #separator[, #fallback]] is the constructor named as #string except all characters up to the 
// first occurrence of #separator are omitted.
//
STRING_PRIMITIVE[E_AfterFirst] ;

Set-String-AfterFirst[Fresh[p, s1, s2, l2], Free[sink, str], Discard[#Name], Copy[#String, #Sep]]:
{#env}E-set-string[E_AfterFirst, (#Name; #String; #Sep;), sink, str] → %n⟪{⟦String «s1», «s2»;
«{#env}T-set-string-local[#String, sink, s1]»«{#env}T-set-string-local[#Sep, sink, s2]»int «p» = «s1».indexOf(«s2»);
«str» = («p» == -1 ? "" : «s1».substring(«p» + 1)); ⟧}
⟫;

Set-String-AfterFirst-Local[Fresh[p, s2], Free[sink, str], Discard[#Name], Copy[#String, #Sep]]:
{#env}E-set-string-local[E_AfterFirst, (#Name; #String; #Sep;), sink, str]
→
{#env} T-argument-string[#String, sink, s1.%n⟪{⟦String «s2»;
«{#env}T-set-string-local[#Sep, sink, s2]»int «p» = «s1».indexOf(«s2»);
«str» = («p» == -1 ? "" : «s1».substring(«p» + 1)); ⟧}
⟫]
;
// TODO: fallback versions.

// $[Mangle, #1] returns #1 as a constant suitable for use as the tail end of an identifier in (at least) Java and C.
//
STRING_PRIMITIVE[E_Mangle];

Set-String-Mangle[Free[sink, str], Fresh[s]]:  
{#env}E-set-string[E_Mangle, #Args, sink, str] → %n⟪{⟦ String «s»;
« {#env}E-set-string-local[E_Mangle, #Args, sink, s] »«str» = quoteJavaIdentifierPart(«s»); ⟧}
⟫;

Set-String-Mangle-Local[Fresh[s1], Free[sink, str], Discard[#Name]]:
{#env}E-set-string-local[E_Mangle, (#Name; #String;), sink, str] → %n⟪«{#env}T-set-string-local[#String, sink, str]»«str» = quoteJavaIdentifierPart(«str»);
⟫;

// $[Escape, #1] returns #1 as a string (quoted with "s and replacing internal "s with \"). 
//
STRING_PRIMITIVE[E_Escape];

Set-String-Escape[Free[sink, str], Fresh[s]]:
{#env}E-set-string[E_Escape, #Args, sink, str] → %n⟪{⟦ String «s»;
« {#env}E-set-string-local[E_Escape, #Args, sink, s] »«str» = quote(«s»); ⟧}
⟫;

Set-String-Escape-Local[Fresh[s1], Free[sink, str], Discard[#Name], Copy[#String]]:
{#env}E-set-string-local[E_Escape, (#Name; #String;), sink, str] → %n⟪«{#env}T-set-string-local[#String, sink, str]»«str» = quote(«str»);
⟫;

// $[FormatNumber, #number ,#format] is a string representing the number (TODO: use #format).
//
// TODO: it's quite a hack for now...deprecate and use $[Format].
STRING_PRIMITIVE[E_FormatNumber];

Set-String-FormatNumber[Free[sink, variable], Fresh[s]]:  
{#env}E-set-string[E_FormatNumber, #Args, sink, variable] → %n⟪{⟦ String «s»;
« {#env}E-set-string-local[E_FormatNumber, #Args, sink, s] »«variable» = quoteJavaIdentifierPart(«s»); ⟧}
⟫;

Set-String-FormatNumber-Local[Fresh[num], Free[sink, variable], Discard[#Name, #Format]]:
{#env}E-set-string-local[E_FormatNumber, (#Name; #Number; #Format), sink, variable] → %n⟪double «num»;
« {#env}T-set-num[#Number, sink, num] »«variable» = java.text.NumberFormat.getInstance().format(«num»);
⟫;

// $[Format, #format[, #rest...]] printf-style formatting.
//
STRING_PRIMITIVE[E_Format];

Set-String-Format-None[Free[sink,variable],Discard[#Name]]:
{#env}
E-set-string[E_Format, (#Name;#String;), sink, variable]
→
{#env}
T-argument-string[#String, sink, arg . %n⟪«variable» = «arg»;
⟫]
;

Set-String-Format-Many[Free[sink,variable],Discard[#MsgSort]]:
{#env}
E-set-string[E_Format, (#Name; #Format; LITERAL[#Msg, #MsgSort]; #Args), sink, variable]
→
{#env} T-argument-string[#Format, sink, arg .
 {#env} E-flatten-strings[(), #Args, sink, %n⟪«variable» = FORMAT(«FormatKindOf[#Name]», «arg», «TOKEN[#Msg]»⟫, %n⟪);
⟫]]
;

// $[Show, #term] is a constant with the textual representation of #term as the string value. 
//
STRING_PRIMITIVE[E_Show];

Set-String-Show[Free[sink, str], Discard[#Name]]: // TODO: Implement proper semantic
{#env}E-set-string[E_Show, (#Name; #Term;), sink, str] → %n⟪{⟦
«{#env}T-set-string[#Term, sink, str]»⟧}
⟫;

{#env}E-set-string-local[E_Show, #Args, #sink, #str] → {#env}E-set-string[E_Show, #Args, #sink, #str] ;


///////////////////////////////////////////////////////////////////////////////////////////////////
// POLYMORPHIC PRIMITIVES

// Primitives for term functions defined with generic E-poly helper:
// * E-poly[PRIMITIVE, ARGUMENT_TERMS, sink, ok result.#Tail[ok,result]]
//
$Meta[(
  -[Meta,Lax]:
  POLY_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[C,$[:,##PRIMITIVE,"-send"], (Free[sink];)] : {#env} E-send[##PRIMITIVE, #Args, sink] → {#env} E-poly[##PRIMITIVE, #Args, sink, ok result.T-then-send[ok,result,sink]] ;
    $[C,$[:,##PRIMITIVE,"-set"], (Free[sink,variable];)] : {#env} E-set[##PRIMITIVE, #Args, sink, variable] → {#env} E-poly[##PRIMITIVE, #Args, sink, ok result.T-then-set[ok,result,sink,variable]] ;
    $[C,$[:,##PRIMITIVE,"-set-ref"], (Free[sink,variable];)] : {#env} E-set-ref[##PRIMITIVE, #Args, sink, variable] → {#env} E-poly[##PRIMITIVE, #Args, sink, ok result.T-then-set-ref[ok,result,sink,variable]] ;
    $[C,$[:,##PRIMITIVE,"-set-bool"], (Free[sink,variable];)] : {#env} E-set-bool[##PRIMITIVE, #Args, sink, variable] → {#env} E-poly[##PRIMITIVE, #Args, sink, ok result.T-then-set-bool[ok,result,sink,variable]] ;
    $[C,$[:,##PRIMITIVE,"-set-int"], (Free[sink,variable];)] : {#env} E-set-int[##PRIMITIVE, #Args, sink, variable] → {#env} E-poly[##PRIMITIVE, #Args, sink, ok result.T-then-set-int[ok,result,sink,variable]] ;
    $[C,$[:,##PRIMITIVE,"-set-num"], (Free[sink,variable];)] : {#env} E-set-num[##PRIMITIVE, #Args, sink, variable] → {#env} E-poly[##PRIMITIVE, #Args, sink, ok result.T-then-set-num[ok,result,sink,variable]] ;
    $[C,$[:,##PRIMITIVE,"-set-string"], (Free[sink,variable];)] : {#env} E-set-string[##PRIMITIVE, #Args, sink, variable] → {#env} E-poly[##PRIMITIVE, #Args, sink, ok result.T-then-set-string[ok,result,sink,variable]] ;
    $[C,$[:,##PRIMITIVE,"-set-string-local"], (Free[sink,variable];)] : {#env} E-set-string-local[##PRIMITIVE, #Args, sink, variable] → {#env} E-poly[##PRIMITIVE, #Args, sink, ok result.T-then-set-string-local[ok,result,sink,variable]] ;
  );
)];

// $[SaveTerm, #url, #term, #result] saves #term onto #url (for $[LoadTerm,#url] later) and the returns #result.
//
POLY_PRIMITIVE[E_SaveTerm];

Poly-SaveTerm[Fresh[term], Free[sink], Discard[#Name], Copy[#Url], Copy[#Result]]:
{#env}E-poly[E_SaveTerm, (#Name; #Url; #Term; #Result), sink, ok result.#Tail[ok,result]]
→
{#env} T-argument-string[#Url, sink, url.%n⟪{⟦ Term «term»;
«{#env} T-set[#Term, sink, term]»SAVE_TERM(«url», «term»); ⟧}
«{#env} E-optional[#Result, ok r.#Tail[ok,r]]»⟫]
;

// $[Error[#kind], #format[, #arg,...]] emits an exception.
//
POLY_PRIMITIVE[E_Error];

Poly-Error-None[Free[sink]]:
{#env} E-poly[E_Error, (#Name; #String;), sink, ok result.#Tail[ok,result]]
→
{#env} T-argument-string[#String, sink, arg . %n⟪ERRORF(«FormatKindOf[#Name]», «arg»);
« {#env} E-optional[(), ok r.#Tail[ok,r]] »⟫]
;

Poly-Error-Kind[Free[sink],Discard[#MsgSort]]:
{#env} E-poly[E_Error, (#Name; #Format; LITERAL[#Msg, #MsgSort]; #Args), sink, ok result.#Tail[ok,result]]
→
{#env} T-argument-string[#Format, sink, arg .
 {#env} E-flatten-strings[(), #Args, sink, %n⟪ERRORF(«FormatKindOf[#Name]», «arg», «STRING[#Msg]»⟫, %n⟪);
« {#env} E-optional[(), ok r.#Tail[ok,r]] »⟫]]
;

Poly-Error-Other[Free[sink],Discard[#Msg,#MsgSort]]:
{#env} E-poly[E_Error, (#Name; #Format; $[NotMatch,LITERAL[#Msg, #MsgSort],#Arg1]; #Args), sink, ok result.#Tail[ok,result]]
→
{#env} T-argument-string[#Format, sink, arg .
 {#env} E-flatten-strings[(), (#Arg1; #Args), sink, %n⟪ERRORF(«FormatKindOf[#Name]»⟫, %n⟪);
« {#env} E-optional[(), ok r.#Tail[ok,r]] »⟫]]
;

-[Discard[#Name,#KindSort]] : FormatKindOf[CONSTRUCTION[#Name, (ARGUMENT[(), LITERAL[#Kind, #KindSort]]; )]] → TOKEN[#Kind] ;
-[Discard[#Name]] : FormatKindOf[CONSTRUCTION[#Name, (ARGUMENT[(), CONSTRUCTION[#Kind, ()]]; )]] → TOKEN[#Kind] ;
-[Discard[#Name]] : FormatKindOf[CONSTRUCTION[#Name, ()]] → TOKEN[Default] ;
-[Discard[#Name,#Sort]] : FormatKindOf[LITERAL[#Name, #Sort]] → TOKEN[Default] ;

// $[Trace[#kind], #message, #esult] prints the message
// $[Trace[#kind], #esult] just returns the result
//
POLY_PRIMITIVE[E_Trace];

Poly-Trace-Message[Free[sink],Copy[#Result]]:
{#env} E-poly[E_Trace, (#Name; #String; #Result;), sink, ok result.#Tail[ok,result]]
→
{#env} T-argument-string[#String, sink, arg . %n⟪TRACEF(«FormatKindOf[#Name]», «arg»);
«{#env}#Tail[OK,#Result] »⟫]
;

Poly-Trace-None[Free[sink],Copy[#Result],Discard[#Name]]:
{#env} E-poly[E_Trace, (#Name; #Result;), sink, ok result.#Tail[ok,result]]
→
{#env}#Tail[OK,#Result]
;

// Rules to flatten reified list to non-reified list.
//
// No work item, no list: done.
-[Discard[#sink]]:
{#env} E-flatten-strings[(), (), #sink, #pre, #post]
→
%n⟪{⟦«#pre»«#post»⟧}⟫
;

// No work item, one more list item: work with it.
{#env} E-flatten-strings[(), (#Arg; #Args), #sink, #pre, #post]
 →
{#env} E-flatten-strings[#Arg, #Args, #sink, #pre, #post]
;

// Work item is empty list: remove.
{#env} E-flatten-strings[CONSTRUCTION["$Nil", ()], #Args, #sink, #pre, #post]
→
{#env} E-flatten-strings[(), #Args, #sink, #pre, #post]
;

// Work item is list: split and delay tail part and proceed.
-[Discard[#S1,#S2]]:
{#env} E-flatten-strings[CONSTRUCTION["$Cons", (ARGUMENT[#S1,#Arg1];ARGUMENT[#S2,#Args1];)], #Args2, #sink, #pre, #post]
→
{#env} E-flatten-strings[#Arg1, (#Args1;#Args2), #sink, #pre, #post]
;

// Work item is non-list (we hope string): Emit and recurse.
-[Free[sink],Discard[#S1,#Arg1,#S2,#Args1]]:
{#env} E-flatten-strings[$[NotMatch,CONSTRUCTION["$Nil",()],$[NotMatch,CONSTRUCTION["$Cons",(ARGUMENT[#S1,#Arg1];ARGUMENT[#S2,#Args1];)],#Arg]], #Args, sink, #pre, #post]
→
{#env} T-argument-string[#Arg, sink, arg . {#env} E-flatten-strings[(), #Args, sink, %n⟨‹#pre›, ‹arg›⟩, #post]]
;

// $[If, #test, #true[, #false]] with constant #test evaluates as either #true or #false depending on test.
//
POLY_PRIMITIVE[E_If];

Poly-If[Fresh[test], Free[sink], Discard[#Name], Copy[#Tail,#Yes]]:
{#env}E-poly[E_If, (#Name; #Test; #Yes; #Nos), sink, ok result.#Tail[ok,result]] → %n⟪{⟦ boolean «test»;
«{#env}T-set-bool[#Test, sink, test]»if («test») { ⟦«{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, ok no.#Tail[ok,no]]» ⟧}⟧
}
⟫;

// $[IfZero, #int, #true[, #false]] with constant integer #int evaluates as either #true or #false depending on whether #i is zero.
//
POLY_PRIMITIVE[E_IfZero];

Poly-IfZero[Fresh[int], Free[sink], Discard[#Name], Copy[#Tail,#Yes]]:
{#env}E-poly[E_IfZero, (#Name; #Int; #Yes; #Nos), sink, ok result.#Tail[ok,result]] → %n⟪{⟦ long «int»;
«{#env}T-set-int[#Int, sink, int]»if («int» == 0l) { ⟦«{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, ok no.#Tail[ok,no]]» ⟧}⟧
}
⟫;

// $[IfEmpty, #str, #true[, #false]] with constant string #str evaluates as either #true or #false depending on whether it is the empty string.
//
POLY_PRIMITIVE[E_IfEmpty];

Poly-IfEmpty[Fresh[str], Free[sink], Discard[#Name], Copy[#Tail,#Yes]]:
{#env}E-poly[E_IfEmpty, (#Name; #Str; #Yes; #Nos), sink, ok result.#Tail[ok,result]] → %n⟪{⟦ String «str»;
«{#env}T-set-string-local[#Str, sink, str]»if («str».isEmpty()) { ⟦«{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, ok no.#Tail[ok,no]]» ⟧}⟧
}
⟫;

// $[{#environment}IfDef, #name, #true[, #false]] with constant #name evaluates as either #true or #false depending on whether name is defined in #environment,
// If {#environment} is omitted completely, the system environment is searched.
//
POLY_PRIMITIVE[E_IfDef];

Poly-IfDef[Fresh[key,value], Free[sink], Discard[#Name], Copy[#Tail,#Yes]]:
{#env}E-poly[E_IfDef, (PROPERTY-REF[#Ref, #Name]; #Key; #Yes; #Nos), sink, ok result.#Tail[ok,result]] → %n⟪{⟦ Term «key»;
«{#env}T-set[#Key, sink, key]»Term «value» = «{#env}E-Get-Property[$[:,"MetaVar$",#Ref], key]»;
if («value» != null) {⟦ «{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, ok no.#Tail[ok,no]]» ⟧}⟧
}
⟫;

Poly-IfDef-Global[Fresh[value], Free[sink], Discard[#_Ref,#_Name,#Name], Copy[#Tail,#Yes]]:
{#env}E-poly[E_IfDef, ($[NotMatch,PROPERTY-REF[#_Ref, #_Name],#Name]; #Key; #Yes; #Nos), sink, ok result.#Tail[ok,result]]
→
{#env} T-argument-string[#Key, sink, key.%n⟪{⟦ String «value» = System.getenv(«key»);
if («value» != null) {⟦ «{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, ok no.#Tail[ok,no]]» ⟧}⟧
}
⟫];


///////////////////////////////////////////////////////////////////////////////////////////////////
// PATTERNS.

// $[Match, #First, #Second, ...]

{#env} E-Pattern[E_Match, #Patterns, #pass, #stage, #sink, #termp, ok.#[ok]]
→
{#env} E-Pattern-All[#Patterns, #pass, #stage, #sink, #termp, ok.#[ok]]
;

-[Discard[#pass, #stage, #sink, #termp]]
:
{#env} E-Pattern-All[(), #pass, #stage, #sink, #termp, ok.#[ok]]
→
{#env} #[OK]
;

-[Copy[#pass,#stage],Free[sink,termp]]
:
{#env} E-Pattern-All[(#Pattern;#Patterns), #pass, #stage, sink, termp, ok.#[ok]]
→
{#env} F-Pattern[#pass, #stage, #Pattern, sink, %n⟨⟩, $False, $False, termp, ok.E-then-Pattern-All[ok, #Patterns, #pass, #stage, sink, termp, o2.#[o2]]]
;

{#env} E-then-Pattern-All[OK, #Patterns, #pass, #stage, #sink, #termp, ok.#[ok]]
→
{#env} E-Pattern-All[#Patterns, #pass, #stage, #sink, #termp, ok.#[ok]]
;


///////////////////////////////////////////////////////////////////////////////////////////////////
)] //EVAL

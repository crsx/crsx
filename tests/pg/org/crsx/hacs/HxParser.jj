/* org.crsx.hacs.HxParser: PG-generated JavaCC parser specification. */

options {
	SANITY_CHECK  = true;
	BUILD_PARSER = true;
	JDK_VERSION = "1.5";
	ERROR_REPORTING = true;
	DEBUG_PARSER = true;
	BUILD_TOKEN_MANAGER = true;
	FORCE_LA_CHECK = true;
	STATIC = false;
}

PARSER_BEGIN(HxParser)
package org.crsx.hacs;

/** HxParser.pg: GRAMMAR FOR .hx HACS FILES. */
public class HxParser implements net.sf.crsx.Parser
{
	/** Factory. */
	net.sf.crsx.Factory<? extends net.sf.crsx.Term> factory;
	/** Compilation unit name for error messages. */
	String unit;
	/** Whether the parser should capture token locations. */
	boolean captureLocations = true;
	/** Constructor with token location information. */
	private net.sf.crsx.Constructor makeTConstructor(net.sf.crsx.Sink sink, Token t, Object object, String sort)
	{
		net.sf.crsx.Constructor c = sort == null ? sink.makeConstructor(object) : sink.makeLiteral(object, sort);
		if (t == null) t = token;
		if (captureLocations && t != null)
		{
			if (factory.get("meta") == null)
				c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn);
		}
		return c;
	}

	/** Helper interface with category non-terminal calls. */
	abstract class CategoryCall { abstract net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException; }
	/** Direct category invocations. */
	java.util.Map<String,CategoryCall> categoryCall = new java.util.HashMap<String,CategoryCall>();
	{
		categoryCall.put("hx", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Module$WithEOF(sink, bound);} });
		categoryCall.put("hxModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Module$WithEOF(sink, bound);} });
		categoryCall.put("hxModuleName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ModuleName$WithEOF(sink, bound);} });
		categoryCall.put("hxEmbeddedModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_EmbeddedModule$WithEOF(sink, bound);} });
		categoryCall.put("hxDeclaration", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Declaration$WithEOF(sink, bound);} });
		categoryCall.put("hxDeclarations", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Declarations$WithEOF(sink, bound);} });
		categoryCall.put("hxSortAbstraction", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortAbstraction$WithEOF(sink, bound);} });
		categoryCall.put("hxRule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Rule$WithEOF(sink, bound);} });
		categoryCall.put("hxSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Sort$WithEOF(sink, bound);} });
		categoryCall.put("hxSortParam", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortParam$WithEOF(sink, bound);} });
		categoryCall.put("hxSortName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortName$WithEOF(sink, bound);} });
		categoryCall.put("hxSortNames", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortNames$WithEOF(sink, bound);} });
		categoryCall.put("hxSimpleSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SimpleSort$WithEOF(sink, bound);} });
		categoryCall.put("hxSimpleSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SimpleSorts$WithEOF(sink, bound);} });
		categoryCall.put("hxSubstituteSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SubstituteSorts$WithEOF(sink, bound);} });
		categoryCall.put("hxSubstituteSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SubstituteSort$WithEOF(sink, bound);} });
		categoryCall.put("hxTagging", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Tagging$WithEOF(sink, bound);} });
		categoryCall.put("hxSortAlternative", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortAlternative$WithEOF(sink, bound);} });
		categoryCall.put("hxSortAlternatives", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_SortAlternatives$WithEOF(sink, bound);} });
		categoryCall.put("hxForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Form$WithEOF(sink, bound);} });
		categoryCall.put("hxFormPrec", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_FormPrec$WithEOF(sink, bound);} });
		categoryCall.put("hxInheritedRefs", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_InheritedRefs$WithEOF(sink, bound);} });
		categoryCall.put("hxInheritedRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_InheritedRef$WithEOF(sink, bound);} });
		categoryCall.put("hxAttributeKind", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeKind$WithEOF(sink, bound);} });
		categoryCall.put("hxAttributeForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeForm$WithEOF(sink, bound);} });
		categoryCall.put("hxAttributeOptions", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeOptions$WithEOF(sink, bound);} });
		categoryCall.put("hxAttributeOption", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeOption$WithEOF(sink, bound);} });
		categoryCall.put("hxBindersScopeSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_BindersScopeSorts$WithEOF(sink, bound);} });
		categoryCall.put("hxBindersScopeSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_BindersScopeSort$WithEOF(sink, bound);} });
		categoryCall.put("hxScopeSortPrecRepeat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ScopeSortPrecRepeat$WithEOF(sink, bound);} });
		categoryCall.put("hxScopeSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ScopeSort$WithEOF(sink, bound);} });
		categoryCall.put("hxRepeat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Repeat$WithEOF(sink, bound);} });
		categoryCall.put("hxPriority", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Priority$WithEOF(sink, bound);} });
		categoryCall.put("hxFragmentName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_FragmentName$WithEOF(sink, bound);} });
		categoryCall.put("hxFragmentRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_FragmentRef$WithEOF(sink, bound);} });
		categoryCall.put("hxRegExp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExp$WithEOF(sink, bound);} });
		categoryCall.put("hxRegExpChoice", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpChoice$WithEOF(sink, bound);} });
		categoryCall.put("hxRegExpUnits", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpUnits$WithEOF(sink, bound);} });
		categoryCall.put("hxRegExpUnit", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpUnit$WithEOF(sink, bound);} });
		categoryCall.put("hxRegExpSimple", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpSimple$WithEOF(sink, bound);} });
		categoryCall.put("hxRegExpLeaf", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpLeaf$WithEOF(sink, bound);} });
		categoryCall.put("hxWord", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Word$WithEOF(sink, bound);} });
		categoryCall.put("hxTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Term$WithEOF(sink, bound);} });
		categoryCall.put("hxNotVariableTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_NotVariableTerm$WithEOF(sink, bound);} });
		categoryCall.put("hxAttributes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Attributes$WithEOF(sink, bound);} });
		categoryCall.put("hxAttribute", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Attribute$WithEOF(sink, bound);} });
		categoryCall.put("hxAttributeValue", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeValue$WithEOF(sink, bound);} });
		categoryCall.put("hxScopes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Scopes$WithEOF(sink, bound);} });
		categoryCall.put("hxScope", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Scope$WithEOF(sink, bound);} });
		categoryCall.put("hxTerms", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Terms$WithEOF(sink, bound);} });
		categoryCall.put("hxLiteral", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Literal$WithEOF(sink, bound);} });
		categoryCall.put("hxConstructor", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Constructor$WithEOF(sink, bound);} });
		categoryCall.put("hxMetaVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_MetaVariable$WithEOF(sink, bound);} });
		categoryCall.put("hxMetaVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_MetaVariables$WithEOF(sink, bound);} });
		categoryCall.put("hxVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Variable$WithEOF(sink, bound);} });
		categoryCall.put("hxVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Variables$WithEOF(sink, bound);} });
		categoryCall.put("hxAttributeName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_AttributeName$WithEOF(sink, bound);} });
		categoryCall.put("hxRegExpClass", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_RegExpClass$WithEOF(sink, bound);} });
		categoryCall.put("hxCC", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC$WithEOF(sink, bound);} });
		categoryCall.put("hxCC_RangesTop", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_RangesTop$WithEOF(sink, bound);} });
		categoryCall.put("hxCC_Ranges", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_Ranges$WithEOF(sink, bound);} });
		categoryCall.put("hxCC_FirstRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_FirstRangeStartChar$WithEOF(sink, bound);} });
		categoryCall.put("hxCC_NonDashRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_NonDashRangeStartChar$WithEOF(sink, bound);} });
		categoryCall.put("hxCC_RangeChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_CC_RangeChar$WithEOF(sink, bound);} });
		categoryCall.put("hxParsedForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_ParsedForm$WithEOF(sink, bound);} });
		categoryCall.put("hxPP", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_PP$WithEOF(sink, bound);} });
	}

	// Constructor.

	/** Construct dummy instance. */
	public HxParser()
	{
		this((java.io.Reader) null);
		disable_tracing();
	}

	// Parser implementation.

	public net.sf.crsx.Parser parser(net.sf.crsx.Factory<? extends net.sf.crsx.Term> f)
	{
		if (factory != null)
		{
			net.sf.crsx.Parser parser = new HxParser().parser(f);
			parser.setParserVerbose(trace_enabled); parser.setParserLocation(captureLocations);
			return parser;
		}
		else
		{
			factory = f;
			assert f != null : "Or Else!";
			return this;
		}
	}

	public void setParserVerbose(boolean verbose)
	{
		if (verbose)
			enable_tracing();
		else
			disable_tracing();
	}

	public void setParserLocation(boolean capture)
	{
		captureLocations = capture;
	}

	public void setEmbeddedParser(net.sf.crsx.Parser subparser) throws net.sf.crsx.CRSException
	{}

	public Iterable<String> categories()
	{
		return categoryCall.keySet();
	}

	public net.sf.crsx.Sink parse(net.sf.crsx.Sink sink, String category, java.io.Reader reader, String unit, int firstLine, int firstColumn, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
	{
		try
		{
			this.unit = unit;
			ReInit((java.io.Reader) null);
			jj_input_stream.ReInit(reader, firstLine, firstColumn); token_source = new HxParserTokenManager(jj_input_stream); // hacks to update line and column numbers
			if (bound == null) bound = new net.sf.crsx.util.LinkedExtensibleMap<String, net.sf.crsx.Variable>();
			if (category == null || category.length() == 0) return N_Module(sink, bound);
			else if (categoryCall.containsKey(category)) return categoryCall.get(category).call(sink, bound);
			else throw new net.sf.crsx.CRSException("Parser category '"+category+"' not supported!");
		}
		catch (ParseException e)
		{
			throw new net.sf.crsx.CRSException(e.getMessage());
		}
	}

	public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
	{
		net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
		parse(buffer.sink(), category, reader, null, 1, 1, bound);
		return buffer.term(true);
	}


static String hx(String s) {return "HX_"+s;} // prefix for constructors
static String unwrap(String s) {return s.substring(1, s.length()-1);}
static String unpp(String s) {return "\001"+s.substring(1, s.length()-1)+"\001";}
static String checkModuleString(String s) throws ParseException {if (java.util.regex.Pattern.matches("[\"]([a-z0-9]+[.])*[A-Z][A-Za-z0-9]*[\"]", s)) return s; else throw new ParseException("Illegal module name "+s);}

private String storedSort = "";

	/**
	 * Run the parser and print the resulting term.
	 * @param args should contain two strings: the category and an input file name
	 */
	public static void main(String[] args)
	{
		try
		{
			if (args.length != 2)
			{
				System.err.println("Usage: HxParser category input");
				System.exit(2);
			}
			String category = args[0];
			java.io.Reader reader = new java.io.FileReader(args[1]);
			net.sf.crsx.Factory<net.sf.crsx.generic.GenericTerm> factory = new net.sf.crsx.generic.GenericFactory();
			net.sf.crsx.Parser parser = new HxParser();
			net.sf.crsx.Sink sink = factory.sink(System.out);
			parser.parser(factory).parse(sink, category, reader, null, 1, 1, null);
		}
		catch (net.sf.crsx.CRSException e)
		{
			System.err.println("CRS error: "+e);
			System.exit(1);
		}
		catch (java.io.IOException e)
		{
			System.err.println("I/O error: "+e);
			System.exit(1);
		}
	}

}
PARSER_END(HxParser)

/**
 * <em>Embedded</em> ::=   <a href="#T_Embedded">Embedded</a><font color="red">$$:unwrap</font> 
 */
net.sf.crsx.Sink N_Embedded(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	 ( 
	t=<T_Embedded>
	{
		try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

/** <em>Module$WithEOF</em> ::= <em>Module</em> EOF . */
net.sf.crsx.Sink N_Module$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Module(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Module production. */
TOKEN : {<MT_Module : "#Module" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Module production. */
TOKEN : {<IT_Module : "%Module">}

/**
 * <em>Module</em> ::=  <font color="red">{top-module}</font><font color="red">:hx</font>   <a href="#N_EmbeddedModule">&lang;EmbeddedModule&rang;</a>  
 */
net.sf.crsx.Sink N_Module(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Module> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Module>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("top-module"), null)) ;
	}
	 ) 
	 ( 
	sink=N_EmbeddedModule(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>EmbeddedModule$WithEOF</em> ::= <em>EmbeddedModule</em> EOF . */
net.sf.crsx.Sink N_EmbeddedModule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_EmbeddedModule(sink, env) <EOF> {return sink;} }

/** Special meta-variable for EmbeddedModule production. */
TOKEN : {<MT_EmbeddedModule : "#EmbeddedModule" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token EmbeddedModule production. */
TOKEN : {<IT_EmbeddedModule : "%EmbeddedModule">}

/**
 * <em>EmbeddedModule</em> ::=   <a href="#T_MODULE">MODULE</a><font color="red">:hx</font>   <a href="#N_ModuleName">&lang;ModuleName&rang;</a>     <a href="#T_LBRACE">LBRACE</a>   <a href="#N_Storing_Declarations">&lang;Storing_Declarations&rang;</a>     <a href="#T_RBRACE">RBRACE</a> 
 */
net.sf.crsx.Sink N_EmbeddedModule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_EmbeddedModule> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_EmbeddedModule>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_MODULE>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_ModuleName(sink, env)
	 ) 
	 ( 
	 <T_LBRACE>
	 ) 
	 ( 
	sink=N_Storing_Declarations(sink, env)
	 ) 
	 ( 
	 <T_RBRACE>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Declarations$WithEOF</em> ::= <em>Declarations</em> EOF . */
net.sf.crsx.Sink N_Declarations$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Declarations(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Declarations production. */
TOKEN : {<MT_Declarations : "#Declarations" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Declarations production. */
TOKEN : {<IT_Declarations : "%Declarations">}

/**
 * <em>Declarations</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_Declaration">&lang;Declaration&rang;</a>    <a href="#N_Declarations">&lang;Declarations&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Declarations(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Declarations> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Declarations>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		sink=N_Declaration(sink, env)
		 ) 
		 ( 
		sink=N_Declarations(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Declaration$WithEOF</em> ::= <em>Declaration</em> EOF . */
net.sf.crsx.Sink N_Declaration$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Declaration(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Declaration production. */
TOKEN : {<MT_Declaration : "#Declaration" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Declaration production. */
TOKEN : {<IT_Declaration : "%Declaration">}

/**
 * <em>Declaration</em> ::=  <font color="red">{embedded-module}</font><font color="red">:hx</font>   <a href="#N_EmbeddedModule">&lang;EmbeddedModule&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_IMPORT">IMPORT</a><font color="red">:hx</font>   <a href="#N_ModuleName">&lang;ModuleName&rang;</a>    (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_SortNames">&lang;SortNames&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |  <font color="red">{$Nil}</font>  )    <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_SPACE">SPACE</a><font color="red">:hx</font>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_TOKEN">TOKEN</a>   (  <font color="red">{'token'}</font><font color="red">:hx</font>   <a href="#N_Store_SortName">&lang;Store_SortName&rang;</a>     <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  |   <a href="#T_FRAGMENT">FRAGMENT</a><font color="red">:hx</font>   <a href="#N_FragmentName">&lang;FragmentName&rang;</a>     <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  )  <br>
 *  |   <a href="#T_FRAGMENT">FRAGMENT</a><font color="red">:hx</font>   <a href="#N_FragmentName">&lang;FragmentName&rang;</a>     <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |   <a href="#T_ATTRIBUTE">ATTRIBUTE</a><font color="red">:hx</font>   <a href="#N_AttributeKind">&lang;AttributeKind&rang;</a>    <a href="#N_AttributeName">&lang;AttributeName&rang;</a>    <a href="#N_AttributeForm">&lang;AttributeForm&rang;</a>    <a href="#N_AttributeOptions">&lang;AttributeOptions&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  <font color="red">{sort}</font><font color="red">:hx</font>   (   <a href="#T_START">START</a><font color="red">:hx</font>  |  <font color="red">{no-start}</font><font color="red">:hx</font>  )    <a href="#T_SORT">SORT</a>   <a href="#N_Store_SortName">&lang;Store_SortName&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>    <a href="#N_SortAbstraction">&lang;SortAbstraction&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  <font color="red">{anonymous}</font><font color="red">:hx</font>   <a href="#N_SortAlternatives">&lang;SortAlternatives&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  (   <a href="#T_RULE">RULE</a>  )?   <font color="red">{rule}</font><font color="red">:hx</font>   <a href="#N_Rule">&lang;Rule&rang;</a>     <a href="#T_SEMI">SEMI</a>  <br>
 *  |  <font color="red">{nestedDeclarations}</font><font color="red">:hx</font>    <a href="#T_LBRACE">LBRACE</a>   <a href="#N_Declarations">&lang;Declarations&rang;</a>     <a href="#T_RBRACE">RBRACE</a> 
 */
net.sf.crsx.Sink N_Declaration(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Declaration> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Declaration>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("embedded-module"), null)) ;
	}
	 ) 
	 ( 
	sink=N_EmbeddedModule(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_IMPORT>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_ModuleName(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_LPAREN>
		 ) 
		 ( 
			 ( 
			sink=N_SortNames(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_RPAREN>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_SPACE>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExp(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_TOKEN>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("token"), null)) ;
		}
		 ) 
		 ( 
		sink=N_Store_SortName(sink, env)
		 ) 
		 ( 
		 <T_BAR>
		 ) 
		 ( 
		sink=N_RegExp(sink, env)
		 ) 
		 ( 
		 <T_SEMI>
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_FRAGMENT>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_FragmentName(sink, env)
		 ) 
		 ( 
		 <T_BAR>
		 ) 
		 ( 
		sink=N_RegExp(sink, env)
		 ) 
		 ( 
		 <T_SEMI>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	t=<T_FRAGMENT>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_FragmentName(sink, env)
	 ) 
	 ( 
	 <T_BAR>
	 ) 
	 ( 
	sink=N_RegExp(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_ATTRIBUTE>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_AttributeKind(sink, env)
	 ) 
	 ( 
	sink=N_AttributeName(sink, env)
	 ) 
	 ( 
	sink=N_AttributeForm(sink, env)
	 ) 
	 ( 
	sink=N_AttributeOptions(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("sort"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		t=<T_START>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("no-start"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	 <T_SORT>
	 ) 
	 ( 
	sink=N_Store_SortName(sink, env)
	 ) 
	 ( 
	sink=N_Repeat(sink, env)
	 ) 
	 ( 
	sink=N_SortAbstraction(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("anonymous"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortAlternatives(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
		 ( 
		 <T_RULE>
		 ) 
	 )? 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("rule"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Rule(sink, env)
	 ) 
	 ( 
	 <T_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("nestedDeclarations"), null)) ;
	}
	 ) 
	 ( 
	 <T_LBRACE>
	 ) 
	 ( 
	sink=N_Declarations(sink, env)
	 ) 
	 ( 
	 <T_RBRACE>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExp$WithEOF</em> ::= <em>RegExp</em> EOF . */
net.sf.crsx.Sink N_RegExp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExp(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExp production. */
<RE> TOKEN : {<MT_RegExp : "#RegExp" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExp production. */
<RE> TOKEN : {<IT_RegExp : "%RegExp">}

/**
 * <em>RegExp</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_RegExpChoice">&lang;RegExpChoice&rang;</a>    (   <a href="#T_BAR">BAR</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_RegExp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExp> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExp>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpChoice(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_BAR>
		 ) 
		 ( 
		sink=N_RegExp(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpChoice$WithEOF</em> ::= <em>RegExpChoice</em> EOF . */
net.sf.crsx.Sink N_RegExpChoice$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpChoice(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpChoice production. */
<RE> TOKEN : {<MT_RegExpChoice : "#RegExpChoice" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpChoice production. */
<RE> TOKEN : {<IT_RegExpChoice : "%RegExpChoice">}

/**
 * <em>RegExpChoice</em> ::=   <a href="#T_NESTED">NESTED</a><font color="red">:hx</font>   <a href="#N_RegExpSimple">&lang;RegExpSimple&rang;</a>    <a href="#N_RegExpSimple">&lang;RegExpSimple&rang;</a>   <br>
 *  |  <font color="red">{RegExpConcat}</font><font color="red">:hx</font>   <a href="#N_RegExpUnits">&lang;RegExpUnits&rang;</a>  
 */
net.sf.crsx.Sink N_RegExpChoice(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpChoice> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpChoice>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_NESTED>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpSimple(sink, env)
	 ) 
	 ( 
	sink=N_RegExpSimple(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpConcat"), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpUnits(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpUnits$WithEOF</em> ::= <em>RegExpUnits</em> EOF . */
net.sf.crsx.Sink N_RegExpUnits$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpUnits(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpUnits production. */
<RE> TOKEN : {<MT_RegExpUnits : "#RegExpUnits" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpUnits production. */
<RE> TOKEN : {<IT_RegExpUnits : "%RegExpUnits">}

/**
 * <em>RegExpUnits</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_RegExpUnit">&lang;RegExpUnit&rang;</a>    <a href="#N_RegExpUnits">&lang;RegExpUnits&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_RegExpUnits(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpUnits> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpUnits>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpUnit(sink, env)
	 ) 
	 ( 
	sink=N_RegExpUnits(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpUnit$WithEOF</em> ::= <em>RegExpUnit</em> EOF . */
net.sf.crsx.Sink N_RegExpUnit$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpUnit(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpUnit production. */
<RE> TOKEN : {<MT_RegExpUnit : "#RegExpUnit" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpUnit production. */
<RE> TOKEN : {<IT_RegExpUnit : "%RegExpUnit">}

/**
 * <em>RegExpUnit</em> ::=  <font color="red">{RegExpUnit}</font><font color="red">:hx</font>   <a href="#N_RegExpSimple">&lang;RegExpSimple&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>  
 */
net.sf.crsx.Sink N_RegExpUnit(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpUnit> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpUnit>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpUnit"), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpSimple(sink, env)
	 ) 
	 ( 
	sink=N_Repeat(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Repeat$WithEOF</em> ::= <em>Repeat</em> EOF . */
net.sf.crsx.Sink N_Repeat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_Repeat(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Repeat production. */
<DEFAULT, RE> TOKEN : {<MT_Repeat : "#Repeat" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Repeat production. */
<DEFAULT, RE> TOKEN : {<IT_Repeat : "%Repeat">}

/**
 * <em>Repeat</em> ::=   <a href="#T_PLUS">PLUS</a>   (  <font color="red">{RepeatSomeSep}</font><font color="red">:hx</font>    <a href="#T_SUB">SUB</a>   (  <a href="#N_RegExpLeaf">&lang;RegExpLeaf&rang;</a>   |  <font color="red">{RegExpWord}</font><font color="red">:hx</font>   <a href="#N_Separator">&lang;Separator&rang;</a>   )  |  <font color="red">{RepeatSome}</font><font color="red">:hx</font>  )  <br>
 *  |  <font color="red">{RepeatMaybeSome}</font><font color="red">:hx</font>    <a href="#T_STAR">STAR</a>  <br>
 *  |  <font color="red">{RepeatMaybe}</font><font color="red">:hx</font>    <a href="#T_QUEST">QUEST</a>  <br>
 *  |  <font color="red">{RepeatSingle}</font><font color="red">:hx</font> 
 */
net.sf.crsx.Sink N_Repeat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Repeat> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Repeat>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	 <T_PLUS>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RepeatSomeSep"), null)) ;
		}
		 ) 
		 ( 
		 <T_SUB>
		 ) 
		 ( 
			 ( 
			sink=N_RegExpLeaf(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, hx("RegExpWord"), null)) ;
			}
			 ) 
			 ( 
			sink=N_Separator(sink, env)
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RepeatSome"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RepeatMaybeSome"), null)) ;
	}
	 ) 
	 ( 
	 <T_STAR>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RepeatMaybe"), null)) ;
	}
	 ) 
	 ( 
	 <T_QUEST>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RepeatSingle"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpLeaf$WithEOF</em> ::= <em>RegExpLeaf</em> EOF . */
net.sf.crsx.Sink N_RegExpLeaf$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_RegExpLeaf(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpLeaf production. */
<DEFAULT, RE> TOKEN : {<MT_RegExpLeaf : "#RegExpLeaf" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpLeaf production. */
<DEFAULT, RE> TOKEN : {<IT_RegExpLeaf : "%RegExpLeaf">}

/**
 * <em>RegExpLeaf</em> ::=  <font color="red">{RegExpString}</font><font color="red">:hx</font>   <a href="#N_String">&lang;String&rang;</a>   <br>
 *  |  <font color="red">{RegExpWord}</font><font color="red">:hx</font>   <a href="#N_Word">&lang;Word&rang;</a>  
 */
net.sf.crsx.Sink N_RegExpLeaf(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpLeaf> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpLeaf>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpString"), null)) ;
	}
	 ) 
	 ( 
	sink=N_String(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpWord"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Word(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>RegExpSimple$WithEOF</em> ::= <em>RegExpSimple</em> EOF . */
net.sf.crsx.Sink N_RegExpSimple$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpSimple(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpSimple production. */
<RE> TOKEN : {<MT_RegExpSimple : "#RegExpSimple" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpSimple production. */
<RE> TOKEN : {<IT_RegExpSimple : "%RegExpSimple">}

/**
 * <em>RegExpSimple</em> ::=  <a href="#N_RegExpLeaf">&lang;RegExpLeaf&rang;</a>   <br>
 *  |  <font color="red">{RegExpRef}</font><font color="red">:hx</font>   <a href="#N_FragmentRef">&lang;FragmentRef&rang;</a>   <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:hx</font>   <a href="#N_RegExpClass">&lang;RegExpClass&rang;</a>   <br>
 *  |  <font color="red">{RegExpAny}</font><font color="red">:hx</font>    <a href="#T_DOT">DOT</a>  <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:hx</font>   <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   (   <a href="#T_ESCAPEDCHAR">ESCAPEDCHAR</a><font color="red">$</font>  )   <font color="red">{RegExpClassDone}</font><font color="red">:hx</font>  <br>
 *  |  <font color="red">{RegExpNest}</font><font color="red">:hx</font>    <a href="#T_LPAREN">LPAREN</a>   <a href="#N_RegExp">&lang;RegExp&rang;</a>     <a href="#T_RPAREN">RPAREN</a> 
 */
net.sf.crsx.Sink N_RegExpSimple(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpSimple> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpSimple>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_RegExpLeaf(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpRef"), null)) ;
	}
	 ) 
	 ( 
	sink=N_FragmentRef(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClass"), null)) ;
	}
	 ) 
	 ( 
	sink=N_RegExpClass(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpAny"), null)) ;
	}
	 ) 
	 ( 
	 <T_DOT>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClass"), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		t=<T_ESCAPEDCHAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
	}
	 ) 
	{
		return sink .end().end().end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpNest"), null)) ;
	}
	 ) 
	 ( 
	 <T_LPAREN>
	 ) 
	 ( 
	sink=N_RegExp(sink, env)
	 ) 
	 ( 
	 <T_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>AttributeForm$WithEOF</em> ::= <em>AttributeForm</em> EOF . */
net.sf.crsx.Sink N_AttributeForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeForm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeForm production. */
TOKEN : {<MT_AttributeForm : "#AttributeForm" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeForm production. */
TOKEN : {<IT_AttributeForm : "%AttributeForm">}

/**
 * <em>AttributeForm</em> ::=  <font color="red">{AttributeFormSimple}</font><font color="red">:hx</font>    <a href="#T_LPAREN">LPAREN</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RPAREN">RPAREN</a>  <br>
 *  |   <a href="#T_LBRACE">LBRACE</a>   <a href="#N_Sort">&lang;Sort&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeFormMap}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  |  <font color="red">{AttributeFormSet}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_RBRACE">RBRACE</a>  ) 
 */
net.sf.crsx.Sink N_AttributeForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink bs__ = null;
	net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_AttributeForm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeForm>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("AttributeFormSimple"), null)) ;
	}
	 ) 
	 ( 
	 <T_LPAREN>
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	 <T_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_LBRACE>
	 ) 
	 ( 
	{
		bs__ = b__.sink();
	}
	N_Sort(bs__, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeFormMap"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__, true) ;
		}
		 ) 
		 ( 
		 <T_COLON>
		 ) 
		 ( 
		sink=N_Sort(sink, env)
		 ) 
		 ( 
		 <T_RBRACE>
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeFormSet"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__, true) ;
		}
		 ) 
		 ( 
		 <T_RBRACE>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>AttributeOptions$WithEOF</em> ::= <em>AttributeOptions</em> EOF . */
net.sf.crsx.Sink N_AttributeOptions$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeOptions(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeOptions production. */
TOKEN : {<MT_AttributeOptions : "#AttributeOptions" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeOptions production. */
TOKEN : {<IT_AttributeOptions : "%AttributeOptions">}

/**
 * <em>AttributeOptions</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_AttributeOption">&lang;AttributeOption&rang;</a>    <a href="#N_AttributeOptions">&lang;AttributeOptions&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_AttributeOptions(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_AttributeOptions> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeOptions>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_AttributeOption(sink, env)
	 ) 
	 ( 
	sink=N_AttributeOptions(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>AttributeOption$WithEOF</em> ::= <em>AttributeOption</em> EOF . */
net.sf.crsx.Sink N_AttributeOption$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeOption(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeOption production. */
TOKEN : {<MT_AttributeOption : "#AttributeOption" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeOption production. */
TOKEN : {<IT_AttributeOption : "%AttributeOption">}

/**
 * <em>AttributeOption</em> ::=  <font color="red">{AttributeOption}</font><font color="red">:hx</font>   <a href="#N_Variable">&lang;Variable&rang;</a>    <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_AttributeOption(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_AttributeOption> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeOption>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("AttributeOption"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Variable(sink, env)
	 ) 
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortNames$WithEOF</em> ::= <em>SortNames</em> EOF . */
net.sf.crsx.Sink N_SortNames$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortNames(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortNames production. */
TOKEN : {<MT_SortNames : "#SortNames" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortNames production. */
TOKEN : {<IT_SortNames : "%SortNames">}

/**
 * <em>SortNames</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SortName">&lang;SortName&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_SortNames">&lang;SortNames&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_SortNames(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SortNames> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortNames>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_SortName(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_SortNames(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortAbstraction$WithEOF</em> ::= <em>SortAbstraction</em> EOF . */
net.sf.crsx.Sink N_SortAbstraction$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortAbstraction(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortAbstraction production. */
TOKEN : {<MT_SortAbstraction : "#SortAbstraction" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortAbstraction production. */
TOKEN : {<IT_SortAbstraction : "%SortAbstraction">}

/**
 * <em>SortAbstraction</em> ::=  <font color="red">{SortAbstractionParam}</font><font color="red">:hx</font>   <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">^a</font>   <a href="#N_SortAbstraction">&lang;SortAbstraction&rang;</a> <font color="red">[a]</font>  <br>
 *  |  <font color="red">{SortAbstractionBody}</font><font color="red">:hx</font>   <a href="#N_SortAlternatives">&lang;SortAlternatives&rang;</a>  
 */
net.sf.crsx.Sink N_SortAbstraction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	String s_a = null;
	Token t = null;
	net.sf.crsx.Variable v_a = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_a = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs_a = null;
}
{
	t=<MT_SortAbstraction> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortAbstraction>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("SortAbstractionParam"), null)) ;
	}
	 ) 
	 ( 
	{
		bs_a = b_a.sink();
	}
	N_Variable(bs_a, env)
	{
		if (b_a.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_a.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_a.term(false)+")");
		c0 = b_a.term(true).constructor().symbol();
		s_a = c0;
		v_a = sink.makeVariable(s_a,true);
	}
	 ) 
	 ( 
	{
		{
			net.sf.crsx.Variable[] bs1 = {v_a};
			sink = sink .binds(bs1) ;
		}
	}
	sink=N_SortAbstraction(sink, env.extend(s_a, v_a))
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("SortAbstractionBody"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortAlternatives(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortAlternatives$WithEOF</em> ::= <em>SortAlternatives</em> EOF . */
net.sf.crsx.Sink N_SortAlternatives$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortAlternatives(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortAlternatives production. */
TOKEN : {<MT_SortAlternatives : "#SortAlternatives" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortAlternatives production. */
TOKEN : {<IT_SortAlternatives : "%SortAlternatives">}

/**
 * <em>SortAlternatives</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SortAlternative">&lang;SortAlternative&rang;</a>    <a href="#N_SortAlternatives">&lang;SortAlternatives&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_SortAlternatives(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SortAlternatives> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortAlternatives>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_SortAlternative(sink, env)
	 ) 
	 ( 
	sink=N_SortAlternatives(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortAlternative$WithEOF</em> ::= <em>SortAlternative</em> EOF . */
net.sf.crsx.Sink N_SortAlternative$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortAlternative(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortAlternative production. */
TOKEN : {<MT_SortAlternative : "#SortAlternative" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortAlternative production. */
TOKEN : {<IT_SortAlternative : "%SortAlternative">}

/**
 * <em>SortAlternative</em> ::=   <a href="#T_BAR">BAR</a>   (   <a href="#T_SCHEME">SCHEME</a><font color="red">:hx</font>   <a href="#N_Form">&lang;Form&rang;</a>   |  <font color="red">{SynthesizedRef}</font><font color="red">:hx</font>    <a href="#T_UP">UP</a>   <a href="#N_AttributeName">&lang;AttributeName&rang;</a>   |   <a href="#T_SUGAR">SUGAR</a><font color="red">:hx</font>   <a href="#N_Form">&lang;Form&rang;</a>     <a href="#T_ARROW">ARROW</a>   <a href="#N_Term">&lang;Term&rang;</a>   |   <a href="#T_SYMBOL">SYMBOL</a><font color="red">:hx</font>   <a href="#N_Form">&lang;Form&rang;</a>   |   <a href="#T_STATIC">STATIC</a><font color="red">:hx</font>   (   <a href="#T_SYMBOL">SYMBOL</a>  )?   <a href="#N_Form">&lang;Form&rang;</a>   |  <font color="red">{data}</font><font color="red">:hx</font>   (   <a href="#T_DATA">DATA</a>  )?   <a href="#N_Form">&lang;Form&rang;</a>    <a href="#N_Tagging">&lang;Tagging&rang;</a>   ) 
 */
net.sf.crsx.Sink N_SortAlternative(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SortAlternative> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortAlternative>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	 <T_BAR>
	 ) 
	 ( 
		 ( 
		t=<T_SCHEME>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("SynthesizedRef"), null)) ;
		}
		 ) 
		 ( 
		 <T_UP>
		 ) 
		 ( 
		sink=N_AttributeName(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SUGAR>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		 ( 
		 <T_ARROW>
		 ) 
		 ( 
		sink=N_Term(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SYMBOL>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_STATIC>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_SYMBOL>
			 ) 
		 )? 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("data"), null)) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_DATA>
			 ) 
		 )? 
		 ( 
		sink=N_Form(sink, env)
		 ) 
		 ( 
		sink=N_Tagging(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Form$WithEOF</em> ::= <em>Form</em> EOF . */
net.sf.crsx.Sink N_Form$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Form(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Form production. */
TOKEN : {<MT_Form : "#Form" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Form production. */
TOKEN : {<IT_Form : "%Form">}

/**
 * <em>Form</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a> <font color="red">:#C</font>   (  <font color="red">{FormParsedSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>    <a href="#N_FormPrec">&lang;FormPrec&rang;</a>    <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>   |  <font color="red">{FormConstruction}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_BindersScopeSorts">&lang;BindersScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>   )  <br>
 *  |  <font color="red">{FormParsed}</font><font color="red">:hx</font>   <a href="#N_ParsedForm">&lang;ParsedForm&rang;</a>    <a href="#N_FormPrec">&lang;FormPrec&rang;</a>    <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>  
 */
net.sf.crsx.Sink N_Form(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
	Token t = null;
	net.sf.crsx.Sink bs__C = null;
}
{
	t=<MT_Form> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Form>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__C = b__C.sink();
	}
	N_Constructor(bs__C, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("FormParsedSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		sink=N_ParsedForm(sink, env)
		 ) 
		 ( 
		sink=N_FormPrec(sink, env)
		 ) 
		 ( 
		sink=N_InheritedRefs(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("FormConstruction"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_BindersScopeSorts(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_InheritedRefs(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("FormParsed"), null)) ;
	}
	 ) 
	 ( 
	sink=N_ParsedForm(sink, env)
	 ) 
	 ( 
	sink=N_FormPrec(sink, env)
	 ) 
	 ( 
	sink=N_InheritedRefs(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>BindersScopeSorts$WithEOF</em> ::= <em>BindersScopeSorts</em> EOF . */
net.sf.crsx.Sink N_BindersScopeSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_BindersScopeSorts(sink, env) <EOF> {return sink;} }

/** Special meta-variable for BindersScopeSorts production. */
TOKEN : {<MT_BindersScopeSorts : "#BindersScopeSorts" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token BindersScopeSorts production. */
TOKEN : {<IT_BindersScopeSorts : "%BindersScopeSorts">}

/**
 * <em>BindersScopeSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_BindersScopeSort">&lang;BindersScopeSort&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_BindersScopeSorts">&lang;BindersScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_BindersScopeSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_BindersScopeSorts> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_BindersScopeSorts>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_BindersScopeSort(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_BindersScopeSorts(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>BindersScopeSort$WithEOF</em> ::= <em>BindersScopeSort</em> EOF . */
net.sf.crsx.Sink N_BindersScopeSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_BindersScopeSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for BindersScopeSort production. */
TOKEN : {<MT_BindersScopeSort : "#BindersScopeSort" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token BindersScopeSort production. */
TOKEN : {<IT_BindersScopeSort : "%BindersScopeSort">}

/**
 * <em>BindersScopeSort</em> ::=  <font color="red">{ScopeSort}</font><font color="red">:hx</font>   <a href="#N_Sort">&lang;Sort&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   <a href="#N_SubstituteSorts">&lang;SubstituteSorts&rang;</a>     <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )  <br>
 *  |  <font color="red">{BinderScopeSort}</font><font color="red">:hx</font>    <a href="#T_LBRACKET">LBRACKET</a>   <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!!!</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>    <a href="#N_BindersScopeSortTail">&lang;BindersScopeSortTail&rang;</a>  
 */
net.sf.crsx.Sink N_BindersScopeSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Variable v_Variable = null;
	String s_Variable = null;
	net.sf.crsx.Sink bs_Variable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_Variable = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_BindersScopeSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_BindersScopeSort>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ScopeSort"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	sink=N_Repeat(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_LBRACKET>
		 ) 
		 ( 
		sink=N_SubstituteSorts(sink, env)
		 ) 
		 ( 
		 <T_RBRACKET>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("BinderScopeSort"), null)) ;
	}
	 ) 
	 ( 
	 <T_LBRACKET>
	 ) 
	 ( 
	{
		bs_Variable = b_Variable.sink();
	}
	N_Variable(bs_Variable, env)
	{
		if (b_Variable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_Variable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_Variable.term(false)+")");
		c0 = b_Variable.term(true).constructor().symbol();
		s_Variable = c0;
		v_Variable = (env.containsKey(s_Variable) ? env.get(s_Variable) : factory.freeVariable(s_Variable, true, true));
		if (v_Variable == null) throw new ParseException("Variable "+s_Variable+" cannot be resolved?");
		sink = sink .use(v_Variable) ;
	}
	 ) 
	 ( 
	 <T_COLON>
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	sink=N_BindersScopeSortTail(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for BindersScopeSortTail production. */
TOKEN : {<MT_BindersScopeSortTail : "#BindersScopeSortTail" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token BindersScopeSortTail production. */
TOKEN : {<IT_BindersScopeSortTail : "%BindersScopeSortTail">}

/**
 * <em>BindersScopeSortTail</em> ::=   <a href="#T_RBRACKET">RBRACKET</a>   <a href="#N_BindersScopeSort">&lang;BindersScopeSort&rang;</a>   <br>
 *  |  <font color="red">{BinderScopeSort}</font><font color="red">:hx</font>    <a href="#T_COMMA">COMMA</a>   <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!!!</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>    <a href="#N_BindersScopeSortTail">&lang;BindersScopeSortTail&rang;</a>  
 */
net.sf.crsx.Sink N_BindersScopeSortTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Variable v_Variable = null;
	String s_Variable = null;
	net.sf.crsx.Sink bs_Variable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_Variable = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_BindersScopeSortTail> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_BindersScopeSortTail>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	 <T_RBRACKET>
	 ) 
	 ( 
	sink=N_BindersScopeSort(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("BinderScopeSort"), null)) ;
	}
	 ) 
	 ( 
	 <T_COMMA>
	 ) 
	 ( 
	{
		bs_Variable = b_Variable.sink();
	}
	N_Variable(bs_Variable, env)
	{
		if (b_Variable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_Variable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_Variable.term(false)+")");
		c0 = b_Variable.term(true).constructor().symbol();
		s_Variable = c0;
		v_Variable = (env.containsKey(s_Variable) ? env.get(s_Variable) : factory.freeVariable(s_Variable, true, true));
		if (v_Variable == null) throw new ParseException("Variable "+s_Variable+" cannot be resolved?");
		sink = sink .use(v_Variable) ;
	}
	 ) 
	 ( 
	 <T_COLON>
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	sink=N_BindersScopeSortTail(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SubstituteSorts$WithEOF</em> ::= <em>SubstituteSorts</em> EOF . */
net.sf.crsx.Sink N_SubstituteSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SubstituteSorts(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SubstituteSorts production. */
TOKEN : {<MT_SubstituteSorts : "#SubstituteSorts" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SubstituteSorts production. */
TOKEN : {<IT_SubstituteSorts : "%SubstituteSorts">}

/**
 * <em>SubstituteSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SubstituteSort">&lang;SubstituteSort&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_SubstituteSorts">&lang;SubstituteSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_SubstituteSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SubstituteSorts> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SubstituteSorts>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_SubstituteSort(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_SubstituteSorts(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SubstituteSort$WithEOF</em> ::= <em>SubstituteSort</em> EOF . */
net.sf.crsx.Sink N_SubstituteSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SubstituteSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SubstituteSort production. */
TOKEN : {<MT_SubstituteSort : "#SubstituteSort" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SubstituteSort production. */
TOKEN : {<IT_SubstituteSort : "%SubstituteSort">}

/**
 * <em>SubstituteSort</em> ::=  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!!!:#v</font>   (  <font color="red">{SubstituteSort}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>   |  <font color="red">{SubstituteNoSort}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>  ) 
 */
net.sf.crsx.Sink N_SubstituteSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	String s__v = null;
	Token t = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__v = null;
	net.sf.crsx.Variable v__v = null;
}
{
	t=<MT_SubstituteSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SubstituteSort>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__v = b__v.sink();
	}
	N_Variable(bs__v, env)
	{
		if (b__v.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b__v.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b__v.term(false)+")");
		c0 = b__v.term(true).constructor().symbol();
		s__v = c0;
		v__v = (env.containsKey(s__v) ? env.get(s__v) : factory.freeVariable(s__v, true, true));
		if (v__v == null) throw new ParseException("Variable "+s__v+" cannot be resolved?");
	}
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("SubstituteSort"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .use(v__v) ;
		}
		 ) 
		 ( 
		 <T_COLON>
		 ) 
		 ( 
		sink=N_Sort(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("SubstituteNoSort"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .use(v__v) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Sort$WithEOF</em> ::= <em>Sort</em> EOF . */
net.sf.crsx.Sink N_Sort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Sort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Sort production. */
TOKEN : {<MT_Sort : "#Sort" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Sort production. */
TOKEN : {<IT_Sort : "%Sort">}

/**
 * <em>Sort</em> ::=  <font color="red">{Sort}</font><font color="red">:hx</font>   <a href="#N_SimpleSort">&lang;SimpleSort&rang;</a>    <a href="#N_SimpleSorts">&lang;SimpleSorts&rang;</a>  
 */
net.sf.crsx.Sink N_Sort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Sort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Sort>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Sort"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SimpleSort(sink, env)
	 ) 
	 ( 
	sink=N_SimpleSorts(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SimpleSorts$WithEOF</em> ::= <em>SimpleSorts</em> EOF . */
net.sf.crsx.Sink N_SimpleSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SimpleSorts(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SimpleSorts production. */
TOKEN : {<MT_SimpleSorts : "#SimpleSorts" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SimpleSorts production. */
TOKEN : {<IT_SimpleSorts : "%SimpleSorts">}

/**
 * <em>SimpleSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_SimpleSort">&lang;SimpleSort&rang;</a>    <a href="#N_SimpleSorts">&lang;SimpleSorts&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_SimpleSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SimpleSorts> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SimpleSorts>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_SimpleSort(sink, env)
	 ) 
	 ( 
	sink=N_SimpleSorts(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SimpleSort$WithEOF</em> ::= <em>SimpleSort</em> EOF . */
net.sf.crsx.Sink N_SimpleSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SimpleSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SimpleSort production. */
TOKEN : {<MT_SimpleSort : "#SimpleSort" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SimpleSort production. */
TOKEN : {<IT_SimpleSort : "%SimpleSort">}

/**
 * <em>SimpleSort</em> ::=  <font color="red">{SortName}</font><font color="red">:hx</font>   <a href="#N_SortName">&lang;SortName&rang;</a>    <a href="#N_MetaVariables">&lang;MetaVariables&rang;</a>   <br>
 *  |  <font color="red">{SortParam}</font><font color="red">:hx</font>   <a href="#N_SortParam">&lang;SortParam&rang;</a>   <br>
 *  |   <a href="#T_LPAREN">LPAREN</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RPAREN">RPAREN</a> 
 */
net.sf.crsx.Sink N_SimpleSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SimpleSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SimpleSort>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("SortName"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortName(sink, env)
	 ) 
	 ( 
	sink=N_MetaVariables(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("SortParam"), null)) ;
	}
	 ) 
	 ( 
	sink=N_SortParam(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_LPAREN>
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	 <T_RPAREN>
	 ) 
	{return sink;}
}

/** <em>MetaVariables$WithEOF</em> ::= <em>MetaVariables</em> EOF . */
net.sf.crsx.Sink N_MetaVariables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_MetaVariables(sink, env) <EOF> {return sink;} }

/** Special meta-variable for MetaVariables production. */
TOKEN : {<MT_MetaVariables : "#MetaVariables" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token MetaVariables production. */
TOKEN : {<IT_MetaVariables : "%MetaVariables">}

/**
 * <em>MetaVariables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_MetaVariable">&lang;MetaVariable&rang;</a>    <font color="red">{$Nil}</font>  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_MetaVariables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_MetaVariables> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_MetaVariables>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_MetaVariable(sink, env)
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end().end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>SortParam$WithEOF</em> ::= <em>SortParam</em> EOF . */
net.sf.crsx.Sink N_SortParam$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_SortParam(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortParam production. */
TOKEN : {<MT_SortParam : "#SortParam" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortParam production. */
TOKEN : {<IT_SortParam : "%SortParam">}

/**
 * <em>SortParam</em> ::=  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!</font> 
 */
net.sf.crsx.Sink N_SortParam(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Variable v_Variable = null;
	String s_Variable = null;
	net.sf.crsx.Sink bs_Variable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_Variable = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_SortParam> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortParam>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs_Variable = b_Variable.sink();
	}
	N_Variable(bs_Variable, env)
	{
		if (b_Variable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_Variable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_Variable.term(false)+")");
		c0 = b_Variable.term(true).constructor().symbol();
		s_Variable = c0;
		v_Variable = env.get(s_Variable);
		if (v_Variable == null) throw new ParseException("Variable "+s_Variable+" cannot be resolved?");
		sink = sink .use(v_Variable) ;
	}
	 ) 
	{return sink;}
}

/** <em>ScopeSortPrecRepeat$WithEOF</em> ::= <em>ScopeSortPrecRepeat</em> EOF . */
net.sf.crsx.Sink N_ScopeSortPrecRepeat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_ScopeSortPrecRepeat(sink, env) <EOF> {return sink;} }

/** Special meta-variable for ScopeSortPrecRepeat production. */
TOKEN : {<MT_ScopeSortPrecRepeat : "#ScopeSortPrecRepeat" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ScopeSortPrecRepeat production. */
TOKEN : {<IT_ScopeSortPrecRepeat : "%ScopeSortPrecRepeat">}

/**
 * <em>ScopeSortPrecRepeat</em> ::=  <font color="red">{ScopeSortPrecRepeat}</font><font color="red">:hx</font>   <a href="#N_ScopeSort">&lang;ScopeSort&rang;</a>    <a href="#N_FormPrec">&lang;FormPrec&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>  
 */
net.sf.crsx.Sink N_ScopeSortPrecRepeat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_ScopeSortPrecRepeat> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ScopeSortPrecRepeat>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ScopeSortPrecRepeat"), null)) ;
	}
	 ) 
	 ( 
	sink=N_ScopeSort(sink, env)
	 ) 
	 ( 
	sink=N_FormPrec(sink, env)
	 ) 
	 ( 
	sink=N_Repeat(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>ScopeSort$WithEOF</em> ::= <em>ScopeSort</em> EOF . */
net.sf.crsx.Sink N_ScopeSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_ScopeSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for ScopeSort production. */
TOKEN : {<MT_ScopeSort : "#ScopeSort" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ScopeSort production. */
TOKEN : {<IT_ScopeSort : "%ScopeSort">}

/**
 * <em>ScopeSort</em> ::=  <font color="red">{ScopeSort}</font><font color="red">:hx</font>   <a href="#N_Sort">&lang;Sort&rang;</a>    <a href="#N_Repeat">&lang;Repeat&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   <a href="#N_SubstituteSorts">&lang;SubstituteSorts&rang;</a>     <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )  <br>
 *  |  <font color="red">{ScopeSortBinder}</font><font color="red">:hx</font>    <a href="#T_LBRACKET">LBRACKET</a>   <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!!!</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Sort">&lang;Sort&rang;</a>     <a href="#T_RBRACKET">RBRACKET</a> 
 */
net.sf.crsx.Sink N_ScopeSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Variable v_Variable = null;
	String s_Variable = null;
	net.sf.crsx.Sink bs_Variable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_Variable = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_ScopeSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ScopeSort>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ScopeSort"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	sink=N_Repeat(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_LBRACKET>
		 ) 
		 ( 
		sink=N_SubstituteSorts(sink, env)
		 ) 
		 ( 
		 <T_RBRACKET>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ScopeSortBinder"), null)) ;
	}
	 ) 
	 ( 
	 <T_LBRACKET>
	 ) 
	 ( 
	{
		bs_Variable = b_Variable.sink();
	}
	N_Variable(bs_Variable, env)
	{
		if (b_Variable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_Variable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_Variable.term(false)+")");
		c0 = b_Variable.term(true).constructor().symbol();
		s_Variable = c0;
		v_Variable = (env.containsKey(s_Variable) ? env.get(s_Variable) : factory.freeVariable(s_Variable, true, true));
		if (v_Variable == null) throw new ParseException("Variable "+s_Variable+" cannot be resolved?");
		sink = sink .use(v_Variable) ;
	}
	 ) 
	 ( 
	 <T_COLON>
	 ) 
	 ( 
	sink=N_Sort(sink, env)
	 ) 
	 ( 
	 <T_RBRACKET>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>FormPrec$WithEOF</em> ::= <em>FormPrec</em> EOF . */
net.sf.crsx.Sink N_FormPrec$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_FormPrec(sink, env) <EOF> {return sink;} }

/** Special meta-variable for FormPrec production. */
TOKEN : {<MT_FormPrec : "#FormPrec" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token FormPrec production. */
TOKEN : {<IT_FormPrec : "%FormPrec">}

/**
 * <em>FormPrec</em> ::=  (   <a href="#T_AT">AT</a>   <a href="#N_Natural">&lang;Natural&rang;</a>   |  <font color="red">{"0"}</font>  ) 
 */
net.sf.crsx.Sink N_FormPrec(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_FormPrec> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_FormPrec>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		 <T_AT>
		 ) 
		 ( 
		sink=N_Natural(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "0", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Tagging$WithEOF</em> ::= <em>Tagging</em> EOF . */
net.sf.crsx.Sink N_Tagging$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Tagging(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Tagging production. */
TOKEN : {<MT_Tagging : "#Tagging" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Tagging production. */
TOKEN : {<IT_Tagging : "%Tagging">}

/**
 * <em>Tagging</em> ::=  (  <font color="red">{$Cons}</font>    <a href="#T_TAG">TAG</a>   <a href="#N_Constructor">&lang;Constructor&rang;</a>    (  <font color="red">{$Nil}</font>  )  |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Tagging(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Tagging> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Tagging>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		 <T_TAG>
		 ) 
		 ( 
		sink=N_Constructor(sink, env)
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>InheritedRefs$WithEOF</em> ::= <em>InheritedRefs</em> EOF . */
net.sf.crsx.Sink N_InheritedRefs$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_InheritedRefs(sink, env) <EOF> {return sink;} }

/** Special meta-variable for InheritedRefs production. */
TOKEN : {<MT_InheritedRefs : "#InheritedRefs" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token InheritedRefs production. */
TOKEN : {<IT_InheritedRefs : "%InheritedRefs">}

/**
 * <em>InheritedRefs</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_InheritedRef">&lang;InheritedRef&rang;</a>    <a href="#N_InheritedRefs">&lang;InheritedRefs&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_InheritedRefs(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_InheritedRefs> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_InheritedRefs>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		sink=N_InheritedRef(sink, env)
		 ) 
		 ( 
		sink=N_InheritedRefs(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>InheritedRef$WithEOF</em> ::= <em>InheritedRef</em> EOF . */
net.sf.crsx.Sink N_InheritedRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_InheritedRef(sink, env) <EOF> {return sink;} }

/** Special meta-variable for InheritedRef production. */
TOKEN : {<MT_InheritedRef : "#InheritedRef" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token InheritedRef production. */
TOKEN : {<IT_InheritedRef : "%InheritedRef">}

/**
 * <em>InheritedRef</em> ::=  <font color="red">{InheritedRef}</font><font color="red">:hx</font>    <a href="#T_DOWN">DOWN</a>   <a href="#N_AttributeName">&lang;AttributeName&rang;</a>  
 */
net.sf.crsx.Sink N_InheritedRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_InheritedRef> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_InheritedRef>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("InheritedRef"), null)) ;
	}
	 ) 
	 ( 
	 <T_DOWN>
	 ) 
	 ( 
	sink=N_AttributeName(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Rule$WithEOF</em> ::= <em>Rule</em> EOF . */
net.sf.crsx.Sink N_Rule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Rule(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Rule production. */
TOKEN : {<MT_Rule : "#Rule" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Rule production. */
TOKEN : {<IT_Rule : "%Rule">}

/**
 * <em>Rule</em> ::=  <font color="red">{Rule}</font><font color="red">:hx</font>   <a href="#N_Priority">&lang;Priority&rang;</a>    <a href="#N_Construction">&lang;Construction&rang;</a> <font color="red">:#first</font>   (   <a href="#T_COLON">COLON</a><font color="red">:hx</font>   <font color="red">{{#first}}</font>   <a href="#N_Construction">&lang;Construction&rang;</a>   |  <font color="red">{OMITTED}</font><font color="red">:hx</font>   <font color="red">{{#first}}</font>  )   (   <a href="#T_ARROW">ARROW</a><font color="red">:hx</font>   <a href="#N_Term">&lang;Term&rang;</a>   |  <font color="red">{OMITTED}</font><font color="red">:hx</font>  ) 
 */
net.sf.crsx.Sink N_Rule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__first = new net.sf.crsx.util.Buffer(sink);
	Token t = null;
	net.sf.crsx.Sink bs__first = null;
}
{
	t=<MT_Rule> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Rule>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Rule"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Priority(sink, env)
	 ) 
	 ( 
	{
		bs__first = b__first.sink();
	}
	N_Construction(bs__first, env)
	 ) 
	 ( 
		 ( 
		t=<T_COLON>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__first, true) ;
		}
		 ) 
		 ( 
		sink=N_Construction(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("OMITTED"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__first, true) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
		 ( 
		t=<T_ARROW>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_Term(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("OMITTED"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Priority$WithEOF</em> ::= <em>Priority</em> EOF . */
net.sf.crsx.Sink N_Priority$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Priority(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Priority production. */
TOKEN : {<MT_Priority : "#Priority" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Priority production. */
TOKEN : {<IT_Priority : "%Priority">}

/**
 * <em>Priority</em> ::=  (   <a href="#T_DEFAULT">DEFAULT</a><font color="red">:hx</font>  |   <a href="#T_PRIORITY">PRIORITY</a><font color="red">:hx</font>  |  <font color="red">{Normal}</font><font color="red">:hx</font>  ) 
 */
net.sf.crsx.Sink N_Priority(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Priority> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Priority>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_DEFAULT>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_PRIORITY>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Normal"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Term$WithEOF</em> ::= <em>Term</em> EOF . */
net.sf.crsx.Sink N_Term$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Term(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Term production. */
TOKEN : {<MT_Term : "#Term" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Term production. */
TOKEN : {<IT_Term : "%Term">}

/**
 * <em>Term</em> ::=  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!!!:#v</font>   (  <font color="red">{Special}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>    <a href="#T_CONCRETE">CONCRETE</a><font color="red">$$:unwrap:{n}</font>  |  <font color="red">{VariableUse}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   )  <br>
 *  |  <a href="#N_NotVariableTerm">&lang;NotVariableTerm&rang;</a>  
 */
net.sf.crsx.Sink N_Term(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	String s__v = null;
	Token t = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__v = null;
	net.sf.crsx.Variable v__v = null;
}
{
	t=<MT_Term> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Term>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__v = b__v.sink();
	}
	N_Variable(bs__v, env)
	{
		if (b__v.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b__v.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b__v.term(false)+")");
		c0 = b__v.term(true).constructor().symbol();
		s__v = c0;
		v__v = (env.containsKey(s__v) ? env.get(s__v) : factory.freeVariable(s__v, true, true));
		if (v__v == null) throw new ParseException("Variable "+s__v+" cannot be resolved?");
	}
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Special"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .use(v__v) ;
		}
		 ) 
		 ( 
		t=<T_CONCRETE>
		{
			try {sink = factory.parser(factory).parse(sink, "n", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
			catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
			catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("VariableUse"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .use(v__v) ;
		}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_NotVariableTerm(sink, env)
	 ) 
	{return sink;}
}

/** <em>NotVariableTerm$WithEOF</em> ::= <em>NotVariableTerm</em> EOF . */
net.sf.crsx.Sink N_NotVariableTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_NotVariableTerm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for NotVariableTerm production. */
TOKEN : {<MT_NotVariableTerm : "#NotVariableTerm" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token NotVariableTerm production. */
TOKEN : {<IT_NotVariableTerm : "%NotVariableTerm">}

/**
 * <em>NotVariableTerm</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a> <font color="red">:#C</font>   <a href="#N_Repeat">&lang;Repeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{UnparsedSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   (   <a href="#T_CONCRETE">CONCRETE</a><font color="red">$:unwrap</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{MetaApplicationSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_MetaVariable">&lang;MetaVariable&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Terms">&lang;Terms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Constructor">&lang;Constructor&rang;</a>    (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{VariableUseSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!!!</font>   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{LiteralSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Literal">&lang;Literal&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:hx</font>   <a href="#N_Literal">&lang;Literal&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   <br>
 *  |  <font color="red">{Unparsed}</font><font color="red">:hx</font>   (   <a href="#T_CONCRETE">CONCRETE</a><font color="red">$:unwrap</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   <br>
 *  |  <font color="red">{MetaApplication}</font><font color="red">:hx</font>   <a href="#N_MetaVariable">&lang;MetaVariable&rang;</a>    (   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Terms">&lang;Terms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>  
 */
net.sf.crsx.Sink N_NotVariableTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
	Token t = null;
	net.sf.crsx.Variable v_Variable = null;
	String s_Variable = null;
	net.sf.crsx.Sink bs_Variable = null;
	net.sf.crsx.Sink bs__C = null;
	String c5 = null;
	net.sf.crsx.Sink bs__R = null;
	net.sf.crsx.util.Buffer b_Variable = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_NotVariableTerm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_NotVariableTerm>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__C = b__C.sink();
	}
	N_Constructor(bs__C, env)
	 ) 
	 ( 
	{
		bs__R = b__R.sink();
	}
	N_Repeat(bs__R, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("UnparsedSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
			 ( 
			t=<T_CONCRETE>
			{
				sink = sink .start(makeTConstructor(sink, t, unwrap(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("MetaApplicationSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_MetaVariable(sink, env)
		 ) 
		 ( 
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Terms(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("ConstructionSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_Constructor(sink, env)
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("VariableUseSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		{
			bs_Variable = b_Variable.sink();
		}
		N_Variable(bs_Variable, env)
		{
			if (b_Variable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_Variable.term(false).arity() != 0)
			 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_Variable.term(false)+")");
			c5 = b_Variable.term(true).constructor().symbol();
			s_Variable = c5;
			v_Variable = (env.containsKey(s_Variable) ? env.get(s_Variable) : factory.freeVariable(s_Variable, true, true));
			if (v_Variable == null) throw new ParseException("Variable "+s_Variable+" cannot be resolved?");
			sink = sink .use(v_Variable) ;
		}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("LiteralSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_Literal(sink, env)
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Construction"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Literal"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Literal(sink, env)
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Unparsed"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		t=<T_CONCRETE>
		{
			sink = sink .start(makeTConstructor(sink, t, unwrap(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("MetaApplication"), null)) ;
	}
	 ) 
	 ( 
	sink=N_MetaVariable(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_LBRACKET>
		 ) 
		 ( 
			 ( 
			sink=N_Terms(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_RBRACKET>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for Construction production. */
TOKEN : {<MT_Construction : "#Construction" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Construction production. */
TOKEN : {<IT_Construction : "%Construction">}

/**
 * <em>Construction</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a> <font color="red">:#C</font>   <a href="#N_Repeat">&lang;Repeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{UnparsedSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   (   <a href="#T_CONCRETE">CONCRETE</a><font color="red">$:unwrap</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Constructor">&lang;Constructor&rang;</a>    (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{LiteralSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_Literal">&lang;Literal&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   (   <a href="#T_LPAREN">LPAREN</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RPAREN">RPAREN</a>  |   <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:hx</font>   <a href="#N_Literal">&lang;Literal&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   <br>
 *  |  <font color="red">{Unparsed}</font><font color="red">:hx</font>   (   <a href="#T_CONCRETE">CONCRETE</a><font color="red">$:unwrap</font>  )   <a href="#N_Attributes">&lang;Attributes&rang;</a>  
 */
net.sf.crsx.Sink N_Construction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
	Token t = null;
	net.sf.crsx.Sink bs__C = null;
	net.sf.crsx.Sink bs__R = null;
}
{
	t=<MT_Construction> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Construction>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__C = b__C.sink();
	}
	N_Constructor(bs__C, env)
	 ) 
	 ( 
	{
		bs__R = b__R.sink();
	}
	N_Repeat(bs__R, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("UnparsedSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
			 ( 
			t=<T_CONCRETE>
			{
				sink = sink .start(makeTConstructor(sink, t, unwrap(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("ConstructionSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_Constructor(sink, env)
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("LiteralSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_Literal(sink, env)
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Construction"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RPAREN>
			 ) 
		|
			 ( 
			 <T_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_Scopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Literal"), null)) ;
	}
	 ) 
	 ( 
	sink=N_Literal(sink, env)
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Unparsed"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		t=<T_CONCRETE>
		{
			sink = sink .start(makeTConstructor(sink, t, unwrap(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_Attributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Scopes$WithEOF</em> ::= <em>Scopes</em> EOF . */
net.sf.crsx.Sink N_Scopes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Scopes(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Scopes production. */
TOKEN : {<MT_Scopes : "#Scopes" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Scopes production. */
TOKEN : {<IT_Scopes : "%Scopes">}

/**
 * <em>Scopes</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Scope">&lang;Scope&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_Scopes">&lang;Scopes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Scopes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Scopes> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Scopes>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_Scope(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_Scopes(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Scope$WithEOF</em> ::= <em>Scope</em> EOF . */
net.sf.crsx.Sink N_Scope$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Scope(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Scope production. */
TOKEN : {<MT_Scope : "#Scope" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Scope production. */
TOKEN : {<IT_Scope : "%Scope">}

/**
 * <em>Scope</em> ::=  <font color="red">{Scope}</font><font color="red">:hx</font>   (  <font color="red">{$Nil}</font>  )   <a href="#N_NotVariableTerm">&lang;NotVariableTerm&rang;</a>   <br>
 *  |  <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!!!:#v</font>   (  <font color="red">{Scope}</font><font color="red">:hx</font>   (  <font color="red">{$Cons}</font>   <font color="red">{{#v}}</font>   <a href="#N_Variables">&lang;Variables&rang;</a>   )    <a href="#T_DOT">DOT</a>   <a href="#N_Term">&lang;Term&rang;</a>   |  <font color="red">{Scope}</font><font color="red">:hx</font>   (  <font color="red">{$Nil}</font>  )   (  <font color="red">{VariableUse}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>  )  )  <br>
 *  |  <font color="red">{Scope}</font><font color="red">:hx</font>    <a href="#T_LBRACKET">LBRACKET</a>   (  <a href="#N_VariableList">&lang;VariableList&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_RBRACKET">RBRACKET</a>   <a href="#N_Term">&lang;Term&rang;</a>  
 */
net.sf.crsx.Sink N_Scope(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	String s__v = null;
	Token t = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__v = null;
	net.sf.crsx.Variable v__v = null;
}
{
	t=<MT_Scope> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Scope>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Scope"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_NotVariableTerm(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		bs__v = b__v.sink();
	}
	N_Variable(bs__v, env)
	{
		if (b__v.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b__v.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b__v.term(false)+")");
		c0 = b__v.term(true).constructor().symbol();
		s__v = c0;
		v__v = (env.containsKey(s__v) ? env.get(s__v) : factory.freeVariable(s__v, true, true));
		if (v__v == null) throw new ParseException("Variable "+s__v+" cannot be resolved?");
	}
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Scope"), null)) ;
		}
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
			}
			 ) 
			 ( 
			{
				sink = sink .use(v__v) ;
			}
			 ) 
			 ( 
			sink=N_Variables(sink, env)
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_DOT>
		 ) 
		 ( 
		sink=N_Term(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Scope"), null)) ;
		}
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, hx("VariableUse"), null)) ;
			}
			 ) 
			 ( 
			{
				sink = sink .use(v__v) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Scope"), null)) ;
	}
	 ) 
	 ( 
	 <T_LBRACKET>
	 ) 
	 ( 
		 ( 
		sink=N_VariableList(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	 <T_RBRACKET>
	 ) 
	 ( 
	sink=N_Term(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Variables$WithEOF</em> ::= <em>Variables</em> EOF . */
net.sf.crsx.Sink N_Variables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Variables(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Variables production. */
TOKEN : {<MT_Variables : "#Variables" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Variables production. */
TOKEN : {<IT_Variables : "%Variables">}

/**
 * <em>Variables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!!!</font>   <a href="#N_Variables">&lang;Variables&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_Variables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Variable v_Variable = null;
	String s_Variable = null;
	net.sf.crsx.Sink bs_Variable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_Variable = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_Variables> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Variables>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	{
		bs_Variable = b_Variable.sink();
	}
	N_Variable(bs_Variable, env)
	{
		if (b_Variable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_Variable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_Variable.term(false)+")");
		c0 = b_Variable.term(true).constructor().symbol();
		s_Variable = c0;
		v_Variable = (env.containsKey(s_Variable) ? env.get(s_Variable) : factory.freeVariable(s_Variable, true, true));
		if (v_Variable == null) throw new ParseException("Variable "+s_Variable+" cannot be resolved?");
		sink = sink .use(v_Variable) ;
	}
	 ) 
	 ( 
	sink=N_Variables(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for VariableList production. */
TOKEN : {<MT_VariableList : "#VariableList" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token VariableList production. */
TOKEN : {<IT_VariableList : "%VariableList">}

/**
 * <em>VariableList</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Variable">&lang;Variable&rang;</a> <font color="red">!!!</font>   (   <a href="#T_COMMA">COMMA</a>   <a href="#N_VariableList">&lang;VariableList&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_VariableList(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Variable v_Variable = null;
	String s_Variable = null;
	net.sf.crsx.Sink bs_Variable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_Variable = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_VariableList> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_VariableList>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	{
		bs_Variable = b_Variable.sink();
	}
	N_Variable(bs_Variable, env)
	{
		if (b_Variable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_Variable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_Variable.term(false)+")");
		c0 = b_Variable.term(true).constructor().symbol();
		s_Variable = c0;
		v_Variable = (env.containsKey(s_Variable) ? env.get(s_Variable) : factory.freeVariable(s_Variable, true, true));
		if (v_Variable == null) throw new ParseException("Variable "+s_Variable+" cannot be resolved?");
		sink = sink .use(v_Variable) ;
	}
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_VariableList(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Terms$WithEOF</em> ::= <em>Terms</em> EOF . */
net.sf.crsx.Sink N_Terms$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Terms(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Terms production. */
TOKEN : {<MT_Terms : "#Terms" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Terms production. */
TOKEN : {<IT_Terms : "%Terms">}

/**
 * <em>Terms</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_Term">&lang;Term&rang;</a>    (   <a href="#T_COMMA">COMMA</a>   <a href="#N_Terms">&lang;Terms&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Terms(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Terms> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Terms>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_Term(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_COMMA>
		 ) 
		 ( 
		sink=N_Terms(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Attributes$WithEOF</em> ::= <em>Attributes</em> EOF . */
net.sf.crsx.Sink N_Attributes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Attributes(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Attributes production. */
TOKEN : {<MT_Attributes : "#Attributes" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Attributes production. */
TOKEN : {<IT_Attributes : "%Attributes">}

/**
 * <em>Attributes</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_Attribute">&lang;Attribute&rang;</a>    <a href="#N_Attributes">&lang;Attributes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_Attributes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Attributes> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Attributes>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		sink=N_Attribute(sink, env)
		 ) 
		 ( 
		sink=N_Attributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Attribute$WithEOF</em> ::= <em>Attribute</em> EOF . */
net.sf.crsx.Sink N_Attribute$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Attribute(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Attribute production. */
TOKEN : {<MT_Attribute : "#Attribute" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Attribute production. */
TOKEN : {<IT_Attribute : "%Attribute">}

/**
 * <em>Attribute</em> ::=  <font color="red">{Attribute}</font><font color="red">:hx</font>   <a href="#N_AttributeKind">&lang;AttributeKind&rang;</a>    <a href="#N_AttributeName">&lang;AttributeName&rang;</a>    <a href="#N_AttributeValue">&lang;AttributeValue&rang;</a>  
 */
net.sf.crsx.Sink N_Attribute(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Attribute> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Attribute>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Attribute"), null)) ;
	}
	 ) 
	 ( 
	sink=N_AttributeKind(sink, env)
	 ) 
	 ( 
	sink=N_AttributeName(sink, env)
	 ) 
	 ( 
	sink=N_AttributeValue(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>AttributeKind$WithEOF</em> ::= <em>AttributeKind</em> EOF . */
net.sf.crsx.Sink N_AttributeKind$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeKind(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeKind production. */
TOKEN : {<MT_AttributeKind : "#AttributeKind" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeKind production. */
TOKEN : {<IT_AttributeKind : "%AttributeKind">}

/**
 * <em>AttributeKind</em> ::=  (  <font color="red">{AttributeKindUp}</font><font color="red">:hx</font>    <a href="#T_UP">UP</a>  |  <font color="red">{AttributeKindDown}</font><font color="red">:hx</font>    <a href="#T_DOWN">DOWN</a>  ) 
 */
net.sf.crsx.Sink N_AttributeKind(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_AttributeKind> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeKind>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeKindUp"), null)) ;
		}
		 ) 
		 ( 
		 <T_UP>
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeKindDown"), null)) ;
		}
		 ) 
		 ( 
		 <T_DOWN>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>AttributeValue$WithEOF</em> ::= <em>AttributeValue</em> EOF . */
net.sf.crsx.Sink N_AttributeValue$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeValue(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeValue production. */
TOKEN : {<MT_AttributeValue : "#AttributeValue" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeValue production. */
TOKEN : {<IT_AttributeValue : "%AttributeValue">}

/**
 * <em>AttributeValue</em> ::=  <font color="red">{AttributeValue}</font><font color="red">:hx</font>    <a href="#T_LPAREN">LPAREN</a>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_RPAREN">RPAREN</a>  <br>
 *  |   <a href="#T_LBRACE">LBRACE</a>   (  <a href="#N_Term">&lang;Term&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeKeyValue}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_COLON">COLON</a>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  |  <font color="red">{AttributeKey}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_RBRACE">RBRACE</a>  )  |  <font color="red">{AttributeNotKey}</font><font color="red">:hx</font>    <a href="#T_NOT">NOT</a>   <a href="#N_Term">&lang;Term&rang;</a>     <a href="#T_RBRACE">RBRACE</a>  ) 
 */
net.sf.crsx.Sink N_AttributeValue(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink bs__ = null;
	net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_AttributeValue> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeValue>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("AttributeValue"), null)) ;
	}
	 ) 
	 ( 
	 <T_LPAREN>
	 ) 
	 ( 
	sink=N_Term(sink, env)
	 ) 
	 ( 
	 <T_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_LBRACE>
	 ) 
	 ( 
		 ( 
		{
			bs__ = b__.sink();
		}
		N_Term(bs__, env)
		 ) 
		 ( 
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, hx("AttributeKeyValue"), null)) ;
			}
			 ) 
			 ( 
			{
				sink = sink .copy(b__, true) ;
			}
			 ) 
			 ( 
			 <T_COLON>
			 ) 
			 ( 
			sink=N_Term(sink, env)
			 ) 
			 ( 
			 <T_RBRACE>
			 ) 
			{
				sink = sink .end() ;
			}
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, hx("AttributeKey"), null)) ;
			}
			 ) 
			 ( 
			{
				sink = sink .copy(b__, true) ;
			}
			 ) 
			 ( 
			 <T_RBRACE>
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeNotKey"), null)) ;
		}
		 ) 
		 ( 
		 <T_NOT>
		 ) 
		 ( 
		sink=N_Term(sink, env)
		 ) 
		 ( 
		 <T_RBRACE>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

// Nesting.
TOKEN_MGR_DECLS : { int nesting ; int nestedState; }


// Nested concrete token .... 
<DEFAULT,RE> MORE : { "\u27e6" { nesting = 0; nestedState = curLexState; } : IN_CONCRETE }
<IN_CONCRETE> MORE : { "\u27e6" { nesting = 1; } : IN_NESTED_CONCRETE }
<IN_NESTED_CONCRETE> MORE : { "\u27e6" { nesting++; } }
<IN_NESTED_CONCRETE> MORE : { "\u27e7" { if (--nesting <= 0) SwitchTo(IN_CONCRETE); } }
<IN_CONCRETE> TOKEN : { <T_CONCRETE : "\u27e7"> { SwitchTo(nestedState); } }
<IN_CONCRETE,IN_NESTED_CONCRETE> MORE : { < ~[] > }


// Nested comments JavaCC hack...
<DEFAULT,RE> SKIP : { "/*" { nesting = 1; nestedState = curLexState; } : NESTED_COMMENT }
<NESTED_COMMENT> SKIP : { "/*" { nesting += 1; } }
<NESTED_COMMENT> SKIP : { "*/" { nesting -= 1; if (nesting<=0) SwitchTo(nestedState); } }
<NESTED_COMMENT> SKIP : { < ~[] > }


/** <em>ModuleName$WithEOF</em> ::= <em>ModuleName</em> EOF . */
net.sf.crsx.Sink N_ModuleName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_ModuleName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for ModuleName production. */
TOKEN : {<MT_ModuleName : "#ModuleName" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ModuleName production. */
TOKEN : {<IT_ModuleName : "%ModuleName">}

/**
 * <em>ModuleName</em> ::=  <a href="#N_String">&lang;String&rang;</a> <font color="red">:checkModuleString</font>  <br>
 *  |  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_ModuleName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.util.Buffer b_String = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs_String = null;
	String c0 = null;
}
{
	t=<MT_ModuleName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ModuleName>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs_String = b_String.sink();
	}
	N_String(bs_String, env)
	{
		if (b_String.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_String.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_String.term(false)+")");
		c0 = b_String.term(true).constructor().symbol();
		sink = sink .start(makeTConstructor(sink, t, checkModuleString(c0), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{return sink;}
}

/** <em>SortName$WithEOF</em> ::= <em>SortName</em> EOF . */
net.sf.crsx.Sink N_SortName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_SortName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for SortName production. */
<DEFAULT, RE> TOKEN : {<MT_SortName : "#SortName" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token SortName production. */
<DEFAULT, RE> TOKEN : {<IT_SortName : "%SortName">}

/**
 * <em>SortName</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_SortName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_SortName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_SortName>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{return sink;}
}

/** <em>FragmentName$WithEOF</em> ::= <em>FragmentName</em> EOF . */
net.sf.crsx.Sink N_FragmentName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_FragmentName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for FragmentName production. */
<RE> TOKEN : {<MT_FragmentName : "#FragmentName" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token FragmentName production. */
<RE> TOKEN : {<IT_FragmentName : "%FragmentName">}

/**
 * <em>FragmentName</em> ::=  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_FragmentName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_FragmentName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_FragmentName>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{return sink;}
}

/** <em>FragmentRef$WithEOF</em> ::= <em>FragmentRef</em> EOF . */
net.sf.crsx.Sink N_FragmentRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_FragmentRef(sink, env) <EOF> {return sink;} }

/** Special meta-variable for FragmentRef production. */
<DEFAULT, RE> TOKEN : {<MT_FragmentRef : "#FragmentRef" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token FragmentRef production. */
<DEFAULT, RE> TOKEN : {<IT_FragmentRef : "%FragmentRef">}

/**
 * <em>FragmentRef</em> ::=   <a href="#T_FRAGMENT_REF">FRAGMENT_REF</a><font color="red">$:unwrap</font> 
 */
net.sf.crsx.Sink N_FragmentRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_FragmentRef> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_FragmentRef>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_FRAGMENT_REF>
	{
		sink = sink .start(makeTConstructor(sink, t, unwrap(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>AttributeName$WithEOF</em> ::= <em>AttributeName</em> EOF . */
net.sf.crsx.Sink N_AttributeName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_AttributeName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for AttributeName production. */
TOKEN : {<MT_AttributeName : "#AttributeName" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token AttributeName production. */
TOKEN : {<IT_AttributeName : "%AttributeName">}

/**
 * <em>AttributeName</em> ::=  <a href="#N_Literal">&lang;Literal&rang;</a>   <br>
 *  |  <a href="#N_Variable">&lang;Variable&rang;</a>   <br>
 *  |  <a href="#N_Constructor">&lang;Constructor&rang;</a>  
 */
net.sf.crsx.Sink N_AttributeName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_AttributeName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_AttributeName>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_Literal(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_Variable(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_Constructor(sink, env)
	 ) 
	{return sink;}
}

/** <em>Constructor$WithEOF</em> ::= <em>Constructor</em> EOF . */
net.sf.crsx.Sink N_Constructor$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Constructor(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Constructor production. */
TOKEN : {<MT_Constructor : "#Constructor" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Constructor production. */
TOKEN : {<IT_Constructor : "%Constructor">}

/**
 * <em>Constructor</em> ::=  (   <a href="#T_UPPER">UPPER</a><font color="red">$</font>  |   <a href="#T_DASH">DASH</a><font color="red">$</font>  |   <a href="#T_CON">CON</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_Constructor(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Constructor> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Constructor>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_UPPER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CON>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Variable$WithEOF</em> ::= <em>Variable</em> EOF . */
net.sf.crsx.Sink N_Variable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Variable(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Variable production. */
TOKEN : {<MT_Variable : "#Variable" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Variable production. */
TOKEN : {<IT_Variable : "%Variable">}

/**
 * <em>Variable</em> ::=  (   <a href="#T_LOWER">LOWER</a><font color="red">$</font>  |   <a href="#T_VAR">VAR</a><font color="red">$</font>  |   <a href="#T_MODULE">MODULE</a><font color="red">$</font>  |   <a href="#T_SORT">SORT</a><font color="red">$</font>  |   <a href="#T_START">START</a><font color="red">$</font>  |   <a href="#T_DATA">DATA</a><font color="red">$</font>  |   <a href="#T_STATIC">STATIC</a><font color="red">$</font>  |   <a href="#T_SYMBOL">SYMBOL</a><font color="red">$</font>  |   <a href="#T_SCHEME">SCHEME</a><font color="red">$</font>  |   <a href="#T_AUTOMATIC">AUTOMATIC</a><font color="red">$</font>  |   <a href="#T_ATTRIBUTE">ATTRIBUTE</a><font color="red">$</font>  |   <a href="#T_COMPOSE">COMPOSE</a><font color="red">$</font>  |   <a href="#T_SUGAR">SUGAR</a><font color="red">$</font>  |   <a href="#T_RULE">RULE</a><font color="red">$</font>  |   <a href="#T_PRIORITY">PRIORITY</a><font color="red">$</font>  |   <a href="#T_DEFAULT">DEFAULT</a><font color="red">$</font>  |   <a href="#T_SPACE">SPACE</a><font color="red">$</font>  |   <a href="#T_IMPORT">IMPORT</a><font color="red">$</font>  |   <a href="#T_TOKEN">TOKEN</a><font color="red">$</font>  |   <a href="#T_FRAGMENT">FRAGMENT</a><font color="red">$</font>  |   <a href="#T_NESTED">NESTED</a><font color="red">$</font>  |   <a href="#T_TAG">TAG</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_Variable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Variable> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Variable>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_LOWER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_VAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_MODULE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SORT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_START>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DATA>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_STATIC>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SYMBOL>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SCHEME>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_AUTOMATIC>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_ATTRIBUTE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_COMPOSE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SUGAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_RULE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_PRIORITY>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DEFAULT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SPACE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_IMPORT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_TOKEN>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_FRAGMENT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_NESTED>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_TAG>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>MetaVariable$WithEOF</em> ::= <em>MetaVariable</em> EOF . */
net.sf.crsx.Sink N_MetaVariable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_MetaVariable(sink, env) <EOF> {return sink;} }

/** Special meta-variable for MetaVariable production. */
TOKEN : {<MT_MetaVariable : "#MetaVariable" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token MetaVariable production. */
TOKEN : {<IT_MetaVariable : "%MetaVariable">}

/**
 * <em>MetaVariable</em> ::=  (   <a href="#T_META">META</a><font color="red">$</font>  |   <a href="#T_HASH">HASH</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_MetaVariable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_MetaVariable> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_MetaVariable>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_META>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** Special meta-variable for Separator production. */
TOKEN : {<MT_Separator : "#Separator" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Separator production. */
TOKEN : {<IT_Separator : "%Separator">}

/**
 * <em>Separator</em> ::=  (   <a href="#T_BAR">BAR</a><font color="red">$</font>  |   <a href="#T_SEMI">SEMI</a><font color="red">$</font>  |   <a href="#T_COMMA">COMMA</a><font color="red">$</font>  |   <a href="#T_COLON">COLON</a><font color="red">$</font>  |   <a href="#T_STAR">STAR</a><font color="red">$</font>  |   <a href="#T_DOT">DOT</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_Separator(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Separator> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Separator>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_BAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_SEMI>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_COMMA>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_COLON>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_STAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DOT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>Literal$WithEOF</em> ::= <em>Literal</em> EOF . */
net.sf.crsx.Sink N_Literal$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_Literal(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Literal production. */
TOKEN : {<MT_Literal : "#Literal" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Literal production. */
TOKEN : {<IT_Literal : "%Literal">}

/**
 * <em>Literal</em> ::=  <a href="#N_String">&lang;String&rang;</a>   <br>
 *  |  <a href="#N_Number">&lang;Number&rang;</a>  
 */
net.sf.crsx.Sink N_Literal(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Literal> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Literal>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_String(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_Number(sink, env)
	 ) 
	{return sink;}
}

/** Special meta-variable for Number production. */
TOKEN : {<MT_Number : "#Number" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Number production. */
TOKEN : {<IT_Number : "%Number">}

/**
 * <em>Number</em> ::=  <a href="#N_Natural">&lang;Natural&rang;</a>   <br>
 *  |   <a href="#T_UNNATURAL">UNNATURAL</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_Number(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Number> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Number>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_Natural(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	t=<T_UNNATURAL>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for Natural production. */
TOKEN : {<MT_Natural : "#Natural" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Natural production. */
TOKEN : {<IT_Natural : "%Natural">}

/**
 * <em>Natural</em> ::=   <a href="#T_DIGIT">DIGIT</a><font color="red">$</font>  <br>
 *  |   <a href="#T_NATURAL">NATURAL</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_Natural(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Natural> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Natural>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_DIGIT>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_NATURAL>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for String production. */
<DEFAULT, RE> TOKEN : {<MT_String : "#String" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token String production. */
<DEFAULT, RE> TOKEN : {<IT_String : "%String">}

/**
 * <em>String</em> ::=   <a href="#T_STRING">STRING</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_String(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_String> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_String>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_STRING>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>Word$WithEOF</em> ::= <em>Word</em> EOF . */
net.sf.crsx.Sink N_Word$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_Word(sink, env) <EOF> {return sink;} }

/** Special meta-variable for Word production. */
<DEFAULT, RE> TOKEN : {<MT_Word : "#Word" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token Word production. */
<DEFAULT, RE> TOKEN : {<IT_Word : "%Word">}

/**
 * <em>Word</em> ::=  (   <a href="#T_UPPER">UPPER</a><font color="red">$</font>  |   <a href="#T_DASH">DASH</a><font color="red">$</font>  |   <a href="#T_CON">CON</a><font color="red">$</font>  |   <a href="#T_WORD">WORD</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_Word(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_Word> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_Word>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_UPPER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CON>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_WORD>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>RegExpClass$WithEOF</em> ::= <em>RegExpClass</em> EOF . */
net.sf.crsx.Sink N_RegExpClass$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(RE);} sink=N_RegExpClass(sink, env) <EOF> {return sink;} }

/** Special meta-variable for RegExpClass production. */
<RE> TOKEN : {<MT_RegExpClass : "#RegExpClass" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token RegExpClass production. */
<RE> TOKEN : {<IT_RegExpClass : "%RegExpClass">}

/**
 * <em>RegExpClass</em> ::=   <a href="#T_CHAR_CLASS">CHAR_CLASS</a><font color="red">$$:unwrap:{hxCC}</font> 
 */
net.sf.crsx.Sink N_RegExpClass(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_RegExpClass> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_RegExpClass>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_CHAR_CLASS>
	{
		try {sink = factory.parser(factory).parse(sink, "hxCC", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

/** <em>CC$WithEOF</em> ::= <em>CC</em> EOF . */
net.sf.crsx.Sink N_CC$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC production. */
<CC> TOKEN : {<MT_CC : "#CC" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC production. */
<CC> TOKEN : {<IT_CC : "%CC">}

/**
 * <em>CC</em> ::=  <a href="#N_CC_RangesTop">&lang;CC_RangesTop&rang;</a>  
 */
net.sf.crsx.Sink N_CC(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_CC> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	sink=N_CC_RangesTop(sink, env)
	 ) 
	{return sink;}
}

/** <em>CC_RangesTop$WithEOF</em> ::= <em>CC_RangesTop</em> EOF . */
net.sf.crsx.Sink N_CC_RangesTop$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_RangesTop(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_RangesTop production. */
<CC> TOKEN : {<MT_CC_RangesTop : "#CC_RangesTop" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_RangesTop production. */
<CC> TOKEN : {<IT_CC_RangesTop : "%CC_RangesTop">}

/**
 * <em>CC_RangesTop</em> ::=  <font color="red">{RegExpClassNot}</font><font color="red">:hx</font>    <a href="#T_CC_NOT">CC_NOT</a>   <a href="#N_CC_FirstRangeStartChar">&lang;CC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>   <br>
 *  |  <a href="#N_CC_FirstRangeStartChar">&lang;CC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>   <br>
 *  |   <a href="#T_CC_SKIP">CC_SKIP</a>   <a href="#N_CC_RangesTop">&lang;CC_RangesTop&rang;</a>  
 */
net.sf.crsx.Sink N_CC_RangesTop(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink s1 = null;
	net.sf.crsx.Sink bs__lo = null;
	net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_CC_RangesTop> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_RangesTop>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassNot"), null)) ;
	}
	 ) 
	 ( 
	 <T_CC_NOT>
	 ) 
	 ( 
	{
		bs__lo = b__lo.sink();
	}
	N_CC_FirstRangeStartChar(bs__lo, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, true) ;
	}
	sink=N_CC_RangeTail(sink, env, b1)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		bs__lo = b__lo.sink();
	}
	N_CC_FirstRangeStartChar(bs__lo, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, true) ;
	}
	sink=N_CC_RangeTail(sink, env, b1)
	 ) 
	{return sink;}
 |
	 ( 
	 <T_CC_SKIP>
	 ) 
	 ( 
	sink=N_CC_RangesTop(sink, env)
	 ) 
	{return sink;}
}

/** <em>CC_Ranges$WithEOF</em> ::= <em>CC_Ranges</em> EOF . */
net.sf.crsx.Sink N_CC_Ranges$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_Ranges(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_Ranges production. */
<CC> TOKEN : {<MT_CC_Ranges : "#CC_Ranges" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_Ranges production. */
<CC> TOKEN : {<IT_CC_Ranges : "%CC_Ranges">}

/**
 * <em>CC_Ranges</em> ::=  <a href="#N_CC_RangeChar">&lang;CC_RangeChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>   <br>
 *  |   <a href="#T_CC_SKIP">CC_SKIP</a>   <a href="#N_CC_Ranges">&lang;CC_Ranges&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassDone}</font><font color="red">:hx</font> 
 */
net.sf.crsx.Sink N_CC_Ranges(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink s1 = null;
	net.sf.crsx.Sink bs__lo = null;
	net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_CC_Ranges> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_Ranges>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		bs__lo = b__lo.sink();
	}
	N_CC_RangeChar(bs__lo, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, true) ;
	}
	sink=N_CC_RangeTail(sink, env, b1)
	 ) 
	{return sink;}
 |
	 ( 
	 <T_CC_SKIP>
	 ) 
	 ( 
	sink=N_CC_Ranges(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for CC_RangeTail production. */
<CC> TOKEN : {<MT_CC_RangeTail : "#CC_RangeTail" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_RangeTail production. */
<CC> TOKEN : {<IT_CC_RangeTail : "%CC_RangeTail">}

/**
 * <em>CC_RangeTail</em> ::=   <a href="#T_CC_DASH">CC_DASH</a>   (  <font color="red">{RegExpClassRange}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <a href="#N_CC_RangeChar">&lang;CC_RangeChar&rang;</a>    <a href="#N_CC_Ranges">&lang;CC_Ranges&rang;</a>   |  <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:hx</font>  )  <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <a href="#N_CC_NonDashRangeStartChar">&lang;CC_NonDashRangeStartChar&rang;</a> <font color="red">:#lo2</font>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo2&rang;</a>   <br>
 *  |   <a href="#T_CC_SKIP">CC_SKIP</a>   <a href="#N_CC_RangeTail">&lang;CC_RangeTail #lo&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:hx</font> 
 */
net.sf.crsx.Sink N_CC_RangeTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__lo) :
{
	Token t = null;
	net.sf.crsx.Sink s1 = null;
	net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__lo2 = null;
	net.sf.crsx.util.Buffer b__lo2 = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_CC_RangeTail> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_RangeTail>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	 <T_CC_DASH>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassRange"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__lo, false) ;
		}
		 ) 
		 ( 
		sink=N_CC_RangeChar(sink, env)
		 ) 
		 ( 
		sink=N_CC_Ranges(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__lo, false) ;
		}
		 ) 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
		}
		 ) 
		{
			sink = sink .end().end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .copy(b__lo, false) ;
	}
	 ) 
	 ( 
	{
		bs__lo2 = b__lo2.sink();
	}
	N_CC_NonDashRangeStartChar(bs__lo2, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo2, true) ;
	}
	sink=N_CC_RangeTail(sink, env, b1)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_CC_SKIP>
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, false) ;
	}
	sink=N_CC_RangeTail(sink, env, b1)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .copy(b__lo, false) ;
	}
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
	}
	 ) 
	{
		return sink .end().end() ;
	}
}

/** <em>CC_FirstRangeStartChar$WithEOF</em> ::= <em>CC_FirstRangeStartChar</em> EOF . */
net.sf.crsx.Sink N_CC_FirstRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_FirstRangeStartChar(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_FirstRangeStartChar production. */
<CC> TOKEN : {<MT_CC_FirstRangeStartChar : "#CC_FirstRangeStartChar" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_FirstRangeStartChar production. */
<CC> TOKEN : {<IT_CC_FirstRangeStartChar : "%CC_FirstRangeStartChar">}

/**
 * <em>CC_FirstRangeStartChar</em> ::=  (   <a href="#T_CC_RBRACKET">CC_RBRACKET</a><font color="red">$</font>  |   <a href="#T_CC_DASH">CC_DASH</a><font color="red">$</font>  |   <a href="#T_CC_OTHER">CC_OTHER</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_CC_FirstRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_CC_FirstRangeStartChar> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_FirstRangeStartChar>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_CC_RBRACKET>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_OTHER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>CC_NonDashRangeStartChar$WithEOF</em> ::= <em>CC_NonDashRangeStartChar</em> EOF . */
net.sf.crsx.Sink N_CC_NonDashRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_NonDashRangeStartChar(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_NonDashRangeStartChar production. */
<CC> TOKEN : {<MT_CC_NonDashRangeStartChar : "#CC_NonDashRangeStartChar" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_NonDashRangeStartChar production. */
<CC> TOKEN : {<IT_CC_NonDashRangeStartChar : "%CC_NonDashRangeStartChar">}

/**
 * <em>CC_NonDashRangeStartChar</em> ::=  (   <a href="#T_CC_NOT">CC_NOT</a><font color="red">$</font>  |   <a href="#T_CC_OTHER">CC_OTHER</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_CC_NonDashRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_CC_NonDashRangeStartChar> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_NonDashRangeStartChar>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_CC_NOT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_OTHER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>CC_RangeChar$WithEOF</em> ::= <em>CC_RangeChar</em> EOF . */
net.sf.crsx.Sink N_CC_RangeChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(CC);} sink=N_CC_RangeChar(sink, env) <EOF> {return sink;} }

/** Special meta-variable for CC_RangeChar production. */
<CC> TOKEN : {<MT_CC_RangeChar : "#CC_RangeChar" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token CC_RangeChar production. */
<CC> TOKEN : {<IT_CC_RangeChar : "%CC_RangeChar">}

/**
 * <em>CC_RangeChar</em> ::=  (   <a href="#T_CC_NOT">CC_NOT</a><font color="red">$</font>  |   <a href="#T_CC_DASH">CC_DASH</a><font color="red">$</font>  |   <a href="#T_CC_OTHER">CC_OTHER</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_CC_RangeChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_CC_RangeChar> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_CC_RangeChar>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
		 ( 
		t=<T_CC_NOT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_CC_OTHER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>ParsedForm$WithEOF</em> ::= <em>ParsedForm</em> EOF . */
net.sf.crsx.Sink N_ParsedForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_ParsedForm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for ParsedForm production. */
TOKEN : {<MT_ParsedForm : "#ParsedForm" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token ParsedForm production. */
TOKEN : {<IT_ParsedForm : "%ParsedForm">}

/**
 * <em>ParsedForm</em> ::=   <a href="#T_CONCRETE">CONCRETE</a><font color="red">$$:unpp:{hxPP}</font> 
 */
net.sf.crsx.Sink N_ParsedForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_ParsedForm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_ParsedForm>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	t=<T_CONCRETE>
	{
		try {sink = factory.parser(factory).parse(sink, "hxPP", new java.io.StringReader(unpp(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

/** <em>PP$WithEOF</em> ::= <em>PP</em> EOF . */
net.sf.crsx.Sink N_PP$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(PP);} sink=N_PP(sink, env) <EOF> {return sink;} }

/** Special meta-variable for PP production. */
<PP> TOKEN : {<MT_PP : "#PP" ((<T_DIGIT>)* | "_" (<T_DIGIT> | <T_UPPER> | <T_LOWER>)*) "#">}

/** Special inject token PP production. */
<PP> TOKEN : {<IT_PP : "%PP">}

/**
 * <em>PP</em> ::=  <font color="red">{ParsedFormSpace}</font><font color="red">:hx</font>   (   <a href="#T_PP_CONCRETESPACE">PP_CONCRETESPACE</a><font color="red">$</font>  )   <a href="#N_PP">&lang;PP&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormWord}</font><font color="red">:hx</font>   (   <a href="#T_PP_CONCRETEWORD">PP_CONCRETEWORD</a><font color="red">$</font>  )   <a href="#N_PP">&lang;PP&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormTerm}</font><font color="red">:hx</font>    <a href="#T_PP_UNCONCRETE">PP_UNCONCRETE</a><font color="red">$$:unpp:{hxScopeSortPrecRepeat}</font>   <a href="#N_PP">&lang;PP&rang;</a>   <br>
 *  |   <a href="#T_PP_SKIP">PP_SKIP</a>   <a href="#N_PP">&lang;PP&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormDone}</font><font color="red">:hx</font> 
 */
net.sf.crsx.Sink N_PP(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_PP> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_SortParam(sink, env)( "\u2225" sink=N_SortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_PP>  {sink=N_Embedded(sink, env);}  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormSpace"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		t=<T_PP_CONCRETESPACE>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_PP(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormWord"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		t=<T_PP_CONCRETEWORD>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_PP(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormTerm"), null)) ;
	}
	 ) 
	 ( 
	t=<T_PP_UNCONCRETE>
	{
		try {sink = factory.parser(factory).parse(sink, "hxScopeSortPrecRepeat", new java.io.StringReader(unpp(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	 ( 
	sink=N_PP(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_PP_SKIP>
	 ) 
	 ( 
	sink=N_PP(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormDone"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

// Nested unconcrete token ... inside PP.
<PP> MORE : { "\u27e8" { nesting = 0; nestedState = curLexState; } : IN_PP_UNCONCRETE }
<IN_PP_UNCONCRETE> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_PP_UNCONCRETE }
<IN_NESTED_PP_UNCONCRETE> MORE : { "\u27e8" { nesting++; } }
<IN_NESTED_PP_UNCONCRETE> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_PP_UNCONCRETE); } }
<IN_PP_UNCONCRETE> TOKEN : { <T_PP_UNCONCRETE : "\u27e9"> { SwitchTo(nestedState); } }
<IN_PP_UNCONCRETE,IN_NESTED_PP_UNCONCRETE> MORE : { < ~[] > }


net.sf.crsx.Sink N_Store_SortName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b = new net.sf.crsx.util.Buffer(sink);
}
{
	N_SortName(b.sink(), env)
	{
		net.sf.crsx.Term term = b.term(false);
		storedSort = net.sf.crsx.util.Util.symbol(term);
		return term.copy(sink, true, net.sf.crsx.util.LinkedExtensibleMap.EMPTY_RENAMING);
	}
}

net.sf.crsx.Sink N_Stored_SortName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{
	{return sink.start(sink.makeLiteral(storedSort, net.sf.crsx.CRS.STRING_SORT)).end();}
}

net.sf.crsx.Sink N_Storing_Declarations(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	String savedStoredSort = storedSort;
}
{
	sink=N_Declarations(sink, env)
	{
		storedSort = savedStoredSort;
		return sink;
	}
}


/**
 * Embedded ::=  "<code></code>" (&not;["<code></code>","<code></code>"])*  "<code></code>"
 */
<*> TOKEN : {<T_Embedded : "\253" (~["\253","\273"])* "\273" >}

/**
 * <b>skip</b><font color="red"> (DEFAULT, RE)</font> ::=  "<code> </code>" | <code>&#92;r</code> | <code>&#92;t</code> | <code>&#92;n</code> |  "<code>//</code>" &not;[<code>&#92;n</code><code>&#92;r</code>]* | <code>&#92;u1</code>
 */
<DEFAULT, RE> SKIP : { <" " | "\r" | "\t" | "\n" | "//" (~["\n","\r"])* | "\001"> }

/**
 * SEMI ::=  "<code>;</code>"
 */
<DEFAULT, RE> TOKEN : {<T_SEMI : ";" >: DEFAULT}

/**
 * BAR ::=  "<code>|</code>"
 */
<DEFAULT, RE> TOKEN : {<T_BAR : "|" >}

/**
 * LPAREN ::=  "<code>(</code>"
 */
<DEFAULT, RE> TOKEN : {<T_LPAREN : "(" >}

/**
 * RPAREN ::=  "<code>)</code>"
 */
<DEFAULT, RE> TOKEN : {<T_RPAREN : ")" >}

/**
 * STAR ::=  "<code>*</code>"
 */
<DEFAULT, RE> TOKEN : {<T_STAR : "*" >}

/**
 * PLUS ::=  "<code>+</code>"
 */
<DEFAULT, RE> TOKEN : {<T_PLUS : "+" >}

/**
 * QUEST ::=  "<code>?</code>"
 */
<DEFAULT, RE> TOKEN : {<T_QUEST : "?" >}

/**
 * SUB ::=  "<code>_</code>"
 */
<DEFAULT, RE> TOKEN : {<T_SUB : "_" >}

/**
 * DOT ::=  "<code>.</code>"
 */
<DEFAULT, RE> TOKEN : {<T_DOT : "." >}

/**
 * COLON ::=  "<code>:</code>"
 */
<DEFAULT, RE> TOKEN : {<T_COLON : ":" >}

/**
 * LBRACE ::=  "<code>{</code>"
 */
TOKEN : {<T_LBRACE : "{" >}

/**
 * RBRACE ::=  "<code>}</code>"
 */
TOKEN : {<T_RBRACE : "}" >}

/**
 * HASH ::=  "<code>#</code>"
 */
TOKEN : {<T_HASH : "#" >}

/**
 * LBRACKET ::=  "<code>[</code>"
 */
TOKEN : {<T_LBRACKET : "[" >}

/**
 * RBRACKET ::=  "<code>]</code>"
 */
TOKEN : {<T_RBRACKET : "]" >}

/**
 * COMMA ::=  "<code>,</code>"
 */
TOKEN : {<T_COMMA : "," >}

/**
 * FORALL ::= <code>&#92;u2200</code>
 */
TOKEN : {<T_FORALL : "\u2200" >}

/**
 * ARROW ::= <code>&#92;u2192</code>
 */
TOKEN : {<T_ARROW : "\u2192" >}

/**
 * UP ::= <code>&#92;u2191</code>
 */
TOKEN : {<T_UP : "\u2191" >}

/**
 * DOWN ::= <code>&#92;u2193</code>
 */
TOKEN : {<T_DOWN : "\u2193" >}

/**
 * NOT ::= <code>&#92;u00ac</code>
 */
TOKEN : {<T_NOT : "\254" >}

/**
 * AT ::=  "<code>@</code>"
 */
TOKEN : {<T_AT : "@" >}

/**
 * DASH ::=  "<code>-</code>"
 */
TOKEN : {<T_DASH : "-" >}

/**
 * DIGIT ::= [<code>0</code>&ndash;<code>9</code>]
 */
TOKEN : {<T_DIGIT : ["0"-"9"] >}

/**
 * LOWER ::= [<code>a-z</code>]
 */
TOKEN : {<T_LOWER : ["a"-"z"] >}

/**
 * UPPER ::= [<code>A-Z</code>]
 */
<DEFAULT, RE> TOKEN : {<T_UPPER : ["A"-"Z"] >}

/**
 * MODULE ::=  "<code>module</code>"
 */
TOKEN : {<T_MODULE : "module" >}

/**
 * SORT ::=  "<code>sort</code>"
 */
TOKEN : {<T_SORT : "sort" >}

/**
 * START ::=  "<code>start</code>"
 */
TOKEN : {<T_START : "start" >}

/**
 * DATA ::=  "<code>data</code>"
 */
TOKEN : {<T_DATA : "data" >}

/**
 * SCHEME ::=  "<code>scheme</code>"
 */
TOKEN : {<T_SCHEME : "scheme" >}

/**
 * AUTOMATIC ::=  "<code>automatic</code>"
 */
TOKEN : {<T_AUTOMATIC : "automatic" >}

/**
 * SYMBOL ::=  "<code>symbol</code>"
 */
TOKEN : {<T_SYMBOL : "symbol" >}

/**
 * STATIC ::=  "<code>static</code>"
 */
TOKEN : {<T_STATIC : "static" >}

/**
 * ATTRIBUTE ::=  "<code>attribute</code>"
 */
TOKEN : {<T_ATTRIBUTE : "attribute" >}

/**
 * COMPOSE ::=  "<code>compose</code>"
 */
TOKEN : {<T_COMPOSE : "compose" >}

/**
 * SUGAR ::=  "<code>sugar</code>"
 */
TOKEN : {<T_SUGAR : "sugar" >}

/**
 * RULE ::=  "<code>rule</code>"
 */
TOKEN : {<T_RULE : "rule" >}

/**
 * PRIORITY ::=  "<code>priority</code>"
 */
TOKEN : {<T_PRIORITY : "priority" >}

/**
 * DEFAULT ::=  "<code>default</code>"
 */
TOKEN : {<T_DEFAULT : "default" >}

/**
 * IMPORT ::=  "<code>import</code>"
 */
TOKEN : {<T_IMPORT : "import" >}

/**
 * TAG ::=  "<code>tag</code>"
 */
TOKEN : {<T_TAG : "tag" >}

/**
 * SPACE ::=  "<code>space</code>"
 */
<DEFAULT> TOKEN : {<T_SPACE : "space" >: RE}

/**
 * TOKEN ::=  "<code>token</code>"
 */
<DEFAULT> TOKEN : {<T_TOKEN : "token" >: RE}

/**
 * FRAGMENT ::=  "<code>fragment</code>"
 */
<DEFAULT, RE> TOKEN : {<T_FRAGMENT : "fragment" >: RE}

/**
 * NESTED ::=  "<code>nested</code>"
 */
<RE> TOKEN : {<T_NESTED : "nested" >}

/**
 * META ::= HASH (NAME | STRING)? (HASH NAME)* SUFFIX*
 */
TOKEN : {<T_META : <T_HASH> (<T_NAME> | <T_STRING>)? (<T_HASH> <T_NAME>)* (<T_SUFFIX>)* >}

/**
 * VAR ::= LOWER NAME? SUFFIX* |  "<code>v</code>" STRING SUFFIX*
 */
TOKEN : {<T_VAR : <T_LOWER> (<T_NAME>)? (<T_SUFFIX>)* | "v" <T_STRING> (<T_SUFFIX>)* >}

/**
 * CON ::= (UPPER | [<code>$</code>]) NAME? SUFFIX* |  "<code>C</code>" STRING SUFFIX*
 */
<DEFAULT, RE> TOKEN : {<T_CON : (<T_UPPER> | ["$"]) (<T_NAME>)? (<T_SUFFIX>)* | "C" <T_STRING> (<T_SUFFIX>)* >}

/**
 * SUFFIX ::=  "<code>_</code>" NAME? |  "<code>_</code>"? NATURAL NAME?
 */
TOKEN : {<#T_SUFFIX : "_" (<T_NAME>)? | ("_")? <T_NATURAL> (<T_NAME>)? >}

/**
 * NAME ::= (LOWER | UPPER | [<code>$</code>])+
 */
TOKEN : {<#T_NAME : (<T_LOWER> | <T_UPPER> | ["$"])+ >}

/**
 * FRAGMENT_REF ::= <code>&#92;u27e8</code> (UPPER | DASH | CON) <code>&#92;u27e9</code>
 */
<RE> TOKEN : {<T_FRAGMENT_REF : "\u27e8" (<T_UPPER> | <T_DASH> | <T_CON>) "\u27e9" >}

/**
 * NATURAL ::= DIGIT+
 */
TOKEN : {<T_NATURAL : (<T_DIGIT>)+ >}

/**
 * INTEGER ::= [&ndash;<code>+</code>]* NATURAL
 */
TOKEN : {<#T_INTEGER : (["-","+"])* <T_NATURAL> >}

/**
 * UNNATURAL ::= (INTEGER?  "<code>.</code>" NATURAL) ([<code>Ee</code>] INTEGER)? | INTEGER [<code>Ee</code>] INTEGER
 */
TOKEN : {<T_UNNATURAL : ((<T_INTEGER>)? "." <T_NATURAL>) (["E","e"] <T_INTEGER>)? | <T_INTEGER> ["E","e"] <T_INTEGER> >}

/**
 * STRING ::=  "<code>'</code>" STRING1CHAR*  "<code>'</code>" |  "<code>"</code>" STRING2CHAR*  "<code>"</code>"
 */
<DEFAULT, RE> TOKEN : {<T_STRING : "\'" (<T_STRING1CHAR>)* "\'" | "\"" (<T_STRING2CHAR>)* "\"" >}

/**
 * STRING1CHAR ::= &not;[<code>&#92;&#92;</code><code>'</code><code>&#92;n</code>] | ESCAPEDCHAR
 */
TOKEN : {<#T_STRING1CHAR : ~["\\","\'","\n"] | <T_ESCAPEDCHAR> >}

/**
 * STRING2CHAR ::= &not;[<code>&#92;&#92;</code><code>"</code><code>&#92;n</code>] | ESCAPEDCHAR
 */
TOKEN : {<#T_STRING2CHAR : ~["\\","\"","\n"] | <T_ESCAPEDCHAR> >}

/**
 * ESCAPEDCHAR ::= [<code>&#92;&#92;</code>] &not;[<code>0</code>&ndash;<code>9</code><code>uUx</code>] | [<code>&#92;&#92;</code>] [<code>0</code>&ndash;<code>3</code>]? [<code>0</code>&ndash;<code>7</code>]? [<code>0</code>&ndash;<code>7</code>] | [<code>&#92;&#92;</code>] [<code>u</code>] HEX? HEX? HEX? HEX | [<code>&#92;&#92;</code>] [<code>U</code>] HEX? HEX? HEX? HEX? HEX? HEX? HEX? HEX | [<code>&#92;&#92;</code>] [<code>x</code>] (HEX HEX |  "<code>{</code>" HEX+  "<code>}</code>")
 */
<DEFAULT, RE> TOKEN : {<T_ESCAPEDCHAR : ["\\"] ~["0"-"9","u","U","x"] | ["\\"] (["0"-"3"])? (["0"-"7"])? ["0"-"7"] | ["\\"] ["u"] (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? <T_HEX> | ["\\"] ["U"] (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? (<T_HEX>)? <T_HEX> | ["\\"] ["x"] (<T_HEX> <T_HEX> | "{" (<T_HEX>)+ "}") >}

/**
 * HEX ::= [<code>0</code>&ndash;<code>9</code><code>A-Fa-f</code>]
 */
TOKEN : {<#T_HEX : ["0"-"9","A"-"F","a"-"f"] >}

/**
 * OTHERCHAR ::= &not;[]
 */
TOKEN : {<T_OTHERCHAR : ~[] >}

/**
 * WORD ::= &not;["<code></code>","<code></code>","<code></code>","<code></code>","<code>(</code>","<code>)</code>","<code>[</code>","<code>]</code>","<code>.</code>","<code>*</code>","<code>+</code>","<code>?</code>","<code>;</code>","<code>"</code>","<code>'</code>","<code>,</code>","<code>:</code>","<code></code>","<code></code>","<code> </code>",<code>&#92;t</code>,<code>&#92;&#92;</code>,<code>&#92;n</code>]+
 */
<RE> TOKEN : {<T_WORD : (~["\u27e8","\u27e9","\u27e6","\u27e7","(",")","[","]",".","*","+","?",";","\"","\'",",",":","\253","\273"," ","\t","\\","\n"])+ >}

/**
 * CHAR_CLASS ::=  "<code>[</code>" ( "<code>^</code>")? ( "<code>]</code>")? (&not;["<code>]</code>",<code>&#92;&#92;</code>,<code>&#92;n</code>] | ESCAPEDCHAR)*  "<code>]</code>"
 */
<RE> TOKEN : {<T_CHAR_CLASS : "[" ("^")? ("]")? (~["]","\\","\n"] | <T_ESCAPEDCHAR>)* "]" >}

/**
 * CC_NOT ::=  "<code>^</code>"
 */
<CC> TOKEN : {<T_CC_NOT : "^" >}

/**
 * CC_RBRACKET ::=  "<code>]</code>"
 */
<CC> TOKEN : {<T_CC_RBRACKET : "]" >}

/**
 * CC_DASH ::=  "<code>-</code>"
 */
<CC> TOKEN : {<T_CC_DASH : "-" >}

/**
 * CC_OTHER ::= &not;["<code>^</code>","<code>]</code>","<code>-</code>",<code>&#92;&#92;</code>,<code>&#92;n</code>,<code>&#92;u1</code>] | ESCAPEDCHAR
 */
<CC> TOKEN : {<T_CC_OTHER : ~["^","]","-","\\","\n","\001"] | <T_ESCAPEDCHAR> >}

/**
 * CC_SKIP ::= <code>&#92;u1</code>
 */
<CC> TOKEN : {<T_CC_SKIP : "\001" >}

/**
 * PP_CONCRETESPACE ::= ["<code> </code>",<code>&#92;t</code><code>&#92;r</code><code>&#92;n</code>,<code>&#92;ub6</code>]+
 */
<PP> TOKEN : {<T_PP_CONCRETESPACE : ([" ","\t","\r","\n","\266"])+ >}

/**
 * PP_CONCRETEWORD ::= &not;["<code> </code>",<code>&#92;t</code><code>&#92;r</code><code>&#92;n</code><code>&#92;ub6</code><code>&#92;u27e6</code><code>&#92;u27e7</code><code>&#92;u27e8</code><code>&#92;u27e9</code><code>&#92;u1</code>]+
 */
<PP> TOKEN : {<T_PP_CONCRETEWORD : (~[" ","\t","\r","\n","\266","\u27e6","\u27e7","\u27e8","\u27e9","\001"])+ >}

/**
 * PP_SKIP ::= <code>&#92;u1</code>
 */
<PP> TOKEN : {<T_PP_SKIP : "\001" >}

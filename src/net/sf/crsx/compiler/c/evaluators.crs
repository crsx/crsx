// Copyright © 2012,2013 IBM Corporation
// $Id: evaluators.crs,v 3.71 2014/02/05 23:02:01 krisrose Exp $

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERATE C FUNCTION BODY FRAGMENT FROM EVALUATOR $[PRIMITIVE,...]
//
// Every PRIMITIVE evaluator $Primitive in ../defs.crs needs several variants: 
//
// * {#env} E-eval[PRIMITIVE, ARGUMENT_TERMS, OPTIONS, sink] - evaluate primitive and send result to sink
// * {#env} E-send[PRIMITIVE, ARGUMENT_TERMS, OPTIONS, sink] - send computed term to sink
// * {#env} E-set[PRIMITIVE, ARGUMENT_TERMS, OPTIONS, sink, variable] - set Term variable
// * {#env} E-set-ref[PRIMITIVE, ARGUMENT_TERMS, OPTIONS, sink, variable] - set Term reference variable. Variable owns a term reference.
// * {#env} E-set-bool[PRIMITIVE, ARGUMENT_TERMS, OPTIONS, sink, variable] - set boolean (int) variable
// * {#env} E-set-int[PRIMITIVE, ARGUMENT_TERMS, OPTIONS, sink, variable] - set integer (long long) variable
// * {#env} E-set-num[PRIMITIVE, ARGUMENT_TERMS, OPTIONS, sink, variable] - set generic numeric (double) variable
// * {#env} E-set-string[PRIMITIVE, ARGUMENT_TERMS, OPTIONS, sink, variable] - set allocated string (char*) variable
// * {#env} E-local-string[PRIMITIVE, ARGUMENT_TERMS, OPTIONS, sink, s p.#[s, p]] - set local s (char*) variable in #. Apply post processing p
//
// In each case, the ARGUMENT_TERMS has *all* the subterms, including the original PRIMITIVE subterm.
// The OPTIONS are the options extracted from the reified term.
// The generated value is sent to the sink for E-send and assigned to the variable for the rest.
// We group the evaluator primitive implementations by their principal value type.
//
// In addition, pattern-permitted primitives have
// 
// * {#env} E-Pattern[PRIMITIVE, PATTERNS, sink, term, ok.CONTINUATION[ok]]
//
///////////////////////////////////////////////////////////////////////////////////////////////////

EVAL[(

$Use["compiler/c/cdefs.crs"];
$Use["compiler/reify.crs"];

$Lax;

E1[(

///////////////////////////////////////////////////////////////////////////////////////////////////
// UTILITIES

// Simple casts from term.
//

E-term-to-string[Text, Text, Text] :: Text;

E-term-to-string[#sink, #term, #variable] → %n⟪
«#variable» = SYMBOL(«#term»);⟫;

E-term-to-local-string[Text, Text, s::Text p::Text.Text] :: Text;

-[Fresh[variable::Text]]:
E-term-to-local-string[#sink, #term, s p.#[s,p]] → %n⟪
{char* «variable» = SYMBOL(«#term»); «#[variable, %n⟨⟩]»}⟫;

E-term-to-int[Text, Text, Text] :: Text;

E-term-to-int[#sink, #term, #variable] → %n⟪
«#variable» = LONGLONG(«#term»);⟫;

E-term-to-num[Text, Text, Text] :: Text;

E-term-to-num[#sink, #term, #variable] → %n⟪
«#variable» = DOUBLE(«#term»);⟫;

// Simple casts from string.
//
E-string-to-set[Text, Text, Text] :: Text;

E-string-to-set[#sink, #str, #variable] → %n⟪
«#variable» = makeStringLiteral(«#sink»->context, «#str»);⟫;

E-string-to-bool[Text, Text, Text] :: Text;

E-string-to-bool[#sink, #str, #variable] → %n⟪
«#variable» = (int) «#str»[0];⟫;

E-string-to-int[Text, Text, Text] :: Text;

E-string-to-int[#sink, #str, #variable] → %n⟪
«#variable» = atoll(«#str»);⟫;

E-string-to-num[Text, Text, Text] :: Text;

E-string-to-num[#sink, #str, #variable] → %n⟪
«#variable» = atof(«#str»);⟫;

// Simple casts from bool.
//
E-bool-to-int[Text, Text, Text] :: Text;

E-bool-to-int[#sink, #bool, #variable] → %n⟪
«#variable» = (long long) «#bool»;⟫;

E-bool-to-num[Text, Text, Text] :: Text;

E-bool-to-num[#sink, #bool, #variable] → %n⟪
«#variable» = (double) «#bool»;⟫;

E-bool-to-string[Text, Text, Text] :: Text;

E-bool-to-string[#sink, #bool, #variable] → %n⟪
«#variable» = («#bool» ? "$True" : "");⟫;

// Simple casts from integers.
//
E-int-to-bool[Text, Text, Text] :: Text;

E-int-to-bool[#sink, #int, #variable] → %n⟪
«#variable» = («#int» != 0);⟫;

E-int-to-num[Text, Text, Text] :: Text;

E-int-to-num[#sink, #int, #variable] → %n⟪
«#variable» = (double) «#int»;⟫;

// Simple casts from numeric.
//
E-num-to-bool[Text, Text, Text] :: Text;

E-num-to-bool[#sink, #num, #variable] → %n⟪
«#variable» = («#num» != 0e0);⟫;

E-num-to-num[Text, Text, Text] :: Text;

E-num-to-num[#sink, #num, #variable] → %n⟪
«#variable» = («#num» != 0ll);⟫; // TODO: incorrect?

// Optional argument.
//
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-optional[$List[Reified_Term], $List[$List[Reified_Option]], Text, ok:OK_SORT arg::Reified_Term.Text] :: Text;

{#env}E-optional[(),       #Option,   #sink, ok arg.#Tail[ok,arg]] → {#env}#Tail[OK, EVALUATOR["Null", (LITERAL["Null", SORT["$String", ()]];), ()]] ;
{#env}E-optional[(#Arg;), (#Option;), #sink, ok arg.#Tail[ok,arg]] → %n⟪«{#env}E-OptionsUnlink[#sink, #Option] »«{#env}#Tail[OK, #Arg]»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-optional-nil[$List[Reified_Term], ok:OK_SORT arg::Reified_Term.Text] :: Text;

{#env}E-optional-nil[(),      ok arg.#Tail[ok,arg]] → {#env}#Tail[OK, EVALUATOR["Nil", (LITERAL["Nil", SORT["$String", ()]];), ()]] ;
{#env}E-optional-nil[(#Arg;), ok arg.#Tail[ok,arg]] → {#env}#Tail[OK, #Arg] ;

// Process Options
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-OptionsUnlink[Text, $List[Reified_Option]] :: Text;

{#env}E-OptionsUnlink[#sink, ()] → %n⟪⟫;
{#env}E-OptionsUnlink[#sink, (#Option;#Options)] → %n⟪«{#env}E-OptionUnlink[#sink, #Option]»«{#env}E-OptionsUnlink[#sink, #Options]»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-OptionUnlink[Text, Reified_Option] :: Text;

{#env}E-OptionUnlink[#sink, OPTION[#Name, #Term]] 
→
$[If, $[Equal, #Name, "Discard"], {#env}E-OptionDiscard[#sink, #Term], %n⟪⟫];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-OptionDiscard[Text, Reified_Term] :: Text;

{#env}E-OptionDiscard[#sink, META-APPLICATION[#MetaVar, #Args, #Use]] → E-OptionDiscard2[#sink, $[{#env}Get[STRING_ENTRY], $[:,"MetaVar$",#MetaVar]]]; 

E-OptionDiscard2[Text, STRING_ENTRY] :: Text;

E-OptionDiscard2[#sink, VARIABLE[#term]]             
→ 
%n⟪
UNLINK(«#sink»->context, «#term»); ⟫;

E-OptionDiscard2[#sink, PROPERTY_VARIABLE[#namedP, #varP]] 
→ 
%n⟪ ⟫
; // property refs are unlink at the end of the step function

// Strict evaluation helpers


{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-send-tail :: Text;

{#env; "$Strict": YES}E-send-tail → ST-send-tail[$[{#env}Get[STRING_ENTRY], "$tail", NO]];
{#env; "$Strict": NO} E-send-tail → %n⟪⟫;

)];

E2[(

///////////////////////////////////////////////////////////////////////////////////////////////////
// Sorts

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text] :: Text;
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-ref[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-bool[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-int[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-num[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-local-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, s::Text p::Text.Text] :: Text;

///////////////////////////////////////////////////////////////////////////////////////////////////
// NULL PRIMITIVE
//

Null-send:             {#env}E-send[E_Null, (#Name;), #Options, #sink] → {#env}E-send-tail ;
Null-set:              {#env}E-set[E_Null, (#Name;), #Options,  #sink, #variable] → %n⟪«#variable» = (Term)0;⟫;
Null-set-ref:          {#env}E-set-ref[E_Null, (#Name;), #Options,  #sink, #variable] → %n⟪«#variable» = (Term)0;⟫;
Null-set-bool:         {#env}E-set-bool[E_Null, (#Name;), #Options,  #sink, #variable] → %n⟪«#variable» = 0;⟫;
Null-set-int:          {#env}E-set-int[E_Null, (#Name;), #Options,  #sink, #variable] → %n⟪«#variable» = 0ll;⟫;
Null-set-num:          {#env}E-set-num[E_Null, (#Name;), #Options,  #sink, #variable] → %n⟪«#variable» = 0e0;⟫;
Null-set-string:       {#env}E-set-string[E_Null, (#Name;), #Options,  #sink, #variable] → %n⟪«#variable» = (char*)0;⟫;
Null-local-string:     {#env}E-local-string[E_Null, (#Name;), #Options,  #sink, s p.#[s,p]] → #[%n⟪((char*)0)⟫, %n⟪⟫];

///////////////////////////////////////////////////////////////////////////////////////////////////
// STREAMING TERM-VALUED EVALUATORS

// Primitives defined using E-send.
//
$Meta[(
  -[Meta,Lax]:
  SEND_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:, ##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-send-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-send-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-send-to-bool[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-int"]: {#env} E-set-int[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-send-to-int[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-send-to-num[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-send-to-string[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-local-string"]: {#env} E-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s,p]] → {#env}E-send-to-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s, p]];
  );
)];


{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-to-set[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[buf::Text]]
:
{#env}E-send-to-set[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);«{#env}E-send[#Primitive, #Args, #Options, buf]»
«#variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»); ⟧
}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-to-bool[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[str::Text]]
:
{#env}E-send-to-bool[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦
char* «str»;«{#env}E-send-to-string[#Primitive, #Args, #Options, #sink, str]»«{#env}E-string-to-bool[#sink, str, #variable]» ⟧}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-to-int[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[str::Text]]
:
{#env}E-send-to-int[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦ 
char* «str»;«{#env}E-send-to-string[#Primitive, #Args, #Options, #sink, str]»«{#env}E-string-to-int[#sink, str, #variable]» ⟧}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-to-num[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[str::Text]]
:
{#env}E-send-to-num[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦
char* «str»;«{#env}E-send-to-string[#Primitive, #Args, #Options, #sink, str]»«{#env}E-string-to-num[#sink, str, #variable]» ⟧}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-to-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[term::Text]]
:
{#env}E-send-to-string[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦ 
Term «term»;«{#env}E-send-to-set[#Primitive, #Args, #Options, #sink, term]»«{#env}E-term-to-string[#sink, term, #variable]»«T-unlink-ref[#sink, term]»⟧}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-to-local-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, s::Text p::Text.Text] :: Text;

-[Fresh[term::Text]]
:
{#env}E-send-to-local-string[#Primitive, #Args, #Options, #sink, s p.#[s,p]] 
→ 
%n⟪
{⟦ 
Term «term»;«{#env}E-send-to-set[#Primitive, #Args, #Options, #sink, term]»«{#env}E-term-to-local-string[#sink, term, s p.#[s,p]]»«T-unlink-ref[#sink, term]»⟧}⟫
;

// $[LoadTerm, #url] parses the URL and returns the term.
//
SEND_PRIMITIVE[E_LoadTerm];

Send-LoadTerm:
{#env}E-send[E_LoadTerm, (#name; #url;), #options, #sink] →
	{#env; "$tail":NO}T-local-string[#url, #sink, url p.%n⟪
LOAD_TERM(«#sink», "", «url»);«p»«{#env}E-send-tail»⟫];

// $[Nil] is synonymous with sending nothing.
//
SEND_PRIMITIVE[E_Nil];

Send-Nil:
{#env}E-send[E_Nil, (#Name;), #Options, #sink] →
	{#env}E-send-tail;

// $[FreeVariables[sortname], t]
//
SEND_PRIMITIVE[E_FreeVariables];

// Without environment and sort.
Send-FreeVariables-Raw[Fresh[term::Text, fvs::Text, link::Text]]
:
{#env}E-send[E_FreeVariables, (LITERAL[#Name, SORT[#SortName, ()]]; #Term;), #Options, #sink]
→
%n⟪
{⟦ 
Term «term»;« {#env; "$tail": NO} T-set[#Term, #sink, term] »
VariableSet «fvs» = makeFreeVariableSet(«#sink»->context, «term», NULL, 0, NULL);
VariableSetLink «link»;
for («link» = «fvs»->u.link; «link»; «link» = «link»->link) { START(«#sink», «EventConstructor["$Cons"]»); USE(«#sink», linkVariable(«#sink»->context, «link»->variable)); }
START(«#sink», «EventConstructor["$Nil"]»); END(«#sink», «EventConstructor["$Nil"]»);
for («link» = «fvs»->u.link; «link»; «link» = «link»->link) { END(«#sink», «EventConstructor["$Cons"]»); }
freeVariableSet(«fvs»);⟧
}«{#env}E-send-tail»⟫
;

// Without environment with sort.
Send-FreeVariables-Unconstrained[Fresh[term::Text, fvs::Text, link::Text]]
:
{#env}E-send[E_FreeVariables, (CONSTRUCTION[#kind, #Name, (ARGUMENT[#Sort1, CONSTRUCTION[#kind, #SortName, ()]]; )]; #Term;), #Options, #sink] 
→
%n⟪
{⟦
Term «term»;« {#env; "$tail":NO} T-set[#Term, #sink, term] »
VariableSet «fvs» = makeFreeVariableSet(«#sink»->context, «term», NULL, 0, NULL);
VariableSetLink «link»;
for («link» = «fvs»->u.link; «link»; «link» = «link»->link) { START(«#sink», «EventConstructor["$Cons"]»); USE(«#sink», linkVariable(«#sink»->context, «link»->variable)); }
START(«#sink», «EventConstructor["$Nil"]»); END(«#sink», «EventConstructor["$Nil"]»);
for («link» = «fvs»->u.link; «link»; «link» = «link»->link) { END(«#sink», «EventConstructor["$Cons"]»); }
freeVariableSet(«fvs»);⟧
}«{#env}E-send-tail»⟫;

// With environment and sort.
Send-FreeVariables-Constrained[Fresh[term::Text, fvs::Text, link::Text]]
:
{#env}E-send[E_FreeVariables, (PROPERTY-REF[#Ref, #Use, CONSTRUCTION[#kind, #Name, (ARGUMENT[#Sort1, CONSTRUCTION[#kind, #SortName, ()]]; )]]; #Term;), #Options, #sink] 
→
%n⟪{⟦ Term «term»;
« {#env; "$tail":NO} T-set[#Term, #sink, term] »VariableSet «fvs» = makeFreeVariableSet(«#sink»->context, «term», NULL, 1, «{#env}E-VariableProperties[$[:,"MetaVar$",#Ref]]»);
VariableSetLink «link»;
for («link» = «fvs»->u.link; «link»; «link» = «link»->link) { START(«#sink», «EventConstructor["$Cons"]»); USE(«#sink», linkVariable(«#sink»->context, «link»->variable)); }
START(«#sink», «EventConstructor["$Nil"]»); END(«#sink», «EventConstructor["$Nil"]»);
for («link» = «fvs»->u.link; «link»; «link» = «link»->link) { END(«#sink», «EventConstructor["$Cons"]»); }
freeVariableSet(«fvs»);⟧
}«{#env}E-send-tail»⟫;

// $[UnionVariables[sortname], vs1, vs2]

SEND_PRIMITIVE[E_UnionVariables];

Send-UnionVariables[Fresh[list::Text,vs::Text,link::Text,v::Text,next::Text]]
:
{#env}E-send[E_UnionVariables, (#Name; #List1; #List2;), #Options, #sink]
→
%n⟪{⟦ Term «list»; VariableSet «vs» = makeVariableSet(«#sink»->context); VariableSetLink «link»;
« {#env; "$tail":NO} T-set[#List1, #sink, list] »while (!strcmp("$Cons",SYMBOL(«list»))) {⟦ Variable «v» = VARIABLE(SUB(«list»,0)); 
if (addVariable(«vs», linkVariable(«#sink»->context, «v»))) {⟦ START(«#sink», «EventConstructor["$Cons"]»); 
USE(«#sink», linkVariable(«#sink»->context, «v»));⟧
} 
Term «next» = LINK(«#sink»->context, SUB(«list»,1));
UNLINK(«#sink»->context, «list»);
«list» = «next»;⟧
}
UNLINK(«#sink»->context, «list»);
« {#env; "$tail":NO} T-set[#List2, #sink, list] »while (!strcmp("$Cons",SYMBOL(«list»))) {⟦ Variable «v» = VARIABLE(SUB(«list»,0));
if (addVariable(«vs»,linkVariable(«#sink»->context, «v»))) {⟦ START(«#sink», «EventConstructor["$Cons"]»); 
USE(«#sink», linkVariable(«#sink»->context, «v»));⟧
}
Term «next» = LINK(«#sink»->context, SUB(«list»,1));
UNLINK(«#sink»->context, «list»);
«list» = «next»;⟧
}
UNLINK(«#sink»->context, «list»);
START(«#sink», «EventConstructor["$Nil"]»); END(«#sink», «EventConstructor["$Nil"]»);
for («link» = «vs»->u.link; «link»; «link» = «link»->link) END(«#sink», «EventConstructor["$Cons"]»);
freeVariableSet(«vs»);⟧
}«{#env}E-send-tail»⟫;

// $[IntersectVariables[sortname], vs1, vs2]

SEND_PRIMITIVE[E_IntersectVariables];

Send-IntersectVariables[Fresh[list::Text,vs::Text,size::Text,v::Text,next::Text]]
:
{#env}E-send[E_IntersectVariables, (#Name; #List1; #List2;), #Options, #sink]
→
%n⟪{⟦ Term «list»; VariableSet «vs» = makeVariableSet(«#sink»->context); int «size» = 0;
« {#env; "$tail":NO} T-set[#List1, #sink, list] »while (!strcmp("$Cons",SYMBOL(«list»))) {⟦ Variable «v» = VARIABLE(SUB(«list»,0)); 
addVariable(«vs», linkVariable(«#sink»->context, «v»));
Term «next» = LINK(«#sink»->context, SUB(«list»,1));
UNLINK(«#sink»->context, «list»);
«list» = «next»;⟧
}
UNLINK(«#sink»->context, «list»);
« {#env; "$tail":NO} T-set[#List2, #sink, list] »while (!strcmp("$Cons",SYMBOL(«list»))) {⟦ Variable «v» = VARIABLE(SUB(«list»,0)); 
if (containsVariable(«vs», «v»)) {⟦ START(«#sink», «EventConstructor["$Cons"]»); 
USE(«#sink», linkVariable(«#sink»->context, «v»)); 
++«size»;⟧
} 
Term «next» = LINK(«#sink»->context, SUB(«list»,1));
UNLINK(«#sink»->context, «list»);
«list» = «next»;⟧
}
UNLINK(«#sink»->context, «list»);
START(«#sink», «EventConstructor["$Nil"]»); END(«#sink», «EventConstructor["$Nil"]»);
while («size»-- > 0) END(«#sink», «EventConstructor["$Cons"]»);
freeVariableSet(«vs»);⟧
}«{#env}E-send-tail»⟫;

// $[ExceptVariables[sortname], vs1, vs2]

SEND_PRIMITIVE[E_ExceptVariables];

Send-ExceptVariables[Fresh[list1::Text,list2::Text,vs::Text,size::Text,v::Text,next::Text]]
:
{#env}
E-send[E_ExceptVariables, (#Name; #List1; #List2;), #Options, #sink]
→
%n⟪{⟦ Term «list1», «list2»; VariableSet «vs» = makeVariableSet(«#sink»->context); int «size» = 0;
« {#env; "$tail":NO} T-set[#List1, #sink, list1] »« {#env; "$tail":NO} T-set[#List2, #sink, list2] »while (!strcmp("$Cons",SYMBOL(«list2»))) {⟦ Variable «v» = VARIABLE(SUB(«list2»,0)); 
addVariable(«vs»,linkVariable(«#sink»->context, «v»));
Term «next» = LINK(«#sink»->context, SUB(«list2»,1));
UNLINK(«#sink»->context, «list2»);
«list2» = «next»;⟧
}
UNLINK(«#sink»->context, «list2»);
while (!strcmp("$Cons",SYMBOL(«list1»))) {⟦ Variable «v» = VARIABLE(SUB(«list1»,0)); 
if (!containsVariable(«vs»,«v»)) {⟦ addVariable(«vs», linkVariable(«#sink»->context, «v»)); 
START(«#sink», «EventConstructor["$Cons"]»); 
USE(«#sink», linkVariable(«#sink»->context, «v»)); 
++«size»;⟧
} 
Term «next» = LINK(«#sink»->context, SUB(«list1»,1));
UNLINK(«#sink»->context, «list1»);
«list1» = «next»;⟧
}
UNLINK(«#sink»->context, «list1»);
START(«#sink», «EventConstructor["$Nil"]»); END(«#sink», «EventConstructor["$Nil"]»);
while («size»-- > 0)  END(«#sink», «EventConstructor["$Cons"]»);
freeVariableSet(«vs»);⟧
}«{#env}E-send-tail»⟫;

// $[Split, string, sep-regex]
//
SEND_PRIMITIVE[E_Split];

Send-split[Fresh[str::Text, regex::Text]]
:
{#env}E-send[E_Split, (#Name; #String; #Regex;), #Options, #sink] 
→ 
%n⟪{⟦char* «str»;«{#env;"$tail":NO}T-set-string[#String, #sink, str]»
char* «regex»;
«{#env;"$tail":NO}T-set-string[#Regex, #sink, regex]»SEND_SPLIT(«str», «regex», «#sink»);⟧
}«{#env}E-send-tail»⟫;

// $[TryCall[$ResultSort, $Arg1Sort, ...], Name, ...]
//
SEND_PRIMITIVE[E_TryCall];

{#env} 
E-send[E_TryCall, (CONSTRUCTION[#kind, #Name, (ARGUMENT[#Sort1, CONSTRUCTION[#kind, #ReturnSortName, #Sort2]]; #ArgSorts)]; LITERAL[#FName, #Sort]; #Args), #Options, #sink]
→
{#env} 
E-send-tryCall[#ReturnSortName, E-call-sortnames[#ArgSorts], E-call-name[#FName], #Args, #Options, #sink]
;

)];

E1[(

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-tryCall[$String, $List[$String], $String, $List[Reified_Term], $List[$List[Reified_Option]], Text] :: Text;

{#env} 
E-send-tryCall[#ReturnSortName, #ArgTypes, #FName, #Args, #Options, #sink]
→
{#env} 
E-call-compute-typed-args[#ArgTypes, #Args, %n⟪⟫, %n⟪⟫, #sink, args.E-send-tryCall-body[E-call-isterm[#ReturnSortName], #ReturnSortName, #FName, args, #Options, #sink]]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-call-compute-typed-args[$List[$String], $List[Reified_Term], Text, Text, Text, args::Text.Text] :: Text;

{#env}
E-call-compute-typed-args[(), (), #cargs, #sep, #sink, args.#[args]]
→
{#env}
#[#cargs]
;

-[Data[#ArgType], Fresh[arg::Text]]
:
{#env}
E-call-compute-typed-args[(#ArgType;#ArgTypes), (#Arg;#Args), #cargs, #sep, #sink, args.#[args]]
→
%n⟪«E-call-cbinding[#ArgType]» «arg»;
« $[If, $[Equal, "$String", #ArgType], {#env; "$tail":NO}T-set-string[#Arg, #sink, arg],
  $[If, $[Equal, "$Boolean", #ArgType], {#env; "$tail":NO}T-set-bool[#Arg, #sink, arg],
  $[If, $[Equal, "$Numeric", #ArgType], {#env; "$tail":NO}T-set-num[#Arg, #sink, arg],
  {#env; "$tail":NO}T-set[#Arg, #sink, arg]]]] »
«{#env}E-call-compute-typed-args[#ArgTypes, #Args, %n⟪⟨#cargs⟩⟨#sep⟩⟨arg⟩⟫, %n⟪,⟫, #sink, args.#[args]]»
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-tryCall-body[$Boolean, $String, $String, Text, $List[$List[Reified_Option]], Text] :: Text;

-[Fresh[value::Text]]
:
{#env}
E-send-tryCall-body[$False, #ReturnSortName, #FName, #cargs, #Options, #sink]
→
%n⟪{⟦
CRSXTRY{⟦
«E-call-cbinding[#ReturnSortName]» «value» = «TOKEN[#FName]»(«#sink», «#cargs»);
START(«#sink», «MANGLE["$TrySuccess"]»);
«{#env}E-send-tryCall-result[#ReturnSortName, value, #sink]»
END(«#sink», «MANGLE["$TrySuccess"]»);⟧
} CRSXCATCH(exc) {⟦
START(«#sink», «MANGLE["$TryFailure"]»);
LITERAL(«#sink», CRSXEXCEPTION(exc));
END(«#sink», «MANGLE["$TryFailure"]»);⟧
}⟧
CRSXTRYEND
}«{#env}E-send-tail»⟫;

-[Fresh[value::Text, buf::Text]]
:
{#env}
E-send-tryCall-body[$True, #ReturnSortName, #FName, #cargs, #Options, #sink]
→
%n⟪{⟦
Sink «buf» = NULL;
CRSXTRY{⟦
«buf» = ALLOCA_BUFFER(«#sink»->context);
int success = «TOKEN[#FName]»(«buf», «#cargs»);
Term «value» = BUFFER_TERM(«buf»);
if (success) START(«#sink», «MANGLE["$TrySuccess"]»); else START(«#sink», «MANGLE["$TryFailure"]»); 
COPY(«#sink», «value»);⟧
if (success) END(«#sink», «MANGLE["$TrySuccess"]»);  else END(«#sink», «MANGLE["$TryFailure"]»); 
} CRSXCATCH(exc) {⟦
START(«#sink», «MANGLE["$TryFailure"]»);
LITERAL(«#sink», CRSXEXCEPTION(exc));
END(«#sink», «MANGLE["$TryFailure"]»);⟧
}
CRSXTRYEND
if («buf») FREE_BUFFER(«buf»);⟧
}«{#env}E-send-tail»⟫;

// Extract sort names
E-call-sortnames[$List[Reified_Binder]] :: $List[$String];

E-call-sortnames[()]
→
()
;

E-call-sortnames[(ARGUMENT[#Sort, CONSTRUCTION[#kind, #SortName, #Rest]]; #SortNames)]
→
(#SortName; E-call-sortnames[#SortNames])
;

// Convert sort name to C binding
E-call-cbinding[$String] :: Text;

E-call-cbinding[#Name]
→
$[If, $[Equal, #Name, "$String"],%n⟪char*⟫,
$[If, $[Equal, #Name, "$Boolean"],%n⟪int⟫,
$[If, $[Equal, #Name, "$Numeric"],%n⟪double⟫,
  %n⟪Term⟫
]]]
;


// Where the sortname binds to a Term
E-call-isterm[$String] :: $Boolean;

E-call-isterm[#Name]
→
$[If, $[Equal, #Name, "$String"], $False,
$[If, $[Equal, #Name, "$Boolean"],$False,
$[If, $[Equal, #Name, "$Numeric"],$False,
  $True
]]]
;


{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-tryCall-result[$String, Text, Text] :: Text;

{#E}E-send-tryCall-result[#ReturnSortName, #value, #sink]
→
$[If, $[Equal, "$String", #ReturnSortName], %n⟪LITERAL(«#sink», «#value»);⟫,
$[If, $[Equal, "$Boolean", #ReturnSortName], %n⟪if («#value») { START(«#sink», «MANGLE["$True"]»); END(«#sink», «MANGLE["$True"]»); } else  { START(«#sink», «MANGLE["$False"]»); END(«#sink», «MANGLE["$False"]»); }⟫,
$[If, $[Equal, "$Numeric", #ReturnSortName], %n⟪LITERALNF(«#sink», (size_t) 31, "%G", «#value»);⟫
]]]
;

)];

E2[(

///////////////////////////////////////////////////////////////////////////////////////////////////
// SET TERM-VALUED EVALUATORS

// Primitives for term functions defined using E-set-ref.
//
$Meta[(
  -[Meta,Lax]:
  SET_REF_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:, ##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #Options, #sink] → {#env}E-set-ref-to-send[##PRIMITIVE, #Args, #Options, #sink];
    $[:, ##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-ref-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-ref-to-bool[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-int"]: {#env} E-set-int[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-ref-to-int[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-ref-to-num[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-ref-to-string[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-local-string"]: {#env} E-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s, p]] → {#env}E-set-ref-to-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s, p]];
  );
)];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-ref-to-send[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text] :: Text;

-[Fresh[term::Text]]
:
{#env}
E-set-ref-to-send[#Primitive, #Args, #Options, #sink] 
→ 
%n⟪{⟦ Term «term»;
«{#env; "$tail":NO}E-set-ref[#Primitive, #Args, #Options, #sink, term]»COPY(«#sink», «term»);«{#env}E-send-tail»⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-ref-to-set[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[buf::Text]]
:
{#env}E-set-ref-to-set[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦ 
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);« {#env; "$tail":NO}E-set-ref-to-send[#Primitive, #Args, #Options, buf] »
«#variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»); ⟧
}«{#env}E-send-tail»⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-ref-to-bool[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[str::Text]]
:
{#env}E-set-ref-to-bool[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ char* «str»;
«{#env}E-set-ref-to-string[#Primitive, #Args, #Options, #sink, str]»«{#env}E-string-to-bool[#sink, str, #variable]» ⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-ref-to-int[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[str::Text]]
:
{#env}E-set-ref-to-int[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ char* «str»;
«{#env}E-set-ref-to-string[#Primitive, #Args, #Options, #sink, str]»«{#env}E-string-to-int[#sink, str, #variable]» ⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-ref-to-num[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[str::Text]]
:
{#env}E-set-ref-to-num[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ char* «str»;
«{#env}E-set-ref-to-string[#Primitive, #Args, #Options, #sink, str]»«{#env}E-string-to-num[#sink, str, #variable]» ⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-ref-to-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[term::Text]]
:
{#env}E-set-ref-to-string[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ Term «term»;
«{#env}E-set-ref[#Primitive, #Args, #Options, #sink, term]»«{#env}E-term-to-string[#sink, term, #variable]»«T-unlink-ref[#sink, term]»⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-ref-to-local-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, s::Text p::Text.Text] :: Text;

-[Fresh[term::Text]]
:
{#env}E-set-ref-to-local-string[#Primitive, #Args, #Options, #sink, s p.#[s,p]] 
→ 
%n⟪{⟦ Term «term»;
«{#env}E-set-ref[#Primitive, #Args, #Options, #sink, term]»«{#env}E-term-to-local-string[#sink, term, s p.#[s,p]]»«T-unlink-ref[#sink, term]»⟧}
⟫
;

// $[{#env}Get, name[, default]] return property or variable from the environment (either the properties in #env on Get or the global one).
//
SET_REF_PRIMITIVE[E_Get];

Set-Get-Literal[Fresh[pp::Text]]:
{#env}E-set-ref[E_Get, (PROPERTY-REF[#Ref, #Use, #Name]; LITERAL[#String, SORT[#Sort, ()]]; #Defaults), #Options, #sink, #property]
→
%n⟪{⟦ Term «pp» = «{#env}E-Get-NamedProperty[$[:,"MetaVar$",#Ref], #Use, #sink, #String]»
if («pp») «#property» = LINK(«#sink»->context, «pp»);
else {⟦«{#env}E-optional-nil[#Defaults, ok arg.T-then-set-ref[ok, arg, #sink, #property]]»⟧}«{#env}ST-UnlinkLastRefUse[#Ref, #Use, #sink]»⟧
}
⟫;

Set-Get-ConsData[Fresh[pp::Text]]:
{#env}E-set-ref[E_Get, (PROPERTY-REF[#Ref, #Use, #Name]; CONSTRUCTION[KDATA, #Symbol, ()]; #Defaults), #Options, #sink, #property]
→
%n⟪{⟦ Term «pp» = «{#env}E-Get-NamedProperty[$[:,"MetaVar$",#Ref], #Use, #sink, #Symbol]»
if («pp») «#property» = LINK(«#sink»->context, «pp»);
else {⟦«{#env}E-optional-nil[#Defaults, ok arg.T-then-set-ref[ok, arg, #sink, #property]]»⟧}«{#env}ST-UnlinkLastRefUse[#Ref, #Use, #sink]»⟧
}
⟫;

Set-Get[Fresh[key::Text,pp::Text]]:
{#env}E-set-ref[E_Get, (PROPERTY-REF[#Ref, #Use, #Name]; #Key; #Defaults), #Options, #sink, #property]
→
%n⟪{⟦ Term «key»;
«{#env}T-set-ref[#Key, #sink, key]»Term «pp» = «{#env}E-Get-Property[$[:,"MetaVar$",#Ref], #Use, #sink, key]»«T-unlink-ref[#sink, key]»
if («pp») «#property» = LINK(«#sink»->context, «pp»);
else {⟦«{#env}E-optional-nil[#Defaults, ok arg.T-then-set-ref[ok, arg, #sink, #property]]»⟧}«{#env}ST-UnlinkLastRefUse[#Ref, #Use, #sink]»⟧
}
⟫;

Set-Term-Get-Global[Fresh[value::Text]]:
{#env}E-set-ref[E_Get, ($[NotMatch,PROPERTY-REF[#_Ref, #_Use, #_Name],#Name]; #Key; #Defaults), #Options,  #sink, #property]
→
{#env} T-local-string[#Key, #sink, key p. %n⟪{⟦ char *«value» = getEnvValue(«#sink»->context, «key»);
«p»if («value») «#property» = makeStringLiteral(«#sink»->context, «value»);
else {⟦«{#env}E-optional-nil[#Defaults, ok arg.T-then-set-ref[ok, arg, #sink, #property]]»⟧}⟧
}
⟫]
;

// $[{#env}GetRef, name[, default]] return immutable property or variable from environment
//
// TODO: deprecate: use $[Get
SET_REF_PRIMITIVE[E_GetRef];

Set-GetRef[Fresh[key::Text, pp::Text]]:
{#env}E-set-ref[E_GetRef, (PROPERTY-REF[#Ref, #Use, #Name]; #Key; #Defaults), #Options, #sink, #property]
→
%n⟪{⟦ Term «key»;
«{#env}T-set-ref[#Key, #sink, key]»Term «pp» = «{#env}E-Get-Property[$[:,"MetaVar$",#Ref], #Use, #sink, key]»«{#env}T-unlink-ref[#sink, key]»
if («pp») «#property» = LINK(«#sink»->context, «pp»);
else {⟦«{#env}E-optional-nil[#Defaults, ok arg.T-then-set-ref[ok, arg, #sink, #property]]»⟧}⟧
}
⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-Get-Property[$String, Reified_Use, Text, Text] :: Text;

{#env; #RefCookie: PROPERTY_VARIABLE[#namedP, #varP]}
E-Get-Property[#RefCookie, #use, #sink, #key]
→
%n⟪DPROPERTY(«#sink»->context, «#namedP», «#varP», «#key»);⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-VariableProperties[$String] :: Text;

{#env; #RefCookie: PROPERTY_VARIABLE[#namedP, #varP]}
E-VariableProperties[#RefCookie]
→
%n⟪«#varP»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-Get-NamedProperty[$String, Reified_Use, Text, $String] :: Text;

{#env; #RefCookie: PROPERTY_VARIABLE[#namedP, #varP]}
E-Get-NamedProperty[#RefCookie, #use, #sink, #name]
→
%n⟪DNAMED_PROPERTY(«#sink»->context, «#namedP», «Literal[#name]»);⟫;


// $[Pick, #index, #list] with constant #index evaluates as the index'th member of list (starting from 0). 
//
SET_REF_PRIMITIVE[E_Pick];

Set-Pick[Fresh[index::Text,t::Text]]
:
{#env}E-set-ref[E_Pick, (#Name; #Index; #List;), #Options, #sink, #result]
→
%n⟪{
Term «t»;
long long «index»;
«{#env} T-set-int[#Index, #sink, index]»«{#env} T-set-ref[#List, #sink, t]»
while («index»--) «t» = SUB(«t»,1);
«#result» = LINK(«#sink»->context, SUB(«t»,0));
}⟫
;

// $[ReversePick, #index, #list] with constant #index evaluates as the index'th member of the reverse of list (starting from 0). 
//
SET_REF_PRIMITIVE[E_ReversePick];

Set-ReversePick[Fresh[index::Text,t::Text,p::Text,index::Text]]
:
{#env}E-set-ref[E_ReversePick, (#Name; #Index; #List;), #Options, #sink, #result]
→
%n⟪{
Term «t»,«p»;
long long «index»;
«{#env} T-set-int[#Index, #sink, index]»«{#env} T-set-ref[#List, #sink, t]»
for («p»=«t»; TAG(«p»)!=Data_M__sNil; «index»--) «p» = SUB(«p»,1);
while (++«index») «t» = SUB(«t»,1);
«#result» = LINK(«#sink»->context, SUB(«t»,0));
}⟫
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// BOOLEAN PRIMITIVES

// Helpers for boolean functions using E-set-bool.
//
$Meta[(
  -[Meta,Lax]:
  BOOL_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:, ##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #Options, #sink] → {#env}E-send-bool[##PRIMITIVE, #Args, #Options, #sink];
    $[:, ##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-bool-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-bool-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-int"]: {#env} E-set-int[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-bool-to-int[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-bool-to-num[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-bool-to-string[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-local-string"]: {#env} E-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s, p]] → {#env}E-set-bool-to-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s,p]];
  );
)];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-bool[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text] :: Text;

-[Fresh[bool::Text]]
:
{#env}E-send-bool[#Primitive, #Args, #Options, #sink] 
→ 
%n⟪{⟦ int «bool»;
«{#env;"$tail":NO}E-set-bool[#Primitive, #Args, #Options, #sink, bool]»if («bool») { START(«#sink», «MANGLE["$True"]»); END(«#sink», «MANGLE["$True"]»); }
else { START(«#sink», «MANGLE["$False"]»); END(«#sink», «MANGLE["$False"]»); } ⟧
}«{#env}E-send-tail»⟫;

// TODO: reference $True and $False...

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-bool-to-set[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[buf::Text]]
:
{#env}E-set-bool-to-set[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦ 
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);«{#env}E-send-bool[#Primitive, #Args, #Options, buf]»
«#variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»); ⟧
}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-bool-to-int[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[bool::Text]]
:
{#env}E-set-bool-to-int[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ int «bool»;
«{#env}E-set-bool[#Primitive, #Args, #Options, #sink, bool]»«{#env}E-bool-to-int[#sink, bool, #variable]» ⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-bool-to-num[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[bool::Text]]
:
{#env}E-set-bool-to-num[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ int «bool»;
«{#env}E-set-bool[#Primitive, #Args, #Options, #sink, bool]»«{#env}E-bool-to-num[#sink, bool, #variable]» ⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-bool-to-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[bool::Text]]
:
{#env}E-set-bool-to-string[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ int «bool»;
«{#env}E-set-bool[#Primitive, #Args, #Options, #sink, bool]»«{#env}E-bool-to-string[#sink, bool, #variable]» ⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-bool-to-local-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, s::Text p::Text.Text] :: Text;

-[Fresh[bool::Text, str::Text]]
:
{#env}E-set-bool-to-local-string[#Primitive, #Args, #Options, #sink, s p .#[s, p]] 
→ 
%n⟪{⟦ int «bool»; char *«str»;
«{#env}E-set-bool[#Primitive, #Args, #Options, #sink, bool]»«{#env}E-bool-to-string[#sink, bool, str]»« #[str, %n⟨⟩] »⟧}
⟫
;

// Generic infix comparison forms...
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-bool-op[Text, Reified_Term, Reified_Term, Text, Text] :: Text;

-[Fresh[n1::Text,n2::Text]]
:
{#env}E-set-bool-op[#Op, #Term1, #Term2, #sink, bool] 
→ 
%n⟪
{⟦
double «n1», «n2»;«{#env}T-set-num[#Term1, #sink, n1]»«{#env}T-set-num[#Term2, #sink, n2]»
«bool» = («n1» «#Op» «n2»);⟧
}⟫
;

// $[SameVariable, #1, #2] test equality of #1, #2, as variables, result is boolean.
//
BOOL_PRIMITIVE[E_SameVariable];

Set-Bool-SameVariable[Fresh[t1::Text,t2::Text]]:
{#env}E-set-bool[E_SameVariable, (#Name; #Term1; #Term2;), #Options, #sink, bool] → %n⟪{⟦ Term «t1», «t2»;
« {#env} T-set[#Term1, #sink, t1] »« {#env} T-set[#Term2, #sink, t2] »«bool» = (int) (VARIABLE(«t1») == VARIABLE(«t2»));
UNLINK(«#sink»->context, «t1»); UNLINK(«#sink»->context, «t2»); ⟧}
⟫;

// $[LesserVariable, #1, #2] test order of #1, #2, as pointers, result is boolean.
//
BOOL_PRIMITIVE[E_LesserVariable];

Set-Bool-LesserVariable[Fresh[t1::Text,t2::Text]]:
{#env}E-set-bool[E_LesserVariable, (#Name; #Term1; #Term2;), #Options, #sink, bool] → %n⟪{⟦ Term «t1», «t2»;
« {#env} T-set[#Term1, #sink, t1] »« {#env} T-set[#Term2, #sink, t2] »«bool» = (int) (VARIABLE(«t1») < VARIABLE(«t2»));
UNLINK(«#sink»->context, «t1»); UNLINK(«#sink»->context, «t2»); ⟧}
⟫;

// $[Equal, #1, #2] test equality of #1, #2, as strings, result is boolean.
//
BOOL_PRIMITIVE[E_Equal];

Set-Bool-Equal:
{#env} E-set-bool[E_Equal, (#Name; #Term1; #Term2;), #Options, #sink, bool]
→
{#env} T-local-string[#Term1, #sink, s1 p1.{#env} T-local-string[#Term2, #sink, s2 p2.%n⟪«bool» = (int) !strcmp(«s1»,«s2»);
«p1»«p2»⟫]]
;

// $[NotEqual, #1, #2] test inequality of #1, #2 as strings, result is boolean.
//
BOOL_PRIMITIVE[E_NotEqual];

Set-Bool-NotEqual-Term:
{#env} E-set-bool[E_NotEqual, (#Name; #Term1; #Term2;), #Options, #sink, bool]
→
{#env} T-local-string[#Term1, #sink, s1 p1.{#env} T-local-string[#Term2, #sink, s2 p2.%n⟪«bool» = (int) strcmp(«s1»,«s2»);
«p1»«p2»⟫]]
;

// $[NumericEqual, #1, #2] test equality of numbers #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_NumericEqual];

Set-Bool-NumericEqual[Fresh[n1::Text,n2::Text]]:
{#env}E-set-bool[E_NumericEqual, (#Name; #Term1; #Term2;), #Options, #sink, #bool]
→
%n⟪
{⟦
double «n1», «n2»;«{#env}T-set-num[#Term1, #sink, n1]»«{#env}T-set-num[#Term2, #sink, n2]»
«#bool» = (fabs(«n2» - «n1») < 1E-300);⟧
}⟫
;

// $[LessThan, #1, #2] for constant numbers #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_LessThan];

Set-Bool-LessThan:
{#env}E-set-bool[E_LessThan, (#Name; #Term1; #Term2;), #Options, #sink, #bool] → {#env}E-set-bool-op[%n⟪ < ⟫, #Term1, #Term2, #sink, #bool];

// $[GreaterThan, #1, #2] for constant numbers #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_GreaterThan];

Set-Bool-GreaterThan:
{#env}E-set-bool[E_GreaterThan, (#Name; #Term1; #Term2;), #Options, #sink, #bool] → {#env}E-set-bool-op[%n⟪ > ⟫, #Term1, #Term2, #sink, #bool];

// $[LessThanOrEqual, #1, #2] for constant numbers #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_LessThanOrEqual];

Set-Bool-LessThanOrEqual:
{#env}E-set-bool[E_LessThanOrEqual, (#Name; #Term1; #Term2;), #Options, #sink, #bool] → {#env}E-set-bool-op[%n⟪ <= ⟫, #Term1, #Term2, #sink, #bool];

// $[GreaterThanOrEqual, #1, #2] for constant numbers #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_GreaterThanOrEqual];

Set-Bool-GreaterThanOrEqual:
{#env}E-set-bool[E_GreaterThanOrEqual, (#Name; #Term1; #Term2;), #Options, #sink, #bool] → {#env}E-set-bool-op[%n⟪ >= ⟫, #Term1, #Term2, #sink, #bool];

// $[StringEqual, #1, #2] for constant strings #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_StringEqual];

Set-Bool-E_StringEqual
:
{#env}E-set-bool[E_StringEqual, (#Name; #String1; #String2;), #Options, #sink, bool]
→
{#env} T-local-string[#String1, #sink, s1 p1.{#env} T-local-string[#String2, #sink, s2 p2.%n⟪«bool» = (strcmp(«s1»,«s2») == 0);
«p1»«p2»⟫]]
;

// $[StringLessThan, #1, #2] for constant strings #1, #2, result is boolean.
//
BOOL_PRIMITIVE[E_StringLessThan];

Set-Bool-E_StringLessThan
:
{#env}E-set-bool[E_StringLessThan, (#Name; #String1; #String2;), #Options, #sink, bool]
→
{#env} T-local-string[#String1, #sink, s1 p1.{#env} T-local-string[#String2, #sink, s2 p2.%n⟪«bool» = (strcmp(«s1»,«s2») < 0);
«p1»«p2»⟫]]
;

// $[Contains, #1, #2] returns whether constant #1 contains the substring constant #2.
//
BOOL_PRIMITIVE[E_Contains];

Set-Bool-Contains
:
{#env}E-set-bool[E_Contains, (#Name; #String; #Substring;), #Options, #sink, bool]
→
{#env} T-local-string[#String, #sink, s1 p1.{#env} T-local-string[#Substring, #sink, s2 p2.%n⟪«bool» = (int) (strstr(«s1»,«s2») != NULL);
«p1»«p2»⟫]]
;

// $[StartsWith, STRING, SUBSTRING] returns whether STRING starts with SUBSTRING.
//
BOOL_PRIMITIVE[E_StartsWith];

Set-Bool-StartsWith:
{#env}E-set-bool[E_StartsWith, (#Name; #String; #Substring;), #Options, #sink, bool]
→
{#env} T-local-string[#String, #sink, s1 p1. {#env} T-local-string[#Substring, #sink, s2 p2. %n⟪«bool» = (int) !strncmp(«s1», «s2», strlen(«s2»));
«p1»«p2»⟫]]
;

// $[EndsWith, #1, #2] returns whether constant #1 ends with the substring constant #2.
//
BOOL_PRIMITIVE[E_EndsWith];

Set-Bool-EndsWith[Fresh[offset::Text]]:
{#env}E-set-bool[E_EndsWith, (#Name; #String; #Substring;), #Options, #sink, bool]
→
{#env} T-local-string[#String, #sink, s1 p1. {#env} T-local-string[#Substring, #sink, s2 p2. %n⟪{⟦
size_t «offset» = strlen(«s1»)-strlen(«s2»);
«bool» = (int) («offset»>=0 && !strcmp(«s1»+«offset»,«s2»));
«p1»«p2» }⟧
⟫]]
;

// $[BitSubSetEq, #i1, #i2] is $True or $Nil depending on whether all bits in #i1 are also in #i2. 
//
BOOL_PRIMITIVE[E_BitSubSetEq];

Set-Bool-BitSubSetEq[Fresh[i1::Text,i2::Text]]:
{#env}E-set-bool[E_BitSubSetEq, (#Name; #Left; #Right;), #Options, #sink, bool]
→
%n⟪{⟦ long long «i1», «i2»;
«{#env}T-set-int[#Left, #sink, i1]»«{#env}T-set-int[#Right, #sink, i2]»«bool» = !(«i1»&(~«i2»)); ⟧}
⟫;

// $[MatchRegex, #regex, #p], for constant #regex, is match pattern that only matches constants that fit the regular expression #regex and also match #p.
//   Can also be used as evaluator where it returns the boolean result of whether the match succeeds.

BOOL_PRIMITIVE[E_MatchRegex];

Set-Bool-MatchRegex:
{#env}E-set-bool[E_MatchRegex, (#Name; #Regex; #Str;), #Options, #sink, bool]
→
{#env} T-local-string[#Regex, #sink, s1 p1. {#env} T-local-string[#Str, #sink, s2 p2. %n⟪«bool» = MATCHREGEX((char *) «s1», «s2»);
«p1»«p2»⟫]]
;

// $[DeepEqual, #1, #2[, #3]] test equality of #1, #2, as terms, result is boolean. If #3 is $True, deep equal the environment too.
//
BOOL_PRIMITIVE[E_DeepEqual];

Set-Bool-DeepEqual[Fresh[term1::Text,term2::Text],Copy[#sink]]:
{#env} E-set-bool[E_DeepEqual, (#Name; #Term1; #Term2; #TestEnv), #Options, #sink, bool]
→
%n⟪{⟦ Term «term1», «term2»;
« {#env} T-set[#Term1, #sink, term1] »« {#env} T-set[#Term2, #sink, term2] »«E-set-deep-equal[#TestEnv, #sink, term1, term2, bool]»⟧
}⟫
;

// DeepEqual Helper
{$String:String}E-set-deep-equal[$List[Reified_Term], Text, Text, Text, Text] :: Text;

{#env}
E-set-deep-equal[(), #sink, #term1, #term2, #bool]
→
%n⟪«#bool» = deepEqual(«#sink»->context, «#term1», «#term2», 1);⟫
;

{#env}
E-set-deep-equal[(CONSTRUCTION[#kind, #Value, #Sort];), #sink, #term1, #term2, #bool]
→
%n⟪«#bool» = deepEqual(«#sink»->context, «#term1», «#term2», «$[If, $[Equal, #Value, "$False"], %n⟨0⟩,  %n⟨1⟩]»);⟫
;

-[Fresh[checkenv::Text], Fallback]
:
{#env}
E-set-deep-equal[(#BoolTerm;), #sink, #term1, #term2, #bool]
→
%n⟪int «checkenv»; «{#env} T-set-bool[#BoolTerm, #sink, checkenv]»«#bool» = deepEqual(«#sink»->context, «#term1», «#term2», «checkenv»);⟫
;

// $[Literal, #] check whether # is a literal
//
BOOL_PRIMITIVE[E_Literal];

Set-Bool-Literal[Fresh[term::Text]]:
{#env}E-set-bool[E_Literal, (#Name; #Term;), #Options, #sink, #bool]
→
%n⟪{ ⟦Term «term»; «{#env}T-set[#Term, #sink, term]»«#bool» = IS_LITERAL(«term»);⟧
}⟫
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// INTEGER PRIMITIVES

// Helpers for integer (long long) functions using E-set-int.
//
$Meta[(
  -[Meta,Lax]:
  INT_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:, ##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #Options, #sink] → {#env}E-send-int[##PRIMITIVE, #Args, #Options, #sink];
    $[:, ##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-int-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-int-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-int-to-bool[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-int-to-num[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-int-to-string[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-local-string"]: {#env} E-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s,p]] → {#env}E-set-int-to-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s,p]];
  );
)];

)];

E1[(

{$String:String}E-send-int[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text] :: Text;

-[Fresh[num::Text]]
:
{#env}E-send-int[#Primitive, #Args, #Options, #sink] 
→ 
%n⟪
{⟦ long long «num»;
«{#env; "$tail":NO}E-set-int[#Primitive, #Args, #Options, #sink, num]»LITERALNF(«#sink», (size_t) 31, "%lld", «num»); ⟧}«{#env}E-send-tail»⟫;

{$String:String}E-set-int-to-set[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[buf::Text]]
:
{#env}E-set-int-to-set[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);«{#env}E-send-int[#Primitive, #Args, #Options, buf]»
«#variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»);⟧
}⟫
;

{$String:String}E-set-int-to-bool[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[num::Text]]
:
{#env}E-set-int-to-bool[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ long long «num»;
«{#env}E-set-int[#Primitive, #Args, #Options, #sink, num]»«#variable» = («num» != 0ll); ⟧}
⟫
;

{$String:String}E-set-int-to-num[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[num::Text]]
:
{#env}E-set-int-to-num[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ long long «num»;
«{#env}E-set-int[#Primitive, #Args, #Options, #sink, num]»«#variable» = (double) «num»; ⟧}
⟫
;

{$String:String}E-set-int-to-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[num::Text]]
:
{#env}E-set-int-to-string[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪{⟦ long long «num»;
«{#env}E-set-int[#Primitive, #Args, #Options, #sink, num]»«#variable» = ALLOCATENF(«#sink»->context, (size_t) 31, "%lld", «num»); ⟧}
⟫
;

{$String:String}E-set-int-to-local-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, s::Text p::Text.Text] :: Text;

-[Fresh[num::Text,string::Text]]
:
{#env}E-set-int-to-local-string[#Primitive, #Args, #Options, #sink, s p .#[s, p]] 
→ 
%n⟪{⟦ long long «num»; char *«string»;
«{#env}E-set-int[#Primitive, #Args, #Options, #sink, num]»snprintf(«string» = (char *) ALLOCA(«#sink»->context, (size_t) 32), (size_t) 31, "%lld", «num»);
« #[string, %n⟨⟩] » }⟧
⟫
;

// Generic infix binary operator forms...]
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-int-op[Text, Reified_Term, Reified_Term, Text, Text] :: Text;

-[Fresh[i1::Text,i2::Text]]
:
{#env}E-set-int-op[#Op, #Left, #Right, #sink, #int] 
→ 
%n⟪{⟦ long long «i1», «i2»;
«{#env}T-set-int[#Left, #sink, i1]»«{#env}T-set-int[#Right, #sink, i2]»«#int» = «i1» «#Op» «i2»; ⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-num-op[Text, Reified_Term, Reified_Term, Text, Text] :: Text;

-[Fresh[n1::Text,n2::Text]]
:
{#env}E-set-num-op[#Op, #Left, #Right, #sink, #num] 
→ 
%n⟪
{⟦
double «n1», «n2»;«{#env}T-set-num[#Left, #sink, n1]»«{#env}T-set-num[#Right, #sink, n2]»
«#num» = «n1» «#Op» «n2»;⟧
}⟫
;

)];

E2[(

// $[Length, #1] returns the number of characters in constant #1.
//
INT_PRIMITIVE[E_Length];

Set-Int-Length:
{#env}E-set-int[E_Length, (#Name; #String;), #Options, #sink, #int]
→
{#env} T-local-string[#String, #sink, s p.%n⟪«#int» = strlen(«s»);
«p»⟫]
;

// $[Index, #1, #2] returns the index in constant #1 of the first occurrence of #2 in the constructor symbol. 
//
INT_PRIMITIVE[E_Index];

Set-Int-Index[Fresh[u::Text]]:
{#env}E-set-int[E_Index, (#Name; #String; #Pattern;), #Options, #sink, #int]
→
{#env} T-local-string[#String, #sink, s p1. {#env} T-local-string[#Pattern, #sink, t p2. 
%n⟪char* «u» = strstr(«s», «t»);
«#int» = «u» ? «u» - «s» : -1;
«p1»«p2»⟫]]
;


// $[Absolute,#n] corresponds to the unsigned integer with same magnitude as #n
//
INT_PRIMITIVE[E_Absolute];

Set-Int-Absolute:
{#env}E-set-int[E_Absolute, (#Name; #Number;), #Options, #sink, #int]
→
%n⟪« {#env} T-set-int[#Number, #sink, #int] »if («#int» < 0ll) «#int» = -«#int»;
⟫
;

// $[Hex,#hex] corresponds to the integer with hex digits #hex.
//
INT_PRIMITIVE[E_Hex];

Set-Int-Hex-Literal:
{#env}E-set-int[E_Hex, (#Name; LITERAL[#String, SORT[#Sort, ()]];), #Options, #sink, #int] → %n⟪«#int» = 0x«TOKEN[#String]»ll;
⟫;

Set-Int-Hex:
{#env}E-set-int[E_Hex, (#Name; $[NotMatch,LITERAL[#_String, #_Sort],#Hex];), #Options, #sink, #num]
→
{#env}T-local-string[#Hex, #sink, hex p. %n⟪if (sscanf(«hex», "%llX", &«#num») <= 0)⟦
ERRORF(«#sink»->context, Crsx, "Illegally formatted $[Hex,'%s']\n", «hex»);⟧
«p»⟫]
;

// $[BitAnd, #i1, #i2] is the integer with the bits common to #i1 and #i2.
//
INT_PRIMITIVE[E_BitAnd];

Set-Int-BitAnd:
{#env}E-set-int[E_BitAnd, (#Name; #Left; #Right;), #Options, #sink, #num] → {#env}E-set-int-op[%n⟪&⟫, #Left, #Right, #sink, #num];

// $[BitOr, #i1, #i2] is the integer with the bits in either #i1 and/or #i2.
//
INT_PRIMITIVE[E_BitOr];

Set-Int-BitOr:
{#env}E-set-int[E_BitOr, (#Name; #Left; #Right;), #Options, #sink, #num] → {#env}E-set-int-op[%n⟪|⟫, #Left, #Right, #sink, #num];

// $[BitXor, #i1, #i2] is the integer with the bits in precisely one of #i1 and #i2.
//
INT_PRIMITIVE[E_BitXOr];

Set-Int-BitXOr:
{#env}E-set-int[E_BitXOr, (#Name; #Left; #Right;), #Options, #sink, #num] → {#env}E-set-int-op[%n⟪^⟫, #Left, #Right, #sink, #num];

// $[BitNot, #i] is the integer with the opposite bits of #i.
//
INT_PRIMITIVE[E_BitNot];

Set-Int-BitNot[Fresh[i1::Text]]:
{#env}E-set-int[E_BitNot, (#Name; #Arg;), #Options, #sink, #num] → %n⟪{⟦ long long «i1»;
«{#env}T-set-int[#Arg, #sink, i1]»«#num» = ~«i1»; ⟧}
⟫;

// $[BitMinus, #i1, #i2] is the integer with the bits in #i1 which are not in #i2.
//
INT_PRIMITIVE[E_BitMinus];

Set-Int-BitMinus[Fresh[i1::Text,i2::Text]]:
{#env}E-set-int[E_BitMinus, (#Name; #Left; #Right;), #Options, #sink, #num] → %n⟪{⟦ long long «i1», «i2»;
«{#env}T-set-int[#Left, #sink, i1]»«{#env}T-set-int[#Right, #sink, i2]»«#num» = «i1» &(~«i2»); ⟧}
⟫;

// $[BitShiftLeft, #i1, #i2] is the integer with the bits in #i1 shifted left by #2
//
INT_PRIMITIVE[E_BitShiftLeft];

Set-Int-BitShiftLeft[Fresh[i1::Text,i2::Text]]:
{#env}E-set-int[E_BitShiftLeft, (#Name; #Left; #Right;), #Options, #sink, #num] → %n⟪{⟦ long long «i1», «i2»;
«{#env}T-set-int[#Left, #sink, i1]»«{#env}T-set-int[#Right, #sink, i2]»«#num» = «i1» << «i2»; ⟧}
⟫;

// $[BitShiftRight, #i1, #i2] is the integer with the bits in #i1 shifted Right by #2
//
INT_PRIMITIVE[E_BitShiftRight];

Set-Int-BitShiftRight[Fresh[i1::Text,i2::Text]]:
{#env}E-set-int[E_BitShiftRight, (#Name; #Left; #Right;), #Options, #sink, #num] → %n⟪{⟦ long long «i1», «i2»;
«{#env}T-set-int[#Left, #sink, i1]»«{#env}T-set-int[#Right, #sink, i2]»«#num» = «i1» >> «i2»; ⟧}
⟫;

// $[HashCode, #term[, #bool]] returns a hash code for #term. When #bool is true, returns hashcode for term and environment.
//
INT_PRIMITIVE[E_HashCode];

Set-Int-HashCode[Fresh[term::Text]]
:
{#env}E-set-int[E_HashCode, (#Name; #Term;), #Options, #sink, #int] 
→ 
%n⟪{⟦ Term «term»;
« {#env}T-set[#Term, #sink, term] »«#int» = HASH_CODE(«#sink»->context, «term»);
UNLINK(«#sink»->context, «term»); ⟧}
⟫
;

// $[ListLength, #list] returns length of list
//
INT_PRIMITIVE[E_ListLength];

Set-ListLength[Fresh[t::Text]]
:
{#env}E-set-int[E_ListLength, (#Name; #List;), #Options, #sink, #int]
→
%n⟪{ Term «t»; « {#env}T-set-ref[#List, #sink, t] »«#int»=0; while (TAG(«t»)!=Data_M__sNil) { «t» = SUB(«t»,1); «#int»++; }}
⟫
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// NUMERIC PRIMITIVES

// Helpers for numeric (double or long long) functions using E-set-num.

$Meta[(
  -[Meta,Lax]:
  NUM_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:, ##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #Options, #sink] → {#env}E-send-num[##PRIMITIVE, #Args, #Options, #sink];
    $[:, ##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-num-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-num-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-num-to-bool[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-num-to-string[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-local-string"]: {#env} E-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s,p]] → {#env}E-set-num-to-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s, p]];
  );
)];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-num[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text] :: Text;

-[Fresh[num::Text]]
:
{#env}
E-send-num[#Primitive, #Args, #Options, #sink] 
→ 
%n⟪
{⟦
double «num»;«{#env; "$tail":NO}E-set-num[#Primitive, #Args, #Options, #sink, num]»
LITERALNF(«#sink», (size_t) 31, "%G", «num»);«{#env}E-send-tail»⟧
}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-num-to-set[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[buf::Text]]
:
{#env}E-set-num-to-set[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦
Sink «buf» = ALLOCA_BUFFER(«#sink»->context);«{#env}E-send-num[#Primitive, #Args, #Options, buf]»
«#variable» = BUFFER_TERM(«buf»);
FREE_BUFFER(«buf»);⟧
}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-num-to-bool[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[num::Text]]
:
{#env}E-set-num-to-bool[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦
double «num»;«{#env}E-set-num[#Primitive, #Args, #Options, #sink, num]»
«#variable» = («num» != 0e0);⟧
}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-num-to-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[num::Text]]
:
{#env}E-set-num-to-string[#Primitive, #Args, #Options, #sink, #variable] 
→ 
%n⟪
{⟦
double «num»;«{#env}E-set-num[#Primitive, #Args, #Options, #sink, num]»
«#variable» = ALLOCATENF(«#sink»->context, (size_t) 31, "%G", «num»);⟧
}⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-num-to-local-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, s::Text p::Text.Text] :: Text;

-[Fresh[num::Text,str::Text]]
:
{#env}E-set-num-to-local-string[#Primitive, #Args, #Options, #sink, s p.#[s, p]] 
→ 
%n⟪
{⟦
double «num»; char *«str»;«{#env}E-set-num[#Primitive, #Args, #Options, #sink, num]»snprintf(«str» = (char *) ALLOCA(«#sink»->context, (size_t) 32), (size_t) 31, "%G", «num»);
« #[str, %n⟨⟩] »⟧
}⟫
;

// Helpers for n-ary operations.
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-num-fold-op[Text, $List[Reified_Term], Text, Text] :: Text;

{#env}E-set-num-fold-op[#Op, (), #sink, #num] → %n⟪⟫;

-[Fresh[tmp::Text]]
:
{#env}E-set-num-fold-op[#Op, (#Arg1;#Args), #sink, #num] 
→ 
%n⟪
{⟦
double «tmp»;«{#env}T-set-num[#Arg1, #sink, tmp]»«#num» «#Op» «tmp»;⟧
}«{#env}E-set-num-fold-op[#Op, #Args, #sink, #num]»⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-int-fold-op[Text, $List[Reified_Term], Text, Text] :: Text;

{#env}E-set-int-fold-op[#Op, (), #sink, #int] → %n⟪⟫;

-[Fresh[tmp::Text]]
:
{#env}E-set-int-fold-op[#Op, (#Arg1;#Args), #sink, #int] 
→ 
%n⟪{⟦ long long «tmp»;
«{#env}T-set-int[#Arg1, #sink, tmp]»«#int» «#Op» «tmp»; ⟧}
«{#env}E-set-int-fold-op[#Op, #Args, #sink, #int]»⟫
;

// $[Plus,#1,...]
//
NUM_PRIMITIVE[E_Plus];

{#env}E-set-num[E_Plus, (#Name; #Arg1; #Args), #Options, #sink, #num] → %n⟪«{#env}T-set-num[#Arg1, #sink, #num]»«{#env}E-set-num-fold-op[%n⟨+=⟩, #Args, #sink, #num]»⟫;
{#env}E-set-int[E_Plus, (#Name; #Arg1; #Args), #Options, #sink, #int] → %n⟪«{#env}T-set-int[#Arg1, #sink, #int]»«{#env}E-set-int-fold-op[%n⟨+=⟩, #Args, #sink, #int]»⟫;

// $[Times,#1,...]
//
NUM_PRIMITIVE[E_Times];

{#env}E-set-num[E_Times, (#Name; #Arg1; #Args), #Options, #sink, #num] → %n⟪«{#env}T-set-num[#Arg1, #sink, #num]»«{#env}E-set-num-fold-op[%n⟨*=⟩, #Args, #sink, #num]»⟫;
{#env}E-set-int[E_Times, (#Name; #Arg1; #Args), #Options, #sink, #int] → %n⟪«{#env}T-set-int[#Arg1, #sink, #int]»«{#env}E-set-int-fold-op[%n⟨*=⟩, #Args, #sink, #int]»⟫;

// $[Minus, #1, #2]
//
NUM_PRIMITIVE[E_Minus];

{#env}E-set-num[E_Minus, (#Name; #Left; #Right;), #Options, #sink, #num] → {#env}E-set-num-op[%n⟪-⟫, #Left, #Right, #sink, #num];
{#env}E-set-int[E_Minus, (#Name; #Left; #Right;), #Options, #sink, #num] → {#env}E-set-int-op[%n⟪-⟫, #Left, #Right, #sink, #num];

// $[Div, #1, #2]
//
NUM_PRIMITIVE[E_Div];

{#env}E-set-num[E_Div, (#Name; #Left; #Right;), #Options, #sink, #num] → {#env}E-set-num-op[%n⟪/⟫, #Left, #Right, #sink, #num];
{#env}E-set-int[E_Div, (#Name; #Left; #Right;), #Options, #sink, #int] → {#env}E-set-int-op[%n⟪/⟫, #Left, #Right, #sink, #int];

// $[Mod, #1, #2]
//
NUM_PRIMITIVE[E_Mod];

{#env}E-set-num[E_Mod, (#Name; #Left; #Right;), #Options, #sink, #num] → {#env}E-set-int-op[%n⟪%⟫, #Left, #Right, #sink, #num];
{#env}E-set-int[E_Mod, (#Name; #Left; #Right;), #Options, #sink, #int] → {#env}E-set-int-op[%n⟪%⟫, #Left, #Right, #sink, #int];

// $[Decimal,#dec] corresponds to the integer #dec...
//
NUM_PRIMITIVE[E_Decimal];

Set-Int-Decimal-Literal:
{#env}E-set-int[E_Decimal, (#Name; LITERAL[#String, SORT[#Sort, ()]];), #Options, #sink, #int] → %n⟪«#int» = «TOKEN[#String]»ll;
⟫;

Set-Int-Decimal:
{#env}E-set-int[E_Decimal, (#Name; $[NotMatch,LITERAL[#_String, #_Sort],#Decimal];), #Options, #sink, #num]
→ 
{#env}T-local-string[#Decimal, #sink, decimal p. %n⟪if (sscanf(«decimal», "%lld", &«#num») <= 0)⟦
ERRORF(«#sink»->context, Crsx, "Illegally formatted $[Decimal,'%s']\n", «decimal »);⟧«p»
⟫]
;

Set-Num-Decimal-Literal:
{#env}E-set-num[E_Decimal, (#Name; LITERAL[#String, SORT[#Sort, ()]];), #Options, #sink, #num] → %n⟪«#num» = «TOKEN[#String]»ll;
⟫;

Set-Num-Decimal:
{#env}E-set-num[E_Decimal, (#Name; $[NotMatch,LITERAL[#_String, #_Sort],#Decimal];), #Options, #sink, #num]
→ 
{#env}T-local-string[#Decimal, #sink, decimal p. %n⟪if (sscanf(«decimal», "%lg", &«#num») <= 0)⟦
ERRORF(«#sink»->context, Crsx, "Illegally formatted $[Decimal,'%s']\n", «decimal »);⟧«p»
⟫]
;

// $[ElapsedTime]
//
NUM_PRIMITIVE[E_ElapsedTime];

{#env}E-set-num[E_ElapsedTime, (#Name;), #Options, #sink, #num] → %n⟪«#num» = (double) elapsed(«#sink»->context);⟫;
{#env}E-set-int[E_ElapsedTime, (#Name;), #Options, #sink, #int] → %n⟪«#int» = (long long) elapsed(«#sink»->context);⟫;


///////////////////////////////////////////////////////////////////////////////////////////////////
// STRING EVALUATORS

// Primitives defined using E-set-string and/or -local.

$Meta[(
  -[Meta,Lax]:
  STRING_AND_LOCAL_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:, ##PRIMITIVE,"-send"]: {#env} E-send[##PRIMITIVE, #Args, #Options, #sink] → {#env}E-send-string[##PRIMITIVE, #Args, #Options, #sink];
    $[:, ##PRIMITIVE,"-set"]: {#env} E-set[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-string-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-ref"]: {#env} E-set-ref[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-string-to-set[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-bool"]: {#env} E-set-bool[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-string-to-bool[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-int"]: {#env} E-set-int[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-string-to-int[##PRIMITIVE, #Args, #Options, #sink, #variable];
    $[:, ##PRIMITIVE,"-set-num"]: {#env} E-set-num[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-set-string-to-num[##PRIMITIVE, #Args, #Options, #sink, #variable];
  );

  -[Meta,Lax]:
  STRING_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:, ##PRIMITIVE,"-local-string"]: {#env} E-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s,p]] → {#env}E-string-to-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s,p]];
    STRING_AND_LOCAL_PRIMITIVE[##PRIMITIVE]
  );

  -[Meta,Lax]:
  STRING_LOCAL_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[:, ##PRIMITIVE,"-set-string"]: {#env} E-set-string[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env}E-local-string-to-string[##PRIMITIVE, #Args, #Options, #sink, #variable];
    STRING_AND_LOCAL_PRIMITIVE[##PRIMITIVE]
  );
)];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text] :: Text;

-[Fresh[str::Text]]
:
{#env}E-send-string[#Primitive, #Args, #Options, #sink] 
→ 
%n⟪
{⟦ char *«str»;
« {#env; "$tail":NO}E-set-string[#Primitive, #Args, #Options, #sink, str] »LITERALU(«#sink», «str»); ⟧}«{#env}E-send-tail»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-string-to-set[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[str::Text]] :
{#env}E-set-string-to-set[#Primitive, #Args, #Options, #sink, #variable]
→
//{#env}E-local-string[#Primitive, #Args, #Options, #sink, str p. %n⟪«#variable» = makeStringLiteral(«#sink»->context, «str»);
//«p»⟫]
%n⟪{⟦ char *«str»;
«{#env}E-set-string[#Primitive, #Args, #Options, #sink, str] »«#variable» = makeStringLiteral(«#sink»->context, «str»); ⟧}
⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-string-to-bool[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

{#env}E-set-string-to-bool[#Primitive, #Args, #Options, #sink, #variable]
→
{#env}E-local-string[#Primitive, #Args, #Options, #sink, str p.%n⟪« E-string-to-bool[#sink, str, #variable] »«p»⟫]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-string-to-int[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

{#env}E-set-string-to-int[#Primitive, #Args, #Options, #sink, #variable]
→
{#env}E-local-string[#Primitive, #Args, #Options, #sink, str p.%n⟪« E-string-to-int[#sink, str, #variable] »«p»⟫]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-set-string-to-num[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

{#env}E-set-string-to-num[#Primitive, #Args, #Options, #sink, #variable]
→
{#env}E-local-string[#Primitive, #Args, #Options, #sink, str p.%n⟪« E-string-to-num[#sink, str, #variable] »«p»⟫]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-local-string-to-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, Text] :: Text;

-[Fresh[z::Text]]:
{#env}E-local-string-to-string[#Primitive, #Args, #Options, #sink, #str]
→
{#env}E-local-string[#Primitive, #Args, #Options, #sink, s p. %n⟪{⟦ size_t «z» = strlen(«s») + 1; memcpy(«#str» = (char *) ALLOCATE(«#sink»->context, «z»), «s», «z»); «p»⟧}
⟫]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-string-to-local-string[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, s::Text p::Text .Text] :: Text;

-[Fresh[str::Text]]
:
{#env}E-string-to-local-string[#Primitive, #Args, #Options, #sink, s p.#[s,p]]
→
%n⟪{⟦ char *«str»;
«{#env}E-set-string[#Primitive, #Args, #Options, #sink, str] »« #[str, %n⟨/*TODO:UNLINK(‹str›);*/⟩] »⟧
}
⟫;

// $[:, #1, #2, ...] corresponds to the literal string obtained from concatenating the argument strings.
//
STRING_AND_LOCAL_PRIMITIVE[E_Concat] ;

Set-String-Concat[Fresh[sub::Text, sublength::Text, length::Text]]
:
{#env}E-set-string[E_Concat, (#Name; #Terms), #Options, #sink, #str] 
→ 
%n⟪{⟦ char *«sub»[«INTEGER[Length[#Terms,0]]»]; size_t «sublength»[«INTEGER[Length[#Terms,0]]»]; size_t «length» = 0;
«{#env}E-concat[#Terms, length, sub, sublength, 0, #sink, "ALLOCATE", s p.%n⟨‹#str› = ‹s›; ⟩]»⟧ }
⟫
;

Set-String-Concat-Local[Fresh[sub::Text, sublength::Text, length::Text]]:
{#env}E-local-string[E_Concat, (#Name; #Terms), #Options, #sink, s p.#[s, p]]
→
%n⟪char *«sub»[«INTEGER[Length[#Terms,0]]»]; size_t «sublength»[«INTEGER[Length[#Terms,0]]»]; size_t «length» = 0;
«{#env}E-concat[#Terms, length, sub, sublength, 0, #sink, "ALLOCA", s p.#[s, p]]»⟫
;

)];

E1[(

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-concat[$List[Reified_Term], Text, Text, Text, $Numeric, Text, $String, s::Text p::Text.Text] :: Text;

// Helper to collect string fragments and concatenate.
{#env}E-concat[(#Term; #Terms), #length, #sub, #sublength, #Index, #sink, #alloc, s p.#[s, p]]
→
{#env} T-local-string[#Term, #sink, s p.%n⟪«#length» += («#sublength»[«INTEGER[#Index]»] = strlen(«#sub»[«INTEGER[#Index]»] = (char *) «s»));
«p»«{#env}E-concat[#Terms, #length, #sub, #sublength, $[Plus,#Index,1], #sink, #alloc, s2 p2.#[s2,p2]]»⟫]
;

-[Fresh[str::Text, p::Text]]:
{#env}E-concat[(), #length, #sub, #sublength, #Index, #sink, #alloc, s p.#[s, p]]
→ 
%n⟪{⟦ char *«str» = (char *) «TOKEN[#alloc]»(«#sink»->context, «#length»+1), *«p» = «str»;
int i; for (i = 0; i < «INTEGER[#Index]»; ++i) {⟦ memcpy(«p», «#sub»[i], «#sublength»[i]); «p» += «#sublength»[i];⟧ }
*«p» = '\0';
ASSERT(«#sink»->context, strlen(«str») == «#length»);
« #[str, %n⟨⟩] »}⟧
⟫;

)];

E2[(

// $[BeforeFirst, #string, #separator[, #fallback]] is the #string except all characters from the 
// first occurrence of #separator are omitted.
//
STRING_LOCAL_PRIMITIVE[E_BeforeFirst] ;

Set-String-BeforeFirst[Fresh[substring::Text, p::Text, z::Text]]
:
{#env}E-local-string[E_BeforeFirst, (#Name; #String; #Sep;), #Options, #sink, sub sp.#[sub,sp]]
→
{#env}T-local-string[#String, #sink, string p1. {#env}T-local-string[#Sep, #sink, sep p2. %n⟪{⟦char *«substring»;
if (!«sep»[0]) «substring» = (char *) "";
else {⟦char *«p» = strstr(«string», «sep»);
if (!«p»)  {⟦size_t «z» = strlen(«string»); memcpy(«substring» = (char *) ALLOCA(«#sink»->context, «z»+1), «string», «z»+1);⟧}
else if («p»==«string») «substring» = (char *) "";
else {⟦size_t «z» = (size_t)(«p» - «string»);
memcpy(«substring» = (char *) ALLOCA(«#sink»->context, «z»+1), «string», «z»);
«substring»[«z»] = '\0';}⟧}⟧
«p1»«p2»« #[substring,%n⟨⟩] »⟧}
⟫]]
;

// $[ToFirst, #string, #separator[, #fallback]] is the #string except all characters after the 
// first occurrence of #separator are omitted.
//
STRING_LOCAL_PRIMITIVE[E_ToFirst] ;

Set-String-ToFirst[Fresh[substring::Text, p::Text, z::Text]]
:
{#env}E-local-string[E_ToFirst, (#Name; #String; #Sep;), #Options, #sink, sub sp.#[sub,sp]]
→
{#env}T-local-string[#String, #sink, string p1. {#env}T-local-string[#Sep, #sink, sep p2. %n⟪{⟦char *«substring»;
if (!«sep»[0]) «substring» = (char *) "";
else {⟦char *«p» = strstr(«string», «sep»);
if (!«p») {⟦size_t «z» = strlen(«string»); memcpy(«substring» = (char *) ALLOCA(«#sink»->context, «z»+1), «string», «z»+1);⟧}
else {⟦size_t «z» = (size_t)(«p» - «string» + strlen(«sep»));
memcpy(«substring» = (char *) ALLOCA(«#sink»->context, «z»+1), «string», «z»);
«substring»[«z»] = '\0';}⟧}⟧
«p1»«p2»« #[substring,%n⟨⟩] »⟧}
⟫]]
;

// $[AfterFirst, #string, #separator[, #fallback]] is the #string except all characters up to the 
// first occurrence of #separator are omitted.
//
STRING_LOCAL_PRIMITIVE[E_AfterFirst] ;

Set-String-AfterFirst[Fresh[substring::Text, p::Text]]
:
{#env}E-local-string[E_AfterFirst, (#Name; #String; #Sep;), #Options, #sink, sub sp.#[sub, sp]]
→
{#env}T-local-string[#String, #sink, string p1. {#env}T-local-string[#Sep, #sink, sep p2. %n⟪{⟦char *«substring»;
char *«p» = strstr(«string», «sep»);
«substring» = («p» ? «p»+strlen(«sep») : (char *) "");
«p2»« #[substring, p1] »⟧}
⟫]]
;

// $[FromFirst, #string, #separator[, #fallback]] is the constructor named as #string except all characters before the 
// first occurrence of #separator are omitted.
//
STRING_LOCAL_PRIMITIVE[E_FromFirst] ;

Set-String-FromFirst[Fresh[p::Text]]:
{#env}E-local-string[E_FromFirst, (#Name; #String; #Sep;), #Options, #sink, sub sp.#[sub, sp]]
→
{#env}T-local-string[#String, #sink, string p1. {#env}T-local-string[#Sep, #sink, sep p2. %n⟪{⟦ char *«p» = strstr(«string», «sep»); if (!«p») «p» = (char *) "";
«p2»« #[p,p1] »⟧}
⟫]]
;

// $[Substring, #string, #first].
// $[Substring, #string, #first, #after-last].
//
STRING_AND_LOCAL_PRIMITIVE[E_Substring];

Set-String-Substring2-Local[Fresh[substring::Text, start::Text]]:
{#env}E-local-string[E_Substring, (#Name; #String; #start;), #Options, #sink, sub sp.#[sub, sp]]
→
{#env}T-local-string[#String, #sink, string p. %n⟪{⟦ char *«substring»; long long «start»;
« {#env} T-set-int[#start, #sink, start]
»if («start» >= (long long) strlen(«string»)) «substring» = (char *) "";
else «substring» = «string»+«start»;
« #[substring, p] »⟧}
⟫]
;

Set-String-Substring2[Fresh[start::Text, length::Text]]
:
{#env}E-set-string[E_Substring, (#Name; #String; #start;), #Options, #sink, #substring]
→
{#env}T-local-string[#String, #sink, string p. %n⟪{⟦ long long «start»;
« {#env} T-set-int[#start, #sink, start]
»long long «length» = (long long) strlen(«string»);
if («start» >= «length») «#substring» = (char *) "";
else memcpy(«#substring» = (char *) ALLOCATE(«#sink»->context, «length»-«start»+1), «string»+«start», «length»-«start»+1);
«p»}⟧
⟫];

Set-String-Substring3-Local[Fresh[substring::Text, start::Text, end::Text, length::Text]]
:
{#env}E-local-string[E_Substring, (#Name; #String; #start; #end;), #Options, #sink, sub sp.#[sub,sp]]
→
{#env}T-local-string[#String, #sink, string p. %n⟪{⟦ char *«substring»; long long «start», «end»;
« {#env} T-set-int[#start, #sink, start] »« {#env} T-set-int[#end, #sink, end]
»long long «length» = (long long) strlen(«string»);
if («start» >= «length» || «start» >= «end») «substring» = (char *) "";
else if («end» < «length») {
⟦memcpy(«substring» = (char *) ALLOCA(«#sink»->context, «end»-«start»+1), «string»+«start», «end»-«start»);
«substring»[«end»-«start»]='\0';⟧
} else «substring» = «string»+«start»;
« #[substring,p] » ⟧}
⟫]
;

Set-String-Substring3[Fresh[start::Text, end::Text]]
:
{#env}E-set-string[E_Substring, (#Name; #String; #start; #end;), #Options, #sink, #substring]
→
{#env}T-local-string[#String, #sink, string post. %n⟪{⟦ long long «start», «end»;
« {#env} T-set-int[#start, #sink, start] »« {#env} T-set-int[#end, #sink, end] »«#substring» = makeSubstring(«#sink»->context, «string», «start», «end»);
«post»⟧}
⟫]
;

// $[Mangle, #1] returns #1 as a constant suitable for use as the tail end of an identifier in (at least) Java and C.
//
STRING_LOCAL_PRIMITIVE[E_Mangle];

Set-String-Mangle[Fresh[str::Text]]
:
{#env}E-local-string[E_Mangle, (#Name; #String;), #Options, #sink, s p.#[s, p]] 
→ 
{#env}T-local-string[#String, #sink, s p.%n⟪{⟦ char *«str» = makeMangled(«#sink»->context, «s»);
« #[str,p] »⟧}
⟫]
;

// $[Escape, #1] returns #1 as a string (quoted with "s and replacing internal "s with \"). 
//
STRING_PRIMITIVE[E_Escape];

Set-String-Escape
:
{#env}E-set-string[E_Escape, (#Name; #String;), #Options, #sink, #str] 
→ 
{#env}T-local-string[#String, #sink, s p.%n⟪{⟦«#str» = makeEscaped(«#sink»->context, «s»);
«p»⟧}
⟫]
;

// $[EncodePoint, #int] returns a Unicode string corresponding to the single character with code point #int. */
//
STRING_LOCAL_PRIMITIVE[E_EncodePoint];

Set-String-EncodePoint[Fresh[code::Text, str::Text]]
:
{#env}E-local-string[E_EncodePoint, (#Name; #code;), #Options, #sink, s p.#[s, p]] 
→ 
%n⟪{⟦unsigned int «code»;
«{#env} T-set-int[#code, #sink, code]»char *«str» = makeEncodePoint(«#sink»->context, «code»);
« #[str, %n⟨⟩] »⟧}
⟫
;

// $[FormatNumber, #number ,#format] is a string representing the number (TODO: use #format).
//
// TODO: it's quite a hack for now...deprecate and use $[Format].
STRING_LOCAL_PRIMITIVE[E_FormatNumber];

Set-String-FormatNumber[Fresh[num::Text, str::Text]]
:
{#env}E-local-string[E_FormatNumber, (#Name; #Number; #Format), #Options, #sink, s p.#[s, p]] 
→
%n⟪
{⟦
double «num»; char *«str»;« {#env}T-set-num[#Number, #sink, num] »
snprintf(«str» = (char *) ALLOCA(«#sink»->context, (size_t) 32), (size_t) 31, "%G", «num»);
« #[str,%n⟨⟩] »⟧
}⟫;

// $[Format, #format[, #rest...]] printf-style formatting.
//
STRING_PRIMITIVE[E_Format];

Set-String-Format-None:
{#env}
E-set-string[E_Format, (#Name;#String;), #Options, #sink, #variable]
→
{#env}
T-set-string[#String, #sink, #variable]
;

Set-String-Format-Many:
{#env}
E-set-string[E_Format, (#Name; #Format; LITERAL[#Msg, #MsgSort]; #Args), #Options, #sink, #variable]
→
{#env} T-local-string[#Format, #sink, arg p.
 {#env} E-flatten-strings[(), #Args, #sink, %n⟪«#variable» = FORMAT(«#sink»->context, «FormatKindOf[#Name]», «arg», «TOKEN[#Msg]»⟫, %n⟪);
«p»⟫]]
;

// $[Show, #term] is a constant with the textual representation of #term as the string value. 
//
STRING_AND_LOCAL_PRIMITIVE[E_Show];

Set-String-Show
: // TODO: Implement proper semantic
{#env}E-set-string[E_Show, (#Name; #Term;), #Options, #sink, #str] 
→ 
%n⟪{⟦
«{#env}T-set-string[#Term, #sink, #str]»⟧}
⟫;

Set-String-Show-Local
: // TODO: Implement proper semantic
{#env}E-local-string[E_Show, (#Name; #Term;), #Options, #sink, s p.#[s,p]] 
→ 
%n⟪{⟦
«{#env}T-local-string[#Term, #sink, s p.#[s,p]]»⟧}
⟫;

// $[Symbol, #var] is the symbol (root constructor or variable name).
//
STRING_PRIMITIVE[E_Symbol];

Set-String-Symbol[Fresh[term::Text]]
:
{#env}E-set-string[E_Symbol, (#Name; #Term;), #Options, #sink, #str] 
→
%n⟪{⟦ Term «term»;
« {#env} T-set[#Term, #sink, term] »«#str» = SYMBOL(«term»);⟧}
⟫;

// TODO: should be polymorphic.

// $[Call[$ResultSort, $Arg1Sort, ...], Name, ...]
//
STRING_AND_LOCAL_PRIMITIVE[E_Call];

{#env} 
E-set-string[E_Call, (#Name; LITERAL[#fname, #Sort]; #Args), #Options, #sink, #str]
→
{#env}
E-call-compute-args[E-call-name[#fname], #Args, (), #sink, #str]
;

-[Fresh[str::Text]]
:
{#env}
E-local-string[E_Call, (#Name; LITERAL[#fname, #Sort]; #Args), #Options, #sink, s p.#[s,p]] 
→
%n⟪{⟦
char* «str»;«{#env}E-set-string[E_Call, (#Name; LITERAL[#fname, #Sort]; #Args), #Options, #sink, str]»
«{#env}#[str, %n⟨⟩]»⟧}
⟫;

)];

E1[(

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-call-compute-args[$String, $List[Reified_Term], $List[Text], Text, Text] :: Text;

{#env}
E-call-compute-args[#fname, (), #CArgs, #sink, #str]
→
%n⟪«#str» = «TOKEN[#fname]»(«#sink»«{#env}E-call-args[#CArgs]»);⟫
;

-[Fresh[arg::Text]]
:
{#env}
E-call-compute-args[#fname, (#Arg;#Args), #CArgs, #sink, #str]
→
%n⟪char* «arg»;«{#env}T-set-string[#Arg, #sink, arg]»«{#env}E-call-compute-args[#fname, #Args, (arg;#CArgs), #sink, #str]»⟫
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-call-args[$List[Text]] :: Text;

{#env}
E-call-args[()]
→
%n⟪⟫
;

{#env}
E-call-args[(#arg;#args)]
→
%n⟪«{#env}E-call-args[#args]», «#arg»⟫
;

E-call-name[$String] :: $String;

-[Data[#fname]]
:
E-call-name[#fname]
→
$[If, $[Contains, #fname, "."],
	E-call-name[$[AfterFirst, #fname, "."]],
	#fname
]
;

)];

E2[(

///////////////////////////////////////////////////////////////////////////////////////////////////
// POLYMORPHIC PRIMITIVES

// Primitives for term functions defined with generic E-poly helper:
// * E-poly[PRIMITIVE, ARGUMENT_TERMS, OPTIONS_TERMS; sink, ok result.#Tail[ok,result]]
//
$Meta[(
  -[Meta,Lax]:
  POLY_PRIMITIVE[##PRIMITIVE]
  →
  (
    $[C,$[:, ##PRIMITIVE,"-send"]] : {#env} E-send[##PRIMITIVE, #Args, #Options, #sink] → {#env} E-poly[##PRIMITIVE, #Args, #Options, #sink, ok result.T-then-send[ok,result,#sink]] ;
    $[C,$[:, ##PRIMITIVE,"-set"]] : {#env} E-set[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env} E-poly[##PRIMITIVE, #Args, #Options, #sink, ok result.T-then-set[ok,result,#sink,#variable]] ;
    $[C,$[:, ##PRIMITIVE,"-set-ref"]] : {#env} E-set-ref[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env} E-poly[##PRIMITIVE, #Args, #Options, #sink, ok result.T-then-set-ref[ok,result,#sink,#variable]] ;
    $[C,$[:, ##PRIMITIVE,"-set-bool"]] : {#env} E-set-bool[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env} E-poly[##PRIMITIVE, #Args, #Options, #sink, ok result.T-then-set-bool[ok,result,#sink,#variable]] ;
    $[C,$[:, ##PRIMITIVE,"-set-int"]] : {#env} E-set-int[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env} E-poly[##PRIMITIVE, #Args, #Options, #sink, ok result.T-then-set-int[ok,result,#sink,#variable]] ;
    $[C,$[:, ##PRIMITIVE,"-set-num"]] : {#env} E-set-num[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env} E-poly[##PRIMITIVE, #Args, #Options, #sink, ok result.T-then-set-num[ok,result,#sink,#variable]] ;
    $[C,$[:, ##PRIMITIVE,"-set-string"]] : {#env} E-set-string[##PRIMITIVE, #Args, #Options, #sink, #variable] → {#env} E-poly[##PRIMITIVE, #Args, #Options, #sink, ok result.T-then-set-string[ok,result,#sink,#variable]] ;
    $[C,$[:, ##PRIMITIVE,"-local-string"]] : {#env} E-local-string[##PRIMITIVE, #Args, #Options, #sink, s p.#[s, p]] → {#env} E-poly[##PRIMITIVE, #Args, #Options, #sink, ok result.T-then-local-string[ok,result,#sink,s p.#[s,p]]] ;
  );
)];


POLY_PRIMITIVE[E_Cast];
POLY_PRIMITIVE[E_SaveTerm];
POLY_PRIMITIVE[E_Dump];
POLY_PRIMITIVE[E_Error];
POLY_PRIMITIVE[E_ForgivableError];
POLY_PRIMITIVE[E_EventualError];
POLY_PRIMITIVE[E_Trace];
POLY_PRIMITIVE[E_If];
POLY_PRIMITIVE[E_IfZero];
POLY_PRIMITIVE[E_IfEmpty];
POLY_PRIMITIVE[E_IfDef];
POLY_PRIMITIVE[E_VariableNameIs];
POLY_PRIMITIVE[E_Echo];
POLY_PRIMITIVE[E_ProfileEnter];
POLY_PRIMITIVE[E_ProfileExit];
POLY_PRIMITIVE[E_Let];
POLY_PRIMITIVE[E_For];

)];

E1[(

{$String}E-poly[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

// $[Cast[sort], #term] is just #term.
//

Poly-Cast
:
{#env}E-poly[E_Cast, (#Name; #Term;), #Options, #sink, ok result.#Tail[ok,result]]
→
{#env}#Tail[OK, #Term]
;

// $[SaveTerm, #url, #term, #result] saves #term onto #url (for $[LoadTerm,#url] later) and the returns #result.
//

Poly-SaveTerm[Fresh[term::Text]]
:
{#env}E-poly[E_SaveTerm, (#Name; #Url; #Term; #Result), (#O1;#O2;#O3;#O4), #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO} T-local-string[#Url, #sink, url p.%n⟪{⟦ Term «term»;
«{#env; "$tail":NO} T-set[#Term, #sink, term]»SAVE_TERM(«#sink»->context, «url», «term»); UNLINK(«#sink»->context, «term»);«p» ⟧}
«{#env} E-optional[#Result, #O4, #sink, ok r.#Tail[ok,r]]»⟫]
;

// $[Dump, #prefix, #term] prints #prefix and #term and acts like #term. 
//

Poly-Dump[Fresh[str::Text]] 
:
{#env}E-poly[E_Dump, (#Name; #Prefix; #Term;), #Options, #sink, ok result.#Tail[ok,result]]
→
%n⟪
char* «str»;«{#env; "$tail":NO}T-set-string[#Prefix, #sink, str]»
ERRORF(«#sink»->context, «FormatKindOf[#Name]», "%s\n", «str»);
«{#env}#Tail[OK, #Term]»⟫;

// $[ProfileEnter, #id, #name, #cont]  

Poly-ProfileEnter
:
{#env}E-poly[E_ProfileEnter, (#Name; META-APPLICATION[#MetaVar, #Args, #Use]; #name; #cont;), #Options, #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO}T-local-string[#name, #sink, s p.%n⟪
PROFILE_ENTER(«#sink»->context, VARIABLE(«{#env}MetaVar[#MetaVar]»), «s»);«p»
«{#env}#Tail[OK, #cont]»
⟫]
;

// $[ProfileExit, #id, #cont]  

Poly-ProfileExit 
:
{#env}E-poly[E_ProfileExit, (#Name; META-APPLICATION[#MetaVar, #Args, #Use]; #cont;), #Options, #sink, ok result.#Tail[ok,result]]
→
%n⟪PROFILE_EXIT(«#sink»->context, VARIABLE(«{#env}MetaVar[#MetaVar]»));
«{#env}#Tail[OK, #cont]»
⟫
;

// $[Error[#kind], #format[, #arg,...]] emits an exception.
//

Poly-Error-None:
{#env} E-poly[E_Error, (#Name; #String;), #Options, #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO} T-local-string[#String, #sink, arg p. %n⟪ERRORF(«#sink»->context, «FormatKindOf[#Name]», "%s\n", «arg»);
«p»« {#env} E-optional[(), (), #sink, ok r.#Tail[ok,r]] »⟫]
;

Poly-Error-Kind:
{#env} E-poly[E_Error, (#Name; #Format; LITERAL[#Msg, #MsgSort]; #Args), #Options, #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO} T-local-string[#Format, #sink, format p.
 {#env; "$tail":NO} E-flatten-strings[(), #Args, #sink, %n⟪ERRORF(«#sink»->context, «FormatKindOf[#Name]», «format», «TOKEN[#Msg]»⟫, %n⟪);
«p»« {#env} E-optional[(), (), #sink, ok r.#Tail[ok,r]] »⟫]]
;

Poly-Error-Other:
{#env} E-poly[E_Error, (#Name; #Format; $[NotMatch,LITERAL[#Msg, #MsgSort],#Arg1]; #Args), #Options, #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO} T-local-string[#Format, #sink, format p.
 {#env; "$tail":NO} E-flatten-strings[(), (#Arg1; #Args), #sink, %n⟪ERRORF(«#sink»->context, «FormatKindOf[#Name]», «format»⟫, %n⟪);
«p»« {#env} E-optional[(), (), #sink, ok r.#Tail[ok,r]] »⟫]]
;

FormatKindOf[Reified_Term] :: Text;

FormatKindOf[CONSTRUCTION[#kind, #Name, (ARGUMENT[#Sort1, LITERAL[#Kind, #KindSort]]; )]] → TOKEN[#Kind] ;
FormatKindOf[CONSTRUCTION[#kind, #Name, (ARGUMENT[#Sort1, CONSTRUCTION[#kind, #Kind, ()]]; )]] → TOKEN[#Kind] ;
FormatKindOf[CONSTRUCTION[#kind, #Name, ()]] → TOKEN["Default"] ;
FormatKindOf[LITERAL[#Name, #Sort]] → TOKEN["Default"] ;

// $[ForgivableError[#kind], #format[, #arg,..., #result]] emits an exception or a warning
//

Poly-ForgivableError-Kind
:
{#env}
E-poly[E_ForgivableError, (#Name; #Format; LITERAL[#Msg, #MsgSort]; #Args), #Options, #sink, ok result.#Tail[ok,result]]
→
{#env}
E-ForgivableError[#Name, #Format, #Msg, E-SplitLast[#Args], #sink, ok result.#Tail[ok,result]]
;

Poly-ForgivableError-None[Fallback]
:
{#env}
E-poly[E_ForgivableError, (#Name; #String; #Result; ), #Options, #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO}
T-local-string[#String, #sink, arg p. %n⟪FORGIVABLEERRORF(«#sink»->context, «FormatKindOf[#Name]», «arg»);
«p»«{#env}#Tail[OK,#Result] »⟫]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-ForgivableError[Reified_Term, Reified_Term, $String, $List[Reified_Term], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}
E-ForgivableError[#Name, #Format, #Msg, (#Result; #Args), #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO}
T-local-string[#Format, #sink, arg p.
 {#env; "$tail":NO} E-flatten-strings[(), #Args, #sink, %n⟪FORGIVABLEERRORF(«#sink»->context, «FormatKindOf[#Name]», «arg», «TOKEN[#Msg]»⟫, %n⟪);
«p»«{#env}#Tail[OK, #Result] »⟫]];

// $[EventualError[#kind], #format[, #arg,..., #result]] accumulates errors and eventually emits an exception. 
//

{#env}E-poly[E_EventualError, (#Name; #Format; LITERAL[#Msg, #MsgSort]; #Args), #Options, #sink, ok result.#Tail[ok,result]]
→ {#env}E-EventualError[#Name, #Format, #Msg, E-SplitLast[#Args], #sink, ok result.#Tail[ok,result]];

-[Fallback]:
{#env}E-poly[E_EventualError, (#Name; #String; #Result; ), #Options, #sink, ok result.#Tail[ok,result]]
→ {#env; "$tail":NO}T-local-string[#String, #sink, arg p. 
                    %n⟪
EVENTUALERRORF(«#sink»->context, «FormatKindOf[#Name]», «arg»);«p»«{#env}#Tail[OK,#Result] »⟫];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-EventualError[Reified_Term, Reified_Term, $String, $List[Reified_Term], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}
E-EventualError[#Name, #Format, #Msg, (#Result; #Args), #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO}
T-local-string[#Format, #sink, arg p.
 {#env; "$tail":NO} E-flatten-strings[(), #Args, #sink, %n⟪
EVENTUALERRORF(«#sink»->context, «FormatKindOf[#Name]», «arg», «TOKEN[#Msg]»⟫, %n⟪);«p»«{#env}#Tail[OK, #Result] »⟫]];

// Helper moving the last element in the list to the first position
E-SplitLast[$List[Reified_Term]] :: $List[Reified_Term];

E-SplitLast[#Args] 
→
(E-Last[#Args]; E-Head[#Args])
;

E-Last[$List[Reified_Term]] :: Reified_Term;

E-Last[(#A;)]      → #A;
E-Last[(#A;#B;#C)] → E-Last[(#B;#C)];

E-Head[$List[Reified_Term]] :: $List[Reified_Term];

E-Head[(#A;)]      → ();
E-Head[(#A;#B;#C)] → (#A; E-Head[(#B;#C)]);

// $[Trace[#kind], #message, #result] prints the message
// $[Trace[#kind], #result] just returns the result
//

Poly-Trace-Message:
{#env} E-poly[E_Trace, (#Name; #String; #Result;), #Options, #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO} T-local-string[#String, #sink, arg p. %n⟪TRACEF(«#sink»->context, «FormatKindOf[#Name]», "%s\n", «arg»);
«p»«{#env}#Tail[OK,#Result] »⟫]
;

Poly-Trace-None:
{#env} E-poly[E_Trace, (#Name; #Result;), #Options, #sink, ok result.#Tail[ok,result]]
→
{#env}#Tail[OK,#Result]
;

// $[Let, #metavar, #value, #return]
Poly-Let[Fresh[value::Text]]:
{#env} E-poly[E_Let, (#name; #vars; #value; #result;), #options, #sink, ok result.#tail[ok,result]]
→ %n⟪
Term «value»;« {#env; "$tail": NO} T-set[#value, #sink, value] »
«value» = NORMALIZEP(«#sink»->context, «value»);« {#env}E-poly-let[#vars, value, #result, #sink, ok result.#tail[ok,result]] »⟫;

// $[For, #metavar, #list, #params, #initvalues, #body, #return]
Poly-For:
{#env} E-poly[E_For, (#name; #vars; #list; #params; #init; #body; #result;), #options, #sink, ok result.#tail[ok,result]]
→ {#env}E-poly-for[#vars, #list, #params, #init, #body, #result, #options, #sink, ok result.#tail[ok,result]];

)];

E2[(

// $[{#loc}E_PassLocationProperties, #result] just returns the result
//
SET_REF_PRIMITIVE[E_PassLocationProperties];

Set-PassLocationProperties[Fresh[extra::Text]]:
{#env}
E-set-ref[E_PassLocationProperties, (#Name; #Result;), #Options, #sink, result]
→
%n⟪
{ /* PassLocationProperties */⟦ 
Term «extra»;« {#env} T-set[#Name, #sink, extra] »« {#env} T-set[#Result, #sink, result] »
passLocationProperties(«#sink»->context, «extra», «result»);⟧
}⟫;

)];

E1[(

// Rules to flatten reified list to non-reified list.
//
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-flatten-strings[$List[Reified_Term], $List[Reified_Term], Text, Text, Text] :: Text;

// No work item, no list: done.
{#env} E-flatten-strings[(), (), #sink, #pre, #post]
→
%n⟪{⟦«#pre»«#post»⟧}⟫
;

// No work item, one more list item: work with it.
{#env}E-flatten-strings[(), (#Arg; #Args), #sink, #pre, #post]
 →
{#env}E-flatten-string[#Arg, #Args, #sink, #pre, #post]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-flatten-string[Reified_Term, $List[Reified_Term], Text, Text, Text] :: Text;

{#env} E-flatten-string[CONSTRUCTION[#kind, #Symbol, #Binders], #Args, #sink, #pre, #post]
→
$[If, $[Equal, #Symbol, "$Nil"],
      {#env} E-flatten-string-nil[#Args, #sink, #pre, #post],
      $[If, $[Equal, #Symbol, "$Cons"],
            {#env} E-flatten-string-cons[#Binders, #Args, #sink, #pre, #post],
            {#env} E-flatten-string-nl[CONSTRUCTION[#kind, #Symbol, #Binders], #Args, #sink, #pre, #post]
]]
;    

// Work item is non-list (we hope string): Emit and recurse.
-[Fallback]
:
{#env} E-flatten-string[#Arg, #Args, sink, #pre, #post]
→
{#env} T-local-string[#Arg, sink, arg p. {#env} E-flatten-strings[(), #Args, sink, %n⟨‹#pre›, ‹arg›⟩, %n⟨‹#post›‹p›⟩]]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-flatten-string-nil[$List[Reified_Term], Text, Text, Text] :: Text;

// Work item is empty list: remove.
{#env} E-flatten-string-nil[#Args, #sink, #pre, #post]
→
{#env} E-flatten-strings[(), #Args, #sink, #pre, #post]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-flatten-string-cons[$List[Reified_Binder], $List[Reified_Term], Text, Text, Text] :: Text;

// Work item is list: split and delay tail part and proceed.
{#env} E-flatten-string-cons[(ARGUMENT[#S1,#Arg1];ARGUMENT[#S2,#Args1];), #Args2, #sink, #pre, #post]
→
{#env} E-flatten-string[#Arg1, (#Args1;#Args2), #sink, #pre, #post]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-flatten-string-nl[Reified_Term, $List[Reified_Term], Text, Text, Text] :: Text;

// Work item is non-list (we hope string): Emit and recurse.
{#env} E-flatten-string-nl[#Arg, #Args, #sink, #pre, #post]
→
{#env} T-local-string[#Arg, #sink, arg p. {#env} E-flatten-strings[(), #Args, #sink, %n⟨‹#pre›, ‹arg›⟩, %n⟨‹#post›‹p›⟩]]
;

// $[If, #test, #true[, #false]] with constant #test evaluates as either #true or #false depending on test.
//

Poly-If[Fresh[test::Text]]
:
{#env}E-poly[E_If, (#Name; #Test; #Yes; #Nos), (#O1; #O2; #O3; #O4), #sink, ok result.#Tail[ok,result]] 
→ 
%n⟪
{⟦
int «test»;«{#env; "$tail":NO}T-set-bool[#Test, #sink, test]»
if («test») 
{⟦«{#env}E-OptionsUnlink[#sink, #O3] »«{#env}#Tail[OK,#Yes] »⟧
}
else
{⟦«{#env}E-optional[#Nos, #O4, #sink, ok no.#Tail[ok,no]]» ⟧}⟧
}⟫;

// $[IfZero, #int, #true[, #false]] with constant integer #int evaluates as either #true or #false depending on whether #i is zero.
//

Poly-IfZero[Fresh[intt::Text]]
:
{#env}E-poly[E_IfZero, (#Name; #Int; #Yes; #Nos), (#O1; #O2; #O3; #O4), #sink, ok result.#Tail[ok,result]] 
→ 
%n⟪{⟦ long long «intt»;
«{#env;"$tail":NO}T-set-int[#Int, #sink, intt]»if («intt» == 0ll) { ⟦«{#env}E-OptionsUnlink[#sink, #O3] »«{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, #O4, #sink, ok no.#Tail[ok,no]]» ⟧}⟧
}⟫;

// $[IfEmpty, #str, #true[, #false]] with constant string #str evaluates as either #true or #false depending on whether it is the empty string.
//

Poly-IfEmpty
:
{#env}E-poly[E_IfEmpty, (#Name; #Str; #Yes; #Nos), (#O1; #O2; #O3; #O4), #sink, ok result.#Tail[ok,result]] 
→ 
{#env; "$tail":NO}T-local-string[#Str, #sink, str p.%n⟪
if (!«str»[0]) { ⟦«p»«{#env}E-OptionsUnlink[#sink, #O3] »«{#env}#Tail[OK,#Yes] »⟧}
else {⟦ «p»«{#env}E-optional[#Nos, #O4, #sink, ok no.#Tail[ok,no]]» ⟧}
⟫];

// $[{#environment}IfDef, #name, #true[, #false]] with constant #name evaluates as either #true or #false depending on whether name is defined in #environment,
// If {#environment} is omitted completely, the system environment is searched.
//

Poly-IfDef-Literal[Fresh[value::Text]]
:
{#env}E-poly[E_IfDef, (PROPERTY-REF[#Ref, #Use, #Name];  LITERAL[#String, SORT[#Sort, ()]]; #Yes; #Nos), (#O1; #O2; #O3; #O4), #sink, ok result.#Tail[ok,result]] 
→ 
%n⟪
{⟦ Term «value» = «{#env}E-Get-NamedProperty[$[:,"MetaVar$",#Ref], #Use, #sink, #String]»«{#env}ST-UnlinkLastRefUse[#Ref, #Use, #sink]»
if («value») {⟦ «{#env}E-OptionsUnlink[#sink, #O3] »«{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, #O4, #sink, ok no.#Tail[ok,no]]» ⟧}⟧
}⟫;


Poly-IfDef-ConsData[Fresh[value::Text]]
:
{#env}E-poly[E_IfDef, (PROPERTY-REF[#Ref, #Use, #Name];  CONSTRUCTION[KDATA, #Symbol, ()]; #Yes; #Nos), (#O1; #O2; #O3; #O4), #sink, ok result.#Tail[ok,result]] 
→ 
%n⟪
{⟦ Term «value» = «{#env}E-Get-NamedProperty[$[:,"MetaVar$",#Ref], #Use, #sink, #Symbol]»«{#env}ST-UnlinkLastRefUse[#Ref, #Use, #sink]»
if («value») {⟦ «{#env}E-OptionsUnlink[#sink, #O3] »«{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, #O4, #sink, ok no.#Tail[ok,no]]» ⟧}⟧
}⟫;


Poly-IfDef[Fresh[key::Text, value::Text]]
:
{#env}E-poly[E_IfDef, (PROPERTY-REF[#Ref, #Use, #Name]; #Key; #Yes; #Nos), (#O1; #O2; #O3; #O4), #sink, ok result.#Tail[ok,result]] 
→ 
%n⟪
{⟦ Term «key»;
«{#env; "$tail":NO}T-set[#Key, #sink, key]»Term «value» = «{#env}E-Get-Property[$[:,"MetaVar$",#Ref], #Use, #sink, key]»«{#env}ST-UnlinkLastRefUse[#Ref, #Use, #sink]»
if («value») {⟦ «{#env}E-OptionsUnlink[#sink, #O3] »«{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, #O4, #sink, ok no.#Tail[ok,no]]» ⟧}⟧
}⟫;

Poly-IfDef-Global[Fresh[value::Text]]
:
{#env}E-poly[E_IfDef, ($[NotMatch,PROPERTY-REF[#_Ref, #_Use, #_Name],#Name]; #Key; #Yes; #Nos), (#O1; #O2; #O3; #O4), #sink, ok result.#Tail[ok,result]]
→
{#env; "$tail":NO} T-local-string[#Key, #sink, key p.%n⟪{⟦ char *«value» = getenv(«key»);
«p»if («value») {⟦ «{#env}E-OptionsUnlink[#sink, #O3] »«{#env}#Tail[OK,#Yes] » ⟧}
else {⟦ «{#env}E-optional[#Nos, #O4, #sink, ok no.#Tail[ok,no]]» ⟧}⟧
}⟫];
// $[VariableNameIs, #var, #name, #result] updates the variable name of #var to #name, then returns #result.
//

Poly-VariableNameIs[Fresh[name::Text]]
:
{#env}E-poly[E_VariableNameIs, (#Name; VARIABLE-USE[var]; #name; #Result;), #Options, #sink, ok result.#Tail[ok,result]]
→
%n⟪{⟦ char *«name»; « {#env; "$tail":NO} T-set-string[#name, #sink, name] »setVariableBaseName(«#sink»->context, «var», «name»);⟧ }
« {#env}#Tail[OK,#Result] »⟫
;

Poly-VariableNameIsComputed[Fresh[term::Text, name::Text]]
:
{#env}E-poly[E_VariableNameIs, (#Name; $[NotMatch,VARIABLE-USE[#var],#varterm]; #name; #Result;), #Options, #sink, ok result.#Tail[ok,result]]
→
%n⟪{⟦ Term «term»; « {#env;; "$tail":NO}T-set[#varterm, #sink, term] »
if (IS_VARIABLE_USE(«term»)) {⟦ char *«name»;
« {#env; "$tail":NO} T-set-string[#name, #sink, name] »setVariableBaseName(«#sink»->context, VARIABLE(«term»), «name»);⟧
} ⟧ }
« {#env}#Tail[OK,#Result] »⟫
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// PATTERNS.

// $[Match, #First, #Second, ...]

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-Pattern[SPrimitive, $List[Reified_Term], PASS, Pattern-Stage, Text, Text, ok::OK_SORT.Text] :: Text;

Pattern-Match
:
{#env}
E-Pattern[E_Match, #Patterns, #pass, #stage, #sink, #term, ok.#[ok]]
→
{#env}
E-Pattern-All[#Patterns, #pass, #stage, #sink, #term, ok.#[ok]]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-Pattern-All[$List[Reified_Term], PASS, Pattern-Stage, Text, Text, ok::OK_SORT.Text] :: Text;

{#env}
E-Pattern-All[(), #pass, #stage, #sink, #term, ok.#[ok]]
→
{#env}
#[OK]
;

{#env}
E-Pattern-All[(#Pattern;#Patterns), #pass, #stage, #sink, term, ok.#[ok]]
→
{#env}
F-Pattern[#pass, #stage, #Pattern, #sink, %n⟨⟩, $False, $False, term, ok.E-then-Pattern-All[ok, #Patterns, #pass, #stage, #sink, term, o2.#[o2]]]
;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-then-Pattern-All[OK_SORT, $List[Reified_Term], PASS, Pattern-Stage, Text, Text, ok::OK_SORT.Text] :: Text;

{#env}
E-then-Pattern-All[OK, #Patterns, #pass, #stage, #sink, #term, ok.#[ok]]
→
{#env}
E-Pattern-All[#Patterns, #pass, #stage, #sink, #term, ok.#[ok]]
;

// $[VariableNameIs, var, #name, #pattern]
Pattern-VariableNameIs[Fresh[varterm::Text, nameterm::Text]]
:
{#env} E-Pattern[E_VariableNameIs, (#var; #namePattern; #Pattern;), #pass, #stage, #sink, #term, ok.#[ok]]
→
%n⟪{⟦ Term «varterm»;
« {#env} T-set[#var, #sink, varterm] »if (!IS_VARIABLE_USE(«varterm»)) break;
Term «nameterm» = makeStringLiteral(«#sink»->context, VARIABLE(«varterm»)->name);
«{#env} F-Pattern[#pass, #stage, #namePattern, #sink, %n⟨⟩, $True, $False, nameterm, ok.
    F-then-Pattern[ok, #pass, #stage, #Pattern, #sink, %n⟨⟩, $True, $False, #term, ok.#[ok]]]
»}⟧
⟫
;

)];

E2[(

///////////////////////////////////////////////////////////////////////////////////////////////////
// NEW PRIMITIVES ADDED BY Kris FOR HACS
// E_UpCase; E_DownCase; E_Replace; E_Trim; E_Keys; E_ParseURL; E_Rescape;

// $[UpCase, #string] is the #string with all lower case letters converted to upper case.
// NOTE: not yet Unicode...
//
STRING_LOCAL_PRIMITIVE[E_UpCase] ;

Set-String-UpCase[Fresh[s::Text]]:
{#env}E-local-string[E_UpCase, (#Name; #String;), #Options, sink, sub sp.#[sub,sp]]
→
{#env}T-local-string[#String, sink, string post . %n⟪{⟦ size_t z = (size_t) strlen(«string»);
char *«s» = memcpy((char *) ALLOCA(«sink»->context, z+1), «string», z+1);
«post»{ char *p; for (p = «s»; *p; ++p) *p = toupper(*p); }
« #[s, %n⟨⟩] »⟧}
⟫]
;

// $[DownCase, #string] is the #string with all upper case letters converted to lower case.
// NOTE: not yet Unicode...
//
STRING_LOCAL_PRIMITIVE[E_DownCase] ;

Set-String-DownCase[Fresh[s::Text]]:
{#env}E-local-string[E_DownCase, (#Name; #String;), #Options, sink, sub sp.#[sub,sp]]
→
{#env}T-local-string[#String, sink, string post . %n⟪{⟦ size_t z = (size_t) strlen(«string»);
char *«s» = memcpy((char *) ALLOCA(«sink»->context, z+1), «string», z+1);
«post»{ char *p; for (p = «s»; *p; ++p) *p = tolower(*p); }
« #[s, %n⟨⟩] »⟧}
⟫]
;

// $[Replace, #string, #old, #new] is the #string with all original occurrences of #old replaced by #new.
//
STRING_LOCAL_PRIMITIVE[E_Replace] ;

Set-String-Replace[Fresh[replaced::Text]]:
{#env}E-local-string[E_Replace, (#Name; #String; #Old; #New;), #Options, sink, sub sp.#[sub,sp]]
→
{#env}T-local-string[#String, sink, string post1 . {#env}T-local-string[#Old, sink, olds post2 . {#env}T-local-string[#New, sink, news post3 .
 %n⟪{⟦ char *«replaced»;
const size_t z = strlen(«string»);
if (*«olds») {⟦
const size_t oldz = strlen(«olds»), newz = strlen(«news»);
size_t limitz;
if (oldz==newz) {⟦ limitz = z; ⟧}
else {⟦ limitz = z; size_t growz = (oldz < newz ? newz - oldz : 0);
if (growz > 0) { char *p = «string»; while ((p = strstr(p, «olds»))) { limitz += growz; p += oldz; } } ⟧}
«replaced» = (char *) ALLOCA(«sink»->context, limitz+1);
if (oldz==newz) {⟦ memcpy(«replaced», «string», z+1);
char *r = «replaced»; while ((r = strstr(r, «olds»))) { memcpy(r, «news», newz); r += oldz; } ⟧}
else {⟦ char *s = «string», *ends = s+z, *r = «replaced», *next;
while ((next = strstr(s, «olds»))) {⟦ size_t prez = next-s;
if (prez) { memcpy(r, s, prez); r += prez; } 
if (newz) { memcpy(r, «news», newz); r += newz; }
s = next+oldz;⟧}
if (s < ends) { memcpy(r, s, ends-s); r += ends-s; }
*r = '\0';⟧}
⟧}
else {⟦ «replaced» = memcpy((char *) ALLOCA(«sink»->context, z+1), «string», z+1); ⟧}
«post1»«post2»«post3»« #[replaced, %n⟨⟩] »⟧
}⟫]]]
;

// $[Trim, #string] is the #string with all leading and trailing spaces removed.
//
STRING_LOCAL_PRIMITIVE[E_Trim] ;

Set-String-Trim[Fresh[trimmed::Text]]:
{#env}E-local-string[E_Trim, (#Name; #String;), #Options, sink, sub sp.#[sub,sp]]
→
{#env}T-local-string[#String, sink, string post . %n⟪{⟦char *p1; for (p1 = «string»; *p1 && isspace(*p1); ++p1);
char *p2; for (p2 = «string»+strlen(«string»); p1 < p2 && isspace(*(p2-1)); --p2);
size_t z = p2 - p1;
char *«trimmed» = memcpy((char *) ALLOCA(«sink»->context, z+1), p1, z); «trimmed»[z] = '\0';
«post»« #[trimmed, %n⟨⟩] »⟧}
⟫]
;

// $[Squash, #1] corresponds to constant #1 with all occurrences of white space collapsed to single ordinary spaces. 
//
STRING_LOCAL_PRIMITIVE[E_Squash] ;

Set-String-Squash[Fresh[squashed::Text]]:
{#env}E-local-string[E_Squash, (#Name; #String;), #Options, sink, sub sp.#[sub,sp]]
→
{#env}T-local-string[#String, sink, string post . %n⟪{⟦
char *«squashed» = (char *) ALLOCA(«sink»->context, strlen(«string»)+1);
char *p1=«string», *p2=«squashed»;
int wasspace=0;
for (; *p1; ++p1) {
   if (isspace(*p1)) { 
      if (!wasspace) { wasspace=1; *p2++=' '; }
   } else {
      *p2++=*p1; wasspace=0;
   }
}
*p2++='\0';
«post»« #[squashed, %n⟨⟩] »⟧}
⟫]
;

// $[Split, #string, #delim] splits the #string into a list ( s1; ... ; sn; ) where the si are the fragments separated by #delim.
//
//SEND_PRIMITIVE[E_Split];
//
//Send-Split:
//{#env} E-send[E_Split, (#Name; #String; #Sep;), #Options, sink]
//→
//{#env}T-local-string[#String, sink, string post1 . {#env}T-local-string[#Sep, sink, sep post2 . %n⟪sendSplit(«sink», «string», «sep», &«Descriptor["$Cons"]», &«Descriptor["$Nil"]»);
//«post1»«post2»⟫]]
//;


// $[ParseURL, #url] parses the URL and returns the term.
//
SEND_PRIMITIVE[E_ParseURL];

Send-ParseURL:
{#env} E-send[E_ParseURL, (#Name; #Category; #Url;), #Options, sink]
→
{#env; "$tail":NO} T-local-string[#Category, sink, cat post1.{#env; "$tail":NO}T-local-string[#Url, sink, url post2.%n⟪LOAD_TERM(«sink», «cat», «url»);
«post1»«post2»«{#env}E-send-tail»⟫]]
;

// $[ParseText, #text] parses the string and returns the term.
//
SEND_PRIMITIVE[E_ParseText];

Send-ParseText:
{#env} E-send[E_ParseText, (#Name; #Category; #Text;), #Options, sink]
→
{#env;"$tail":NO} T-local-string[#Category, sink, cat post1.{#env;"$tail":NO}T-local-string[#Text, sink, text post2.%n⟪SCAN_TERM(«sink», «cat», «text»);
«post1»«post2»«{#env}E-send-tail»⟫]]
;


// $[Rescape, #string] is the #string with all leading and trailing spaces removed.
//
STRING_PRIMITIVE[E_Rescape] ;

{#env}E-set-string[E_Rescape, (#Name; #String;), #Options, #sink, #str] 
→ 
{#env;"$tail":NO}T-local-string[#String, #sink, s p.%n⟪{⟦«#str» = makeRescaped(«#sink»->context, «s»);
«p»⟧}«{#env}E-send-tail»⟫]
;

// $[Mangle, #1] returns #1 as a constant suitable for use as the tail end of an identifier in (at least) Java and C.
//
//STRING_PRIMITIVE[E_Mangle];
//
//Set-String-Mangle:
//{#env}E-set-string[E_Mangle, (#Name; #String;), #Options, sink, str] → {#env}T-local-string[#String, sink, s p.%n⟪{⟦«str» = makeMangled(«sink»->context, «s»);
//«p»⟧}
//⟫]
//;

// $[{#env}Keys]
//
SEND_PRIMITIVE[E_Keys];

Send-Keys:
{#env} E-send[E_Keys, (PROPERTY-REF[#Ref, #Use, #Name];), #Options, #sink]
→
{#env} E-send-Keys1[$[:,"MetaVar$",#Ref], #Name, #Options, #sink]
;

)];

E1[(

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-send-Keys1[$String, Reified_Term, $List[$List[Reified_Option]], Text] :: Text;

{#env; #RefCookie : PROPERTY_VARIABLE[#namedP, #varP]}
E-send-Keys1[#RefCookie, #Name, #Options, #sink]
→
%n⟪
sendPropertiesKeys(«#sink», «#namedP», «#varP»);«{#env}E-send-tail»⟫;

// $[Echo, #message] emits a message.
//

Poly-Echo:
{#env} E-poly[E_Echo, (#Name; #String;), #Options, sink, ok result.#Tail[ok,result]]
→
{#env;"$tail":NO} T-local-string[#String, sink, arg p. %n⟪TRACEF(«sink»->context, «FormatKindOf[#Name]», "%s\n", «arg»);
«p»« {#env}E-optional[(), #Options, sink, ok arg.#Tail[ok,arg]] »⟫]
;

)];

E3[(


{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}E-eval[SPrimitive, $List[Reified_Term], $List[$List[Reified_Option]], Text] :: Text;

Null-eval:             {#env}E-eval[E_Null, (#Name;), #Options, #sink] → %n⟪⟫ ;

// Let

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-let[Reified_Term, Text, Reified_Term, Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-let[META-APPLICATION[#metavar, (), #use], #value, #result, #sink, ok result.#tail[ok,result]]
→ {#env; #value : ARG[0, $True]}AddMetaCookie[#metavar, VARIABLE[#value], ok.#tail[ok, #result]];

{#env}E-poly-let[CONSTRUCTION[KDATA, #symbol, #binders], #value, #result, #sink, ok result.#tail[ok,result]]
→ %n⟪
if («INTEGER[Length[#binders, 0]]» != ARITY(«#value»))⟦
   ERRORF(«#sink»->context, Crsx, "Invalid value encountered while deconstructing let\n");⟧«
{#env}E-poly-let-deconstruct[OK, #binders, #value, 0, #result, #sink, ok result.#tail[ok,result]]»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-let-deconstruct[OK_SORT, $List[Reified_Binder], Text, $Numeric, Reified_Term, Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-let-deconstruct[OK, (), #value, #index, #result, #sink, ok result.#tail[ok,result]]
→ %n⟪
UNLINK(«#sink»->context, «#value»);«{#env}#tail[OK, #result]»⟫;

-[Fresh[sub::Text]]:
{#env}E-poly-let-deconstruct[OK, (ARGUMENT[#sort, META-APPLICATION[#metavar, (), #use]]; #binders), #value, #index, #result, #sink, ok result.#tail[ok,result]]
→ $[If, $[Equal, #use, DISCARD],  
     {#env}E-poly-let-deconstruct[OK, #binders, #value, $[Plus, #index, 1], #result, #sink, ok result.#tail[ok,result]],
     %n⟪
Term «sub» = LINK(«#sink»->context, SUB(«#value», «INTEGER[#index]»));«
{#env; sub : ARG[#index, $True]}AddMetaCookie[#metavar, VARIABLE[sub], ok.E-poly-let-deconstruct[ok, #binders, #value, $[Plus, #index, 1], #result, #sink, ok result.#tail[ok,result]]]»⟫];

// --- For

// TODO: generate lazy evaluation.  

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for[Reified_Term, Reified_Term, Reified_Term, Reified_Term, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

-[Fresh[list::Text]]:
{#env}E-poly-for[#vars, #list, #params, #inits, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ %n⟪
Term «list»;« {#env; "$tail": NO} T-set[#list, #sink, list] »
«list» = NORMALIZEP(«#sink»->context, «list»);«{#env; "$params": TEXTS[()]}E-poly-for-init[#vars, list, #params, #inits, #body, #result, #options, #sink, ok result.#tail[ok,result]]»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-init[Reified_Term, Text, Reified_Term, Reified_Term, Reified_Term, Reified_Term,  $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-for-init[#vars, #list, #params, CONSTRUCTION[#kind2, #symbol2, #args2], #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[If, $[StartsWith, #symbol2, "Tuple"],
     {#env}E-poly-for-init-static1[#vars, #list, #params, #args2, #body, #result, #options, #sink, ok result.#tail[ok,result]],
     {#env}E-poly-for-init1[#vars, #list, #params, CONSTRUCTION[#kind2, #symbol2, #args2], #body, #result, #options,#sink, ok result.#tail[ok,result]]];

-[Fallback]:
{#env}E-poly-for-init[#vars, #list, #params, #init, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ {#env}E-poly-for-init1[#vars, #list, #params, #init, #body, #result, #options,#sink, ok result.#tail[ok,result]];

// Static Tuple. Optimize out
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-init-static1[Reified_Term, Text, Reified_Term, $List[Reified_Binder], Reified_Term, Reified_Term,  $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-for-init-static1[#vars, #list, CONSTRUCTION[#kind, #symbol, #args], #args2, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[If, $[StartsWith, #symbol, "Tuple"], 
        {#env; "$tplparams": YES}E-poly-for-init-static2[OK, #vars, #list, #args, #args2, #body, #result, #options, #sink, ok result.#tail[ok,result]],
        $[Error, "Invalid $[For parameter: must be of the form TupleN[...] or #"]];

-[Fallback]:
{#env}E-poly-for-init-static1[#vars, #list, #init, #args2, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[Error, "Invalid $[For parameter: must be of the form TupleN[...] or #"];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-init-static2[OK_SORT, Reified_Term, Text, $List[Reified_Binder], $List[Reified_Binder], Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-for-init-static2[OK, #vars, #list, (), (), #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ {#env}E-poly-for-binder[OK, #vars, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]];

-[Fresh[term::Text]]:
{#env}E-poly-for-init-static2[OK, #vars, #list, (ARGUMENT[#sort, META-APPLICATION[#metavar, (), #use]]; #binders), (ARGUMENT[#sort2, #term]; #binders2), #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[If, $[Equal, #use, DISCARD], // The param is just an unused meta variable. Don't bother computing the initial value.
    {#env}E-poly-for-init-static3[#metavar, term, $False, #vars, #list, #binders, #binders2, #body, #result, #options, #sink, ok result.#tail[ok,result]],
    %n⟪
Term «term»;« {#env; "$tail": NO} T-set[#term, #sink, term] »«
{#env}E-poly-for-init-static3[#metavar, term, $True, #vars, #list, #binders, #binders2, #body, #result, #options, #sink, ok result.#tail[ok,result]]»⟫];

-[Fallback]:
{#env}E-poly-for-init-static2[OK, #vars, #list, #binder, #binders2, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[Error, "Initialization parameters in $[For primitive have does not match the number of initialization values"];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-init-static3[$String, Text, $Boolean, Reified_Term, Text, $List[Reified_Binder], $List[Reified_Binder], Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env; "$params":TEXTS[#params]}E-poly-for-init-static3[#metavar, #term, #linked, #vars, #list, #binders, #binders2, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ {#env; #term : SUB[#term, 0, #linked, $True]; "$params":TEXTS[Append[#params, (#term;)]]
  }AddMetaCookie[#metavar, VARIABLE[#term], ok.
   E-poly-for-init-static2[ok, #vars, #list, #binders, #binders2, #body, #result, #options, #sink, ok result.#tail[ok,result]]];

// Non static value/tuple. Evaluate and extract (if used)
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-init1[Reified_Term, Text, Reified_Term, Reified_Term, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

// Case where parameter is just a metavar. If not used (most unlikely), then don't compute initial value.
-[Fresh[init::Text]]:
{#env}E-poly-for-init1[#vars, #list, META-APPLICATION[#metavar, (), #use], #inits, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[If, $[Equal, #use, DISCARD], // The param is just an unused meta variable. Don't bother computing the initial value.
     {#env}E-poly-for-init2[#vars, #list, META-APPLICATION[#metavar, (), #use], init, $False, #body, #result, #options, #sink, ok result.#tail[ok,result]],
     {#env}E-poly-for-init1a[#vars, #list, META-APPLICATION[#metavar, (), #use], #inits, #body, #result, #options, #sink, ok result.#tail[ok,result]]];

-[Fallback]:
{#env}E-poly-for-init1[#vars, #list, #args, #inits, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ {#env}E-poly-for-init1a[#vars, #list, #args, #inits, #body, #result, #options, #sink, ok result.#tail[ok,result]];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-init1a[Reified_Term, Text, Reified_Term, Reified_Term, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

-[Fresh[init::Text]]:
{#env}E-poly-for-init1a[#vars, #list, #args, #inits, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ %n⟪
Term «init»;« {#env; "$tail": NO} T-set[#inits, #sink, init] »
«init» = NORMALIZEP(«#sink»->context, «init»);«{#env}E-poly-for-init2[#vars, #list, #args, init, $True, #body, #result, #options, #sink, ok result.#tail[ok,result]]»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-init2[Reified_Term, Text, Reified_Term, Text, $Boolean, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

// Case where parameter is just a metavar  
{#env}E-poly-for-init2[#vars, #list, META-APPLICATION[#metavar, (), #use], #init, #linked, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ {#env; #init : SUB[#init, 0, #linked, $True]; "$tplparams": NO; "$params":TEXTS[(#init;)]}AddMetaCookie[#metavar, VARIABLE[#init], ok.E-poly-for-binder[OK, #vars, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]];

// Case where parameter is dynamic Tuple... extract.
{#env}E-poly-for-init2[#vars, #list, CONSTRUCTION[#kind, #symbol, #args], #init, #linked, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ %n⟪ if («INTEGER[Length[#args, 0]]» != ARITY(«#init»))⟦
   ERRORF(«#sink»->context, Crsx, "Invalid value encountered while initializing for parameters\n");⟧«
{#env; "$tplparams": YES}E-poly-for-init3[OK, #vars, #list, #args, #init, 0, #body, #result, #options, #sink, ok result.#tail[ok,result]]»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-init3[OK_SORT, Reified_Term, Text, $List[Reified_Binder], Text, $Numeric, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-for-init3[OK, #vars, #list, (), #init, #index, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ %n⟪
UNLINK(«#sink»->context, «#init»);«{#env}E-poly-for-binder[OK, #vars, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]»⟫;

-[Fresh[sub::Text]]:
{#env}E-poly-for-init3[OK, #vars, #list, (ARGUMENT[#sort, META-APPLICATION[#metavar, (), #use]]; #args), #init, #index, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[If, $[Equal, #use, DISCARD], // Not used.
    {#env}E-poly-for-init4[#metavar, sub, $False, #vars, #list, #args, #init, $[Plus, #index, 1], #body, #result, #options, #sink, ok result.#tail[ok, result]],
    %n⟪
Term «sub» = LINK(«#sink»->context, SUB(«#init», «INTEGER[#index]»));«
{#env}E-poly-for-init4[#metavar, sub, $True, #vars, #list, #args, #init, $[Plus, #index, 1], #body, #result, #options, #sink, ok result.#tail[ok,result]]»⟫];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-init4[$String, Text, $Boolean, Reified_Term, Text, $List[Reified_Binder], Text, $Numeric, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env; "$params":TEXTS[#params]}E-poly-for-init4[#metavar, #sub, #linked, #vars, #list, #args, #init, #index, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ {#env; #sub : SUB[#sub, #index, #linked, $True]; "$params":TEXTS[Append[#params, (#sub;)]]
  }AddMetaCookie[#metavar, VARIABLE[#sub], ok.
   E-poly-for-init3[ok, #vars, #list, #args, #init, $[Plus, #index, 1], #body, #result, #options, #sink, ok result.#tail[ok,result]]];

// Generate binder declarations
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-binder[OK_SORT, Reified_Term, Text, Reified_Term, Reified_Term,  $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-for-binder[OK, CONSTRUCTION[#kind, #symbol, #args], #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[If, $[StartsWith, #symbol, "Tuple"], 
        {#env}E-poly-for-binder-static[OK, (), #args, 0, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]],
        $[Error, "Invalid $[For binder: must be of the form TupleN[...] or #"]];

-[Fresh[item::Text]]:
{#env}E-poly-for-binder[OK, META-APPLICATION[#metavar, (), #use], #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[If, $[Equal, #use, DISCARD], // case where binder is not used in body and return. Optimize out.
    {#env}E-poly-for-binder1[#metavar, item, $False, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]],
    %n⟪
Term «item» = (Term) «Const["$True"]»; /* dummy */«{#env}E-poly-for-binder1[#metavar, item, $True, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]»⟫];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-binder1[$String, Text, $Boolean, Text, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-for-binder1[#metavar, #item, #linked, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ {#env; #item : SUB[#item, 0, #linked, $True]
  }AddMetaCookie[#metavar, VARIABLE[#item], ok.
   E-poly-for-loop[ok, $False, (#item;), #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]];

// Deconstruct tuple.
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-binder-static[OK_SORT, $List[Text], $List[Reified_Binder], $Numeric, Text, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-for-binder-static[OK, #vars, (), #index, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ {#env}E-poly-for-loop[OK, $True, #vars, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]];

-[Fresh[subitem::Text]]:
{#env}E-poly-for-binder-static[OK, #vars, (ARGUMENT[#sort, META-APPLICATION[#metavar, (), #use]]; #args), #index, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ $[If, $[Equal, #use, DISCARD],
    {#env}E-poly-for-binder-static1[#metavar, subitem, $False, #vars, #args, #index, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]],
    %n⟪
Term «subitem» = (Term) «Const["$True"]»; /* dummy */«
{#env}E-poly-for-binder-static1[#metavar, subitem, $True, #vars, #args, #index, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]»⟫];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-binder-static1[$String, Text, $Boolean, $List[Text], $List[Reified_Binder], $Numeric, Text, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

{#env}E-poly-for-binder-static1[#metavar, #subitem, #linked, #vars, #args, #index, #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]
→ {#env; #subitem : SUB[#subitem, #index, #linked, $True]
  }AddMetaCookie[#metavar, VARIABLE[#subitem], ok.
   E-poly-for-binder-static[ok, Append[#vars, (#subitem;)], #args, $[Plus, #index, 1], #list, #body, #result, #options, #sink, ok result.#tail[ok,result]]];

// Generate loop
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-loop[OK_SORT, $Boolean, $List[Text], Text, Reified_Term, Reified_Term, $List[$List[Reified_Option]], Text, ok::OK_SORT result::Reified_Term.Text] :: Text;

-[Fresh[item::Text, next::Text]]:
{#env}E-poly-for-loop[OK, #istuple, #vars, #list, #body, #result, (#o0; #o1; #o2; #o3; #o4; #ob; #or;), #sink, ok result.#tail[ok,result]]
→ %n⟪
while (&«Descriptor["$Cons"]» == DESCRIPTOR(«#list»)) {⟦
/* Extract item from list */
Term «item» = LINK(«#sink»->context, SUB(«#list», 0)); 
Term «next» = LINK(«#sink»->context, SUB(«#list», 1));
UNLINK(«#sink»->context, «#list»);
«#list» = «next»;
/* bind new list item */«{#env}E-poly-for-update[#istuple, $True, #vars, item, (#o0; #o1; #o2; #o3; #o4; #ob; #or;), #sink]»«{#env}E-poly-for-body[#body, (#o0; #o1; #o2; #o3; #o4; #ob; #or;), #sink]»⟧
}
UNLINK(«#sink»->context, «#list»);«{#env}E-OptionsUnlink[#sink, #or]»«{#env}#tail[OK, #result]»⟫;

// Update variables or parameter values.
{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-update[$Boolean /* is tuple? */, $Boolean /* is variable? */, $List[Text], Text, $List[$List[Reified_Option]], Text] :: Text;

// Don't deconstruct tuple. variable is not used.
{#env; #item: SUB[#parent, #index, $False, #isterm]}E-poly-for-update[$False, #isvar, (#item;), #newitem, #options, #sink]
→ $[If, #isvar, 
    %n⟪⟫, // has been discarded earlier
    %n⟪
UNLINK(«#sink»->context, «#newitem»);⟫]; 

// Don't deconstruct tuple. value is  used.
{#env; #item: SUB[#parent, #index, $True, #isterm]}E-poly-for-update[$False, #isvar, (#item;), #newitem, #options, #sink]
→ %n⟪
«#item» = «#newitem»;⟫;

// deconstruct tuple
{#env}E-poly-for-update[$True, #isvar, (#item; #items), #newtuple, #options, #sink]
→ %n⟪«{#env}E-poly-for-unlink-vars[(#item; #items), #isvar, #sink]»«{#env}E-poly-for-update-tuple[0, (#item; #items), #newtuple, #sink]»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-update-tuple[$Numeric, $List[Text], Text, Text] :: Text;

{#env}E-poly-for-update-tuple[#index, (), #newtuple, #sink]
→ %n⟪
UNLINK(«#sink»->context, «#newtuple»);⟫;

{#env; #item: SUB[#parent, #index, $False, #isterm]}E-poly-for-update-tuple[#index, (#item; #items), #newtuple, #sink]
→ {#env}E-poly-for-update-tuple[$[Plus, #index, 1], #items, #newtuple, #sink];

{#env; #item: SUB[#parent, #index, $True, #isterm]}E-poly-for-update-tuple[#index, (#item; #items), #newtuple, #sink]
→ %n⟪
«#item» = LINK(«#sink»->context, SUB(«#newtuple», «INTEGER[#index]»));«{#env}E-poly-for-update-tuple[$[Plus, #index, 1], #items, #newtuple, #sink]»⟫;

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-unlink-vars[$List[Text], $Boolean, Text] :: Text;

{#env}E-poly-for-unlink-vars[(), #isvar, #sink]        
→ %n⟪⟫;

{#env; #b: SUB[#parent, #index, $False, #isterm]}E-poly-for-unlink-vars[(#b; #bs), #isvar, #sink] 
→ $[If, #isvar, 
    %n⟪
UNLINK(«#sink»->context, «#b»);«{#env}E-poly-for-unlink-vars[#bs, #isvar, #sink]»⟫,
    {#env}E-poly-for-unlink-vars[#bs, #isvar, #sink]];

{#env; #b: SUB[#parent, #index, $True, #isterm]}E-poly-for-unlink-vars[(#b; #bs), #isvar, #sink] 
→ {#env}E-poly-for-unlink-vars[#bs, #isvar, #sink];

{$String:STRING_ENTRY;Reified_Variable:VARIABLE_ENTRY}
E-poly-for-body[Reified_Term, $List[$List[Reified_Option]], Text] :: Text;

// TODO: optimize parameters only updated in body and used in return.

-[Fresh[newvalues::Text]]:
{#env; "$params": TEXTS[#params]; "$tplparams": #istuple}E-poly-for-body[#body, #options, #sink] 
→ %n⟪
Term «newvalues»;«{#env}T-set[#body, #sink, newvalues]»
«newvalues» = NORMALIZEP(«#sink»->context, «newvalues»);«{#env}E-poly-for-update[$[Equal, #istuple, YES], $False, #params, newvalues, #options, #sink]»⟫;

)]; // E3

///////////////////////////////////////////////////////////////////////////////////////////////////
)] //E

// Copyright © 2012,2013 IBM Corporation
// $Id: rules.crs,v 3.29 2013/12/18 20:16:18 villardl Exp $

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERATE C RULES FILE TEXT FROM REIFIED CRSX.
///////////////////////////////////////////////////////////////////////////////////////////////////

RULES[(

$Use["compiler/c/cdefs.crs"];
$Use["compiler/c/term.crs"];
$Use["compiler/c/srules.crs"];

$Lax;

///////////////////////////////////////////////////////////////////////////////////////////////////
// C RULES TEMPLATE.
//
// Create text of C source files with function symbol descriptors and code.
//
// Environment:
// - HEADERS: ;-separated list of header file base names.
// - MODULE: name of module to generate declarations for

ComputeRules[Reify_CRSX] :: Text;

ComputeRules[CRSX[#name, #Declarations]]
→
F-Declarations[#name, #Declarations, $[Get[$String], "MODULE", ""]]
;

F-Declarations[$String, $List[Reified_Declaration], $String] :: Text;

-[Data[#module]]
:
F-Declarations[#name, #Declarations, #module]
→
%n⟪/* C RULES FOR CRSX « COMMENT_TOKEN[#name] » MODULE « COMMENT_TOKEN[#module] ». */
« MapText[x.%n⟨#include "‹ TOKEN[x] ›"
⟩, $[Split, $[Get[$String], "HEADERS", ""], ";"]] »
#ifdef __cplusplus
extern "C" {
#endif
« MapText[d.F-Declaration[d, #module], #Declarations] »
#ifdef __cplusplus
}
#endif
/* END OF C RULES FOR CRSX « COMMENT_TOKEN[#name] » MODULE « COMMENT_TOKEN[#module] ». */
⟫
;

F-Declaration[Reified_Declaration, $String] :: Text;

Polymorphic[Fresh[argument::Reified_Variable]]  
: 
F-Declaration[POLYMORPHIC[a.#Declaration[a]], #module] 
→ 
F-Declaration[#Declaration[argument], #module] 
;

Data
: 
F-Declaration[DATA[#Sort, #Forms], #module] 
→ 
%n⟪⟫ 
;

Function
:
F-Declaration[FUNCTION[#prefix, #kind, #path, #function, #Forms, #Sort, #Rules], #module]
→
$[If, $[StartsWith,#prefix, #module], 
    $[IfDef, "STRICT",
        SF-Function[#kind, #function, #Forms, #Sort, #Rules],
         F-Function[#kind, #function, #Forms, #Sort, #Rules]
    ],
%n⟪⟫]
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// RULE FUNCTIONS.

F-Function[$String, $String, $List[Reified_Form], Reified_Sort, $List[Reified_Rule]] :: Text;

F-Function[#kind, #function, (SORT-SET[#Sort1, #Sort2, #Form]; #Forms), #Sort, #Rules]
→
F-Function[#kind, #function, (#Form; #Forms), #Sort, #Rules]
;

-[Fresh[sink::Text, term::Text]]
:
F-Function[#kind, #function, (FORM[#name, #FormArguments]; #Forms), SORT[#SortName,#SortArgs], #Rules]
→
%n⟪
/* FUNCTION « COMMENT_TOKEN[#function] ». */
int « BinderOffsets[#function] »[] = {0« DelayMapText[k o.%n⟨ , ‹ DINTEGER[k, o] ›⟩, FormArguments-binder-offsets[#FormArguments, 0]] »};
char *« NameFun[#function] »(Term term) { return « STRING[#function] »; }
struct _ConstructionDescriptor « Descriptor[#function] » = {« $[If, $[Contains, #SortName, "$"], %n⟨NULL⟩, %n⟨&‹Sort[#SortName]›⟩] », 0, « INTEGER[Length[#FormArguments,0]] », sizeof(STRUCT« Struct[#function] »), « BinderOffsets[#function] », &« NameFun[#function] », &« Step[#function] »};

int «Step[#function]»(Sink «sink», Term «term»)
{⟦
« F-Body[#kind, sink, term, #function, #FormArguments, SORT[#SortName,#SortArgs], #Rules] »return 0;⟧
}
⟫
;

-[Fresh[sink::Text, term::Text]]
:
F-Function[#kind, #function, (FORM[#name, #FormArguments]; #Forms), SORT-VARIABLE[#SortVariable], #Rules]
→
%n⟪
/* FUNCTION « COMMENT_TOKEN[#function] ». */
int « BinderOffsets[#function] »[] = {0« DelayMapText[k o.%n⟨ , ‹ DINTEGER[k, o] ›⟩, FormArguments-binder-offsets[#FormArguments, 0]] »};
char *« NameFun[#function] »(Term term) { return « STRING[#function] »; }
struct _ConstructionDescriptor « Descriptor[#function] » = {NULL, 0, « INTEGER[Length[#FormArguments,0]] », sizeof(STRUCT« Struct[#function] »), « BinderOffsets[#function] », &« NameFun[#function] », &« Step[#function] »};

int «Step[#function]»(Sink «sink», Term «term»)
{⟦
« F-Body[#kind, sink, term, #function, #FormArguments, SORT-VARIABLE[#SortVariable], #Rules] »return 0;⟧
}
⟫
;
//TODO: check #Forms empty and #function = #name.

F-Function[#kind, #function, (), #Sort, #Rules]
→
%n⟪⟫
;

F-Body[$String, Text, Text, $String, $List[Reified_FormArgument], Reified_Sort, $List[Reified_Rule]] :: Text;

F-Body[#kind, #sink, #term, #function, #FormArguments, #Sort, #Rules]
→ 
%n⟪int « #term »_count = LINK_COUNT(« #term »); permitUnusedInt(« #term »_count);
«
$[If, $[Equal, #kind, "Contract"], F-Contract[#sink, #term, #function, #Rules],
$[If, $[Equal, #kind, "BinderDispatch"], F-Contract[#sink, #term, #function, #Rules], //TODO: only works for single rule...
$[If, $[Equal, #kind, "Dispatch"], F-Dispatch[#sink, #term, #function, #FormArguments, #Sort, #Rules],
$[If, $[Equal, #kind, "Shuffle" ], F-Contract [#sink, #term, #function, #Rules],
%n⟨⟩]]]]
»⟫
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Contraction rule function: rule that merely destructs according to a pattern and generates a result term.

// Generate function body for complete contraction rule: process options, then pattern, finally contraction.
// Record linked subs ($Subs) to unlink when the step fails
// Property refs ($Refs) are always linked during the pattern phase, and unlink either when the step fails or at the end of the step.
//  

F-Contract[Text, Text, $String, $List[Reified_Rule]] :: Text;

F-Contract[#sink, #term, #function, (RULE[#name, #Options, #Pattern, #Contractum];#Rules)]
→
%n⟪do {⟦
/* Contraction rule « COMMENT_TOKEN[#name] ». */
« {"$Binders":LIST_VARIABLE[()];"$Subs": LIST_VARIABLE[()]; "$Refs": LIST_STRING[()]; "$Vars": LIST_VARIABLE[()]} F-Options[#Options, o3.F-then-Fresh[o3, #sink, #Options, ok.F-then-Pattern[ok, FIRST, MATCH, #Pattern, #sink, %n⟨⟩, $False, $False, #term, o2.F-then-Send[o2, #term, #Contractum, #sink]]]] »return 1;⟧
} while (0);
« F-Contract[#sink, #term, #function, #Rules] »⟫
;

// Generate function body for complete contraction rule: process options, then pattern, finally contraction. 
-[Free[sink::Text, term::Text]]
:
F-Contract[sink, term, #function, ()]
→
%n⟪⟫
;

// Initialize fresh variable.

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-then-Fresh[OK_SORT, Text, $List[Reified_Option], ok::OK_SORT.Text] :: Text;

-[Free[sink::Text]]
:
{#env}
F-then-Fresh[OK, sink, #Options, ok.#[ok]] 
→ 
{#env}
F-Freshes[sink, #Options, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Freshes[Text, $List[Reified_Option], ok::OK_SORT.Text] :: Text;

-[Free[sink::Text]]
:	
{#env}
F-Freshes[sink, (OPTION[#name, #value]; #options), ok.#[ok]] 	
→ 
{#env}
F-Fresh[sink, #name, #value, ok.F-then-Fresh[ok, sink, #options, o2.#[o2]]]
;

-[Free[sink::Text]]
:	
{#env}
F-Freshes[sink, (), ok.#[ok]]
→ 
{#env}#[OK]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Fresh[Text, $String, Reified_Term, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text]]
: 
{#env}
F-Fresh [sink, #name, #value, ok.#[ok]]  
→ 
$[If, $[Equal, #name, "Fresh"], {#env}F-Fresh2[sink, #value, ok.#[ok]], {#env}#[OK]]
; 

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Fresh2[Text, Reified_Term, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text]]	
: 
{#env}
F-Fresh2[sink, CONSTRUCTION[#kind, #symbol, #binders], ok.#[ok]] 
→ 
{#env}
F-Fresh3[OK, sink, #binders, ok.#[ok]]
;

-[Free[sink::Text, key::Text]]
:
{#env; "$Vars": LIST_VARIABLE[#Vars]}
F-Fresh2[sink, VARIABLE-USE[key], ok.#[ok]]	 
→ 
%n⟪Variable «key» = MAKE_FRESH_PROMISCUOUS_VARIABLE(«sink»->context, «STRING[$[BeforeFirst,$[Show,key],"_"]]»);«{#env; "$Vars":LIST_VARIABLE[(key;#Vars)]}#[OK]»
⟫;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Fresh3[OK_SORT, Text, $List[Reified_Binder], ok::OK_SORT.Text] :: Text;

{#env}
F-Fresh3[OK, #sink, (#binder; #binders), ok.#[ok]] → 
    %n⟪«{#env}F-Fresh4[#sink, #binder, ok.F-Fresh3[ok, #sink, #binders, o2.#[o2]]]»⟫
;

{#env}
F-Fresh3[OK, #sink, (), ok.#[ok]] 
→ 
{#env}#[OK]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Fresh4[Text, Reified_Binder, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text]] 
: 
{#env}
F-Fresh4[sink, ARGUMENT[#sort,#term], ok.#[ok]] 
→ 
{#env}
F-Fresh2[sink, #term, ok.#[ok]]
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Dispatch rule function: single rule that switches on an initial value before contracting the remainder.

F-Dispatch[Text, Text, $String, $List[Reified_FormArgument], Reified_Sort, $List[Reified_Rule]] :: Text;

// Generate function body for complete contraction rule set.
F-Dispatch[#sink, #term, #function, (#FormArgument1;#FormArguments), #ResultSort, #Rules]
→
F-Dispatch-choice[#function, #FormArgument1, #sink, #term, #Rules]
;

// Generate choice.

F-Dispatch-choice[$String, Reified_FormArgument, Reified_Variable, Reified_Variable, $List[Reified_Rule]] :: Text;

//// TODO: TEMPORARY RULE UNTIL FOUND OUT WHY BinderSort is missing
//-[Fresh[dummy::Text]]
//:
//F-Dispatch-choice[#function, FORM-BINDER[v.#Form[v]], #sink, #term, #Rules]
//→
//F-Dispatch-choice[#function, #Form[dummy], #sink, #term, #Rules]
//;

-[Fresh[dummy::Text]]
:
F-Dispatch-choice[#function, FORM-BINDER[#Kind, #BinderSort, v.#Form[v]], #sink, #term, #Rules]
→
F-Dispatch-choice[#function, #Form[dummy], #sink, #term, #Rules]
;

-[Fresh[sub::Text, choice::Text]]
:
F-Dispatch-choice[#function, FORM-ARGUMENT[SORT[#SortName, #SortParams]], #sink, #term, #Rules]  
→ 
DEBUGCOND(«#sink»->context->debugviz, DEBUGF(«#sink»->context, "//CHILD\n"));
%n⟪Term «sub» = FORCE(«#sink»->context, SUB(«#term», 0));
« Enum[#SortName] » «choice» = (IS_VARIABLE_USE(«sub») ? « EnumVar[#SortName] » : (« Enum[#SortName] ») TAG(«sub»));
DEBUGCOND(«#sink»->context->debugviz, DEBUGF(«#sink»->context, "//PARENT\n"));
switch («choice»)
{⟦
« F-Dispatch-cases[FIRST, #function, #Rules, #sink, #term, #SortName] »default: break;⟧
}
⟫
;

-[Free[alpha::Reified_Variable]]
:
F-Dispatch-choice[#function, FORM-ARGUMENT[SORT-VARIABLE[alpha]], #sink, #term, #Rules]  
→
F-Contract[#sink, #term, #function, #Rules] // dispatch on single polymorphic variable - just contract.
;

F-Dispatch-cases[PASS, $String, $List[Reified_Rule], Text, Text, $String] :: Text;

// Generate switch body for each dispatch rule: case+options+matching, then contraction, finally report success.
F-Dispatch-cases[#pass, #function, (RULE[#name, #Options, #Pattern, #Contractum];#Rules), #sink, term, #SortName]
→
%n⟪« {"$Binders":LIST_VARIABLE[()]; "$Subs":LIST_VARIABLE[()]; "$Refs": LIST_STRING[()];"$Vars": LIST_VARIABLE[()]}
     F-Pattern[#pass, DISPATCH[#name,#Options,#SortName], #Pattern, #sink, %n⟨⟩, $False, $False, term, ok.
     F-then-Send[ok, term, #Contractum, #sink]] »« F-Dispatch-cases[SECOND, #function, #Rules, #sink, term, #SortName] »⟫
;

F-Dispatch-cases[FIRST, #function, (), #sink, #term, #SortName]
→
%n⟪⟫
;

F-Dispatch-cases[SECOND, #function, (), #sink, #term, #SortName]
→
%n⟪}
⟫
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Options.
//
// Options are recorded in the environment thus collected in a chained manner, where the final
// invocation has mappings  variable : Free|Fresh  and  Discard$metavar | Copy$metavar |... : () .

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY} 
F-then-Options[OK_SORT, $List[Reified_Option], ok::OK_SORT.Text] :: Text;

{#env}
F-then-Options[OK, #Options, ok.#[ok]] 
→ 
{#env} 
F-Options[#Options, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY} 
F-Options[$List[Reified_Option], ok::OK_SORT.Text] :: Text;

{#env}F-Options[(OPTION[#option, #value] ; #Options), ok.#[ok]] → {#env}F-Option[#option, #value, o2.F-then-Options[o2, #Options, ok.#[ok]]] ;
{#env}F-Options[()                                  , ok.#[ok]] → {#env}#[OK] ;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY} 
F-Option[$String, Reified_Term, ok::OK_SORT.Text] :: Text;

{#env}
F-Option[#option, #value, ok.#[ok]]
→
$[If, $[Equal, #option, "Free"            ], {#env}F-variableOption[FREE, #value, ok.#[ok]],
$[If, $[Equal, #option, "Fresh"           ], {#env}F-variableOption[FRESH, #value, ok.#[ok]],
$[If, $[Equal, #option, "FreshReuse"      ], {#env}F-variableOption[FRESHREUSE, #value, ok.#[ok]], // TODO: NOT USED?
$[If, $[Equal, #option, "FreshReuseOrigin"], {#env}F-variableFreshReuseOriginOption["FreshReuseOrigin", #value, ok.#[ok]], // TODO: NOT USED?
  {#env}F-metaOption[#option, #value, ok.#[ok]]]]]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-variableOption[VARIABLE_ENTRY, Reified_Term, ok::OK_SORT.Text] :: Text;

-[Free[key::Reified_Variable]]
:
{#env}
F-variableOption[#option, VARIABLE-USE[key], ok.#[ok]] // Unsorted variable
→ 
{#env; key : #option}
F-recordFreeOption[#option, key, ok.#[ok]]
;

{#env}
F-variableOption[#option, CONSTRUCTION[#kind,#symbol, #binders], ok.#[ok]] // Sorted variable
→
{#env} 
F-variableOption2[#option, #symbol, #binders, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-then-VariableOption2[OK_SORT, VARIABLE_ENTRY, $String, $List[Reified_Binder], ok::OK_SORT.Text] :: Text;

{#env}
F-then-VariableOption2[OK, #option, #symbol, #binders, ok.#[ok]]
→
{#env}
F-variableOption2[#option, #symbol, #binders, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-variableOption2[VARIABLE_ENTRY, $String, $List[Reified_Binder], ok::OK_SORT.Text] :: Text;

{#env}
F-variableOption2[#option, #symbol, (#binder;#binders), ok.#[ok]]
→
{#env}
F-variableOption3[#option, #binder, ok.F-then-VariableOption2[ok, #option, #symbol, #binders, o2.#[o2]]]
;

{#env}
F-variableOption2[#option, #symbol, (), ok.#[ok]]
→
{#env}
#[OK]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-variableOption3[VARIABLE_ENTRY, Reified_Binder, ok::OK_SORT.Text] :: Text;

{#env}
F-variableOption3[#option, ARGUMENT[#sort,#term], ok.#[ok]]
→
{#env}
F-variableOption4[#option, #term, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-variableOption4[VARIABLE_ENTRY, Reified_Term, ok::OK_SORT.Text] :: Text;

-[Free[key::Reified_Variable]]
:
{#env}
F-variableOption4[#option, VARIABLE-USE[key], ok.#[ok]]
→
{#env; key : #option}
#[OK]
;

{#env}
F-variableOption4[#option, CONSTRUCTION[#kind,#symbol, #binders], ok.#[ok]]
→
{#env}
#[OK]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY} F-variableFreshReuseOriginOption[$String, Reified_Term, ok::OK_SORT.Text] :: Text;

{#env}
F-variableFreshReuseOriginOption[#option, FreshReuseOrigin[#var, #metavar, #index], ok.#[ok]] // HACK---TODO: clean up here and in reify().
→
{#env}
F-variableFreshReuseOriginOption2[#option, $[:,"Reuse$",#metavar,"$",$[FormatNumber, #index]], #var, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY} F-variableFreshReuseOriginOption2[$String, $String, Reified_Variable, ok::OK_SORT.Text] :: Text;

-[Data[#key]]
:
{#env}
F-variableFreshReuseOriginOption2[#option, #key, #var, ok.#[ok]]
→
{#env; #key : VARIABLE[#var]} 
#[OK]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY} F-metaOption[$String, Reified_Term, ok::OK_SORT.Text] :: Text;

{#env}
F-metaOption[#option, LITERAL[#key, #sort], ok.#[ok]]
→
{#env}
F-metaOption2[$[:,#option,"$",#key], ok.#[ok]]
;

{#env}
F-metaOption[#option, CONSTRUCTION[#kind,#symbol, #binders], ok.#[ok]]
→
{#env}
F-metaOption2[$[:,#option,"$",#symbol], ok.#[ok]]
;

{#env}
F-metaOption[#option, META-APPLICATION[#symbol, #arguments,#count], ok.#[ok]]
→
{#env}
F-metaOption2[$[:,#option,"$",#symbol], ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY} F-metaOption2[$String, ok::OK_SORT.Text] :: Text;

-[Data[#key]]
:
{#env}
F-metaOption2[#key, ok.#[ok]]
→
{#env; #key : LIST_VARIABLE[()]}
#[OK]
;


{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY} F-recordFreeOption[VARIABLE_ENTRY, Reified_Variable, ok::OK_SORT.Text] :: Text;

{#env; "$Vars": LIST_VARIABLE[#Vars]}
F-recordFreeOption[FREE, #key, ok.#[ok]]
→ 
{#env; "$Vars": LIST_VARIABLE[(#key; #Vars)]}
#[OK]
;

{#env}
F-recordFreeOption[$[NotMatch, FREE, #option], #key, ok.#[ok]] →
    {#env}#[OK]
;


///////////////////////////////////////////////////////////////////////////////////////////////////
// Match term against pattern.
//
// Goes to some trouble to match the body of a pattern before the properties.

// Delayed variant.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-then-Pattern[OK_SORT, PASS, Pattern-Stage, Reified_Term, Text, Text, $Boolean, $Boolean, Text, ok::OK_SORT.Text] :: Text;

{#env}
F-then-Pattern[OK, #pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok.#[ok]] 
→ 
{#env}
F-Pattern[#pass, #stage, #Pattern, #sink, #setup, #needed, #unique, #term, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Pattern[PASS, Pattern-Stage, Reified_Term, Text, Text, $Boolean, $Boolean, Text, ok::OK_SORT.Text] :: Text;

// Pattern {#REF} prefix: create reference variable (if used).
Pattern-PropertyRef[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern[#pass, #stage, PROPERTY-REF[#Ref, #Use, #Pattern], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
$[{#env}IfDef, $[:,"Discard$",#Ref],
 $[{#env}IfDef, $[:,"Comparable$",#Ref],
  {#env} F-Pattern[#pass, #stage, #Pattern, sink, #setup, $True, #unique, term, ok.F-then-Pattern-Ref[ok, $[:,"MetaVar$",#Ref], sink, term, o2.#[o2]]],
  {#env} F-Pattern[#pass, #stage, #Pattern, sink, #setup, #needed, #unique, term, ok.#[ok]]],
 {#env} F-Pattern[#pass, #stage, #Pattern, sink, #setup, $True, #unique, term, ok.F-then-Pattern-Ref[ok, $[:,"MetaVar$",#Ref], sink, term, o2.#[o2]]]]
;

// Pattern {KEY:VALUE} prefix: extract property and match pattern.
Pattern-Property[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern[#pass, #stage, PROPERTY[#Key, #Value, #Pattern], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
{#env}
F-Pattern[#pass, #stage, #Pattern, sink, #setup, $True, #unique, term, ok.F-then-Pattern-Property[ok, #pass, sink, term, #Key, #Value, o2.#[o2]]]
;

// Pattern {¬ KEY} prefix: extract property and check for absence.
Pattern-NotProperty[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern[#pass, #stage, PROPERTY-NOT[#Key, #Pattern], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
{#env}
F-Pattern[#pass, #stage, #Pattern, sink, #setup, $True, #unique, term, ok.F-then-Pattern-Not-Property[ok, sink, term, #Key, o2.#[o2]]]
;

// Pattern Symbol[Binders...]: advances the stage.
//
// - DISPATCH stage: ignore function application itself and advance to case generation.
Pattern-Construction-Dispatch[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern[#pass, DISPATCH[#Name,#Options,#SortName], CONSTRUCTION[#kind,#Symbol, (#Binder1;#Binders)], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
{#env}
F-PatternBinder[#pass, CASE[#Name,#Options,#SortName], #Binder1, sink, %n⟪« #setup »ASSERT(«sink»->context, !strcmp(SYMBOL(«term»), «STRING[#Symbol]»));
⟫, #unique, term, 0, 0, o2.F-then-PatternBinders[o2, #pass, #Binders, sink, #unique, term, 1, ok.#[ok]]]
;

Pattern-Construction-NoBinders-Dispatch[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern[#pass, DISPATCH[#Name,#Options,#SortName], CONSTRUCTION[#kind,#Symbol, ()], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
{#env}
F-Pattern[#pass, CASE[#Name,#Options,#SortName], CONSTRUCTION[#kind,#Symbol, ()], sink, %n⟪« #setup »ASSERT(«sink»->context, !strcmp(SYMBOL(«term»), «STRING[#Symbol]»));
⟫, $False, #unique, term, ok.#[ok]]
;

// - CASE stage: emit case check and proceed normally.
Pattern-Construction-Case[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern[#pass, CASE[#Name,#Options,#SortName], CONSTRUCTION[#kind,#Symbol, #Binders], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
%n⟪« F-Pattern-Open[#pass] »case « EnumTag[#Symbol] »: {⟦ /* Function «COMMENT_TOKEN[#Name]» case «COMMENT_TOKEN[#Symbol]» */
« #setup »ASSERT(«sink»->context, !strcmp(SYMBOL(«term»), «STRING[#Symbol]»));
« {#env} F-Options[#Options, ok.F-then-PatternBinders[ok, #pass, #Binders, sink, #unique, term, 0, ok.#[ok]]] »
return 1;⟧
⟫
;

// - MATCH stage: check symbol and then process Binders.
Pattern-Construction-Match[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern[#pass, MATCH, CONSTRUCTION[#kind,#Symbol, #Binders], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
%n⟪« #setup »ASSERT(«sink»->context, !strcmp(SYMBOL(«term»), «STRING[#Symbol]»));
« {#env} F-then-PatternBinders[OK, #pass, #Binders, sink, #unique, term, 0, ok.#[ok]] »⟫
;

// - SUBMATCH stage: force, check, and process argument Binders.
Pattern-Construction-SubMatch[Free[sink::Text, term::Text, parent::Text]]
:
{#env; term:SUB[parent, #i, #linked]}
F-Pattern[#pass, SUBMATCH, CONSTRUCTION[#kind,#Symbol, #Binders], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
%n⟪« #setup »FORCE(«sink»->context, «term»); SUB(«parent», «INTEGER[#i]») = «term»;
if (strcmp(SYMBOL(«term»), «STRING[#Symbol]»)) {«{#env}F-fail-cleanup[sink]» break;}
« {#env} F-then-PatternBinders[OK, #pass, #Binders, sink, #unique, term, 0, ok.#[ok]] »
⟫
;

// Pattern "Literal": assume that the literal is there...
Pattern-Literal[Free[sink::Text]]
:
{#env}
F-Pattern[#pass, #stage, LITERAL[#Literal, #Type], sink, #setup, #needed, #unique, #term, ok.#[ok]]
→
%n⟪/* Ignoring literal «STRING[#Literal]» */
« If[#needed,#setup,%n⟨⟩] »« {#env} #[OK] »⟫
;

// SUBMATCH stage, pattern is free variable (outside meta-application): record the variable.  
Pattern-Variable-Free[Free[variable::Reified_Variable, sink::Text, term::Text, parent::Text]]
:
{#env; variable : FREE; term:SUB[parent, #i, #linked]}
F-Pattern[#pass, SUBMATCH, VARIABLE-USE[variable], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
%n⟪« #setup »FORCE(«sink»->context, «term»); SUB(«parent», «INTEGER[#i]») = «term»; Variable «variable» = linkVariable(«sink»->context, VARIABLE(«term»)); 
« {#env} #[OK] »⟫
;

// SUBMATCH stage, Pattern is bound variable (outside meta-application).
Pattern-Variable-Bound[Free[variable,sink,term,parent],Discard[#pass,#kind,#needed,#unique,#linked]]
:
{#env; variable : $[NotMatch, FREE, #kind]; term:SUB[parent, #i, #linked]}
F-Pattern[#pass, SUBMATCH, VARIABLE-USE[variable], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
%n⟪« #setup »FORCE(«sink»->context, «term»); SUB(«parent», «INTEGER[#i]») = «term»; if («variable» != VARIABLE(«term»)) {«{#env}F-fail-cleanup[sink]» break;}
« {#env} #[OK] »⟫
;

// Pattern is variable but before options have been processed.

// - first variable.
Pattern-Variable-Case1[Discard[#needed,#unique]]
:
{#env}
F-Pattern[FIRST, CASE[#Name,#Options,#SortName], VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok.#[ok]]
→
%n⟪case « EnumVar[#SortName] »: {⟦
« {#env} F-Pattern-Variable-Case[#Name, #Options, #variable, #sink, #setup, #term, ok.#[ok]] »⟧⟫
;
// - subsequent variable (always follows another variable).
Pattern-Variable-Case2[Discard[#SortName,#needed,#unique]]
:
{#env}
F-Pattern[SECOND, CASE[#Name,#Options,#SortName], VARIABLE-USE[#variable], #sink, #setup, #needed, #unique, #term, ok.#[ok]]
→
{#env}
F-Pattern-Variable-Case[#Name, #Options, #variable, #sink, #setup, #term, ok.#[ok]]
;

// Pattern $[...]: 
Pattern-Evaluator[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern[#pass, #stage, EVALUATOR[#Primitive, #Patterns, #Options], sink, #setup, #needed, #unique, term, ok.#[ok]]
→
%n⟪« #setup »« {#env} E-Pattern[Primitive[#Primitive], #Patterns, #pass, #stage, sink, term, ok.#[ok]] »⟫
;

// Pattern #MetaVar[MetaArg...]: store in meta-variable and record argument variables.
Pattern-MetaApplication[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern[#pass, #stage, META-APPLICATION[#MetaVar, #MetaArgs, #Use], sink, #setup, #needed, #unique, term, ok.#[ok]]
→ // No need to LINK term because it's just an alias.
//$[If, $[{#env}IfDef, $[:,"Discard$",#MetaVar], #needed, $True],
	{#env}F-Pattern-MetaArgs-Norm[{#env}F-Pattern-NeedNorm[#MetaVar,#Use], #MetaVar, #MetaArgs, sink, #setup, term, ok.#[ok]]
  	// Not needed: skip.
//  	%n⟪
//« {#env} #[OK] »⟫]
;

// Helper for generating environment reference meta-variable.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-then-Pattern-Ref[OK_SORT, $String, Text, Text, ok::OK_SORT.Text] :: Text;

-[Fresh[namedP::Text, varP::Text], Data[#RefCookie]]
:
{#env; "$Refs": LIST_STRING[#refs]}
F-then-Pattern-Ref[OK, #RefCookie, #sink, #term, ok.#[ok]]
→
%n⟪
NamedPropertyLink «namedP» = LINK_NamedPropertyLink(«#sink»->context, NAMED_PROPERTIES(«#term»));
VariablePropertyLink «varP» = LINK_VariablePropertyLink(«#sink»->context, VARIABLE_PROPERTIES(«#term»));
« {#env;  #RefCookie : PROPERTY_VARIABLE[namedP, varP]; "$Refs":LIST_STRING[(#RefCookie;#refs)]} #[OK] »⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-then-Pattern-Property[OK_SORT, PASS, Text, Text, Reified_Term, Reified_Term, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text, term::Text], Fresh[value::Text]]
:
{#env}
F-then-Pattern-Property[OK, #pass, sink, term, #Key, #Value, ok.#[ok]]
→
%n⟪« {#env} F-set-value[#Key, sink, term, value] »if (!«value») {«{#env}F-fail-cleanup[sink]» break;} 
LINK(«sink»->context, «value»);« {#env} F-Pattern[#pass, SUBMATCH, #Value, sink, %n⟨⟩, $False, $True, value, ok.#[ok]] »⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-set-value[Reified_Term, Text, Text, Text] :: Text;

{#env}
F-set-value[META-APPLICATION[#MetaVar, #Args,#count], #sink, #term, #value] 
→ 
%n⟪Term «#value» = PROPERTY(«#sink»->context, «#term», « {#env}MetaVar[#MetaVar] »); permitUnusedTerm(«#value»);
⟫
;

{#env}
F-set-value[LITERAL[#Literal, #Sort], #sink, #term, #value] 
→ 
%n⟪Term «#value» = NAMED_PROPERTY(«#sink»->context, «#term», «STRING[#Literal]»); permitUnusedTerm(«#value»);
⟫
;

{#env}
F-set-value[CONSTRUCTION[#kind,#Symbol, #Binders], #sink, #term, #value] 
→ 
%n⟪Term «#value» = NAMED_PROPERTY(«#sink»->context, «#term», «STRING[#Symbol]»); permitUnusedTerm(«#value»);
⟫
;

-[Free[variable::Reified_Variable]]
:
{#env}
F-set-value[VARIABLE-USE[variable], #sink, #term, #value] 
→ 
%n⟪Term «#value» = VARIABLE_PROPERTY(«#term», «$[Show, variable]»); permitUnusedTerm(«#value»);
⟫ 
;

F-Pattern-Open[PASS] :: Text;

F-Pattern-Open[FIRST] → %n⟪⟫; 
F-Pattern-Open[SECOND] → %n⟪break;
}
⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-then-Pattern-Not-Property[OK_SORT, Text, Text, Reified_Term, ok::OK_SORT.Text] :: Text;

-[Fresh[value::Text]]
:
{#env}
F-then-Pattern-Not-Property[OK, sink, term, #Key, ok.#[ok]]
→
%n⟪« {#env} F-set-value[#Key, sink, term, value] »if (!«value») {«{#env}F-fail-cleanup[sink]» break;}
LINK(«sink»->context, «value»);« {#env} #[OK] »⟫
;

// Helper for processing construction subterms.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-then-PatternBinders[OK_SORT, PASS, $List[Reified_Binder], Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

{#env}
F-then-PatternBinders[OK, #pass, #Binders, #sink, #unique, #term, #index, ok.#[ok]] 
→ 
{#env}
F-PatternBinders[#pass, #Binders, #sink, #unique, #term, #index, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-PatternBinders[PASS, $List[Reified_Binder], Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

// Pattern arguments [Binder,Binders...]
{#env}
F-PatternBinders[#pass, (#Binder;#Binders), #sink, #unique, #term, #index, ok.#[ok]]
→
{#env}
F-PatternBinder[#pass, SUBMATCH, #Binder, #sink, %n⟨⟩, #unique, #term, #index, 0, ok.F-then-PatternBinders[ok, #pass, #Binders, #sink, #unique, #term, $[Plus,#index,1], o2.#[o2]]]
;

// Pattern arguments []
{#env}
F-PatternBinders[#pass, (), #sink, #unique, #term, #index, ok.#[ok]]
→
{#env}
#[OK]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-PatternBinder[PASS, Pattern-Stage, Reified_Binder, Text, Text, $Boolean, Text, $Numeric, $Numeric, ok::OK_SORT.Text] :: Text;

// Pattern argument b . Binder:
{#env}
F-PatternBinder[#pass, #stage, BINDER[#promisc, #guard, #depth, #sort, #occs, b . #Binder[b]], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
→
{#env}
F-PatternBinder1[#occs, NOTHING, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
;

-[Free[sink::Text, term::Text]]
:
{#env}
F-PatternBinder[#pass, #stage, ARGUMENT[#sort,#Pattern], #sink, #code, #unique, term, #i, #j, ok.#[ok]]
→
{#env}
F-PatternSub[#Pattern, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, term, #i, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-PatternBinder1[$List[Reified_Occurrence], Meta-Occurrence, PASS, Pattern-Stage, Reified_Promiscuity, binder : Reified_Variable . Reified_Binder, Text, Text, $Boolean, Text, $Numeric, $Numeric, ok::OK_SORT.Text] :: Text;

// - if binder occurs in exactly one meta-application then record a BinderUnique$mv$k$promisc cookie for that meta-application position -
{#env}
F-PatternBinder1[(META-USE[#mv,#k];#occs), NOTHING, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
→
{#env}
F-PatternBinder1[#occs, UNIQUE[$[:,"BinderUnique$",#mv,"$",$[FormatNumber, #k],"$",PromiscuityString[#promisc]]], #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
;

{#env}
F-PatternBinder1[(OTHER;#occs), #state, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
→
{#env}
F-PatternBinder2[NOTHING, #pass, #stage, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
//%n⟪/* Ignoring literal «COMMENT_TOKEN[#Literal]» */
//« If[#needed,#setup,%n⟨⟩] »« {#env} #[OK] »⟫
;

{#env}
F-PatternBinder1[(), #cookie, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
→
{#env}
F-PatternBinder2[#cookie, #pass, #stage, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
;


{#env}
F-PatternBinder1[(META-USE[#mv,#k];#occs), UNIQUE[#cookie], #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
→
{#env}
F-PatternBinder2[NOTHING, #pass, #stage, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
;

-[Fallback]
:
{#env}
F-PatternBinder1[#occs, #cookie, #pass, #stage, #promisc, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
→
{#env}
F-PatternBinder2[NOTHING, #pass, #stage, b . #Binder[b], #sink, #code, #unique, #term, #i, #j, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-PatternBinder2[Meta-Occurrence, PASS, Pattern-Stage, binder : Reified_Variable . Reified_Binder, Text, Text, $Boolean, Text, $Numeric, $Numeric, ok::OK_SORT.Text] :: Text;

// - then generate and record cookie, binder name, and promiscuity (and recurse).
-[Free[term::Text], Fresh[v::Text]]
:
{#env; "$Vars":LIST_VARIABLE[#Vars]}
F-PatternBinder2[UNIQUE[#cookie], #pass, #stage, b . #Binder[b], #sink, #code, #unique, term, #i, #j, ok.#[ok]]
→
{#env; v : BOUND; #cookie : VARIABLE[v]; "$Vars":LIST_VARIABLE[(v; #Vars)]}
F-PatternBinder[#pass, #stage, #Binder[v], #sink, %n⟪« #code »Variable «v» = linkVariable(«#sink»->context, BINDER(«term»,«INTEGER[#i]»,«INTEGER[#j]»)); if (« term »_count <= 1) UNBIND(«v»);
⟫, #unique, term, #i, $[Plus,#j,1], ok.#[ok]]
;

-[Free[term::Text], Fresh[v::Text]]
:
{#env; "$Vars":LIST_VARIABLE[#Vars]}
F-PatternBinder2[NOTHING, #pass, #stage, b . #Binder[b], #sink, #code, #unique, term, #i, #j, ok.#[ok]]
→
{#env; v : BOUND; "$Vars":LIST_VARIABLE[(v; #Vars)]}
F-PatternBinder[#pass, #stage, #Binder[v], #sink, %n⟪« #code »Variable «v» = linkVariable(«#sink»->context, BINDER(«term»,«INTEGER[#i]»,«INTEGER[#j]»)); if (« term »_count <= 1) UNBIND(«v»);
⟫, #unique, term, #i, $[Plus,#j,1], ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Pattern-Variable-Case[$String, $List[Reified_Option], Text, Text, Text, Text, ok::OK_SORT.Text] :: Text;

// - use a do block so failed test can break out.
-[Free[sink::Text, term::Text]]:
{#env}
F-Pattern-Variable-Case[#Name, #Options, #variable, sink, #setup, term, ok.#[ok]]
→
%n⟪do {⟦
« #setup »« {#env} F-Options[#Options, ok.F-then-Pattern-Variable-Use[ok, #Name, sink, #variable, term, o2.#[o2]]] »
return 1;⟧
} while(0);
⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-then-Pattern-Variable-Use[OK_SORT, $String, Text, Text, Text, ok::OK_SORT.Text] :: Text;


// - bound variable
-[Free[sink::Text, variable::Reified_Variable, term::Text]]
:
{#env}
F-then-Pattern-Variable-Use[OK, #Name, sink, variable, term, ok.#[ok]]
→
{#env}
F-then-Pattern-Variable-Use2[$[{#env}Get[VARIABLE_ENTRY], variable, FREE], #Name, sink, variable, term, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-then-Pattern-Variable-Use2[VARIABLE_ENTRY, $String, Text, Text, Text, ok::OK_SORT.Text] :: Text;

// - bound variable
-[Free[sink::Text, variable::Reified_Variable, term::Text]]
:
{#env}
F-then-Pattern-Variable-Use2[BOUND, #Name, sink, variable, term, ok.#[ok]]
→
%n⟪/* Function «COMMENT_TOKEN[#Name]» case for pattern bound variable. */
if («variable» != VARIABLE(«term»)) { «{#env}F-fail-cleanup[sink]» break;}
«{#env}#[OK]»⟫
;

// - free variable case is always last
-[Free[sink::Text, variable::Reified_Variable, term::Text]]
:
{#env}
F-then-Pattern-Variable-Use2[FREE, #Name, sink, variable, term, ok.#[ok]]
→
%n⟪/* Function «COMMENT_TOKEN[#Name]» fall-back case for free variable */
Variable «variable» = linkVariable(«sink»->context, VARIABLE(«term»)); 
«{#env}#[OK]»⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-Pattern-NeedNorm[$String, Reified_Use] :: $Boolean;

{#env}F-Pattern-NeedNorm[#MetaVar, USE[#Count]] 
→ 
$[{#env}IfDef, $[:,"Copy$",#MetaVar], $True, $[{#env}IfDef, $[:,"Data$",#MetaVar], $True, $False]]
;

{#env}F-Pattern-NeedNorm[#MetaVar, DISCARD] 
→ 
$False
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-Pattern-MetaArgs-Norm[$Boolean, $String, $List[Reified_Binder], Text, Text, Text, ok::OK_SORT.Text] :: Text;

-[Free[term::Text, parent::Text]]
:
{#env; term : SUB[parent, #i, $True]}
F-Pattern-MetaArgs-Norm[$True, #MetaVar, #MetaArgs, #sink, #setup, term, ok.#[ok]]
→ 
%n⟪« #setup »UNLINK_SUB(«#sink»->context, «parent»,  «INTEGER[#i]»); NORMALIZE(«#sink»->context, «term»); SUB(«parent»,  «INTEGER[#i]») = LINK(«#sink»->context, «term»);
«{#env}F-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, #sink, term, ok.#[ok]]»⟫
;

-[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern-MetaArgs-Norm[$False, #MetaVar, #MetaArgs, sink, #setup, term, ok.#[ok]]
→
%n⟪« #setup »«{#env}F-Pattern-MetaArgs-bind[$[:,"MetaVar$",#MetaVar], #MetaVar, #MetaArgs, sink, term, ok.#[ok]] »⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-Pattern-MetaArgs-Copy[$String, $List[Reified_Binder], Text, Text, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text, term::Text]]
:
{#env}
F-Pattern-MetaArgs-Copy[#MetaVar, #MetaArgs, sink, term, ok.#[ok]]
→ 
{#env}
F-Pattern-MetaArgs-bind[$[:,"MetaVar$",#MetaVar], #MetaVar, #MetaArgs, sink, term, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Pattern-MetaArgs-bind[$String, $String, $List[Reified_Binder], Text, Text, ok::OK_SORT.Text] :: Text;

-[Free[term::Text]]
:
{#env}
F-Pattern-MetaArgs-bind[#MetaVarCookie, #MetaVar, #MetaArgs, #sink, term, ok.#[ok]]
→
%n⟪/* «term» = &« COMMENT_TOKEN[#MetaVar] » */
« {#env; #MetaVarCookie : VARIABLE[term]} F-Pattern-MetaArgs[#MetaVar, #MetaArgs, 0, #sink, term, ok.#[ok]] »⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Pattern-MetaArgs[$String, $List[Reified_Binder], $Numeric, Text, Text, ok::OK_SORT.Text] :: Text;

// Helper for meta-application variable .
{#env}
F-Pattern-MetaArgs[#MetaVar, (), #index, #sink, #term, ok.#[ok]]
→
{#env}
F-Pattern-MetaArgs-arity[$[:,#MetaVar,"$arity"], #index, ok.#[ok]]
;

-[Free[sink::Text, term::Text, variable::Text]]
:
{#env}
F-Pattern-MetaArgs[#MetaVar, (ARGUMENT[#sort, VARIABLE-USE[variable]]; #MetaArgs), #index, sink, term, ok.#[ok]]
→
{#env}
F-Pattern-MetaArgs-variable[$[:,#MetaVar,"$",$[FormatNumber, #index]], $[:,"Reuse$",#MetaVar,"$",$[FormatNumber, #index]], variable, #MetaVar, #MetaArgs, #index, sink, term, ok.#[ok]]
;

//-[Free[sink::Text, term::Text, variable::Text]]
//:
//{#env}
//F-Pattern-MetaArgs[#MetaVar, (ARGUMENT[#sort, META-REQUIRED-VARIABLE[variable]]; #MetaArgs), #index, sink, term, ok.#[ok]]
//→
//{#env}
//F-Pattern-MetaArgs-variable[$[:,#MetaVar,"$",$[FormatNumber, #index]], $[:,"Reuse$",#MetaVar,"$",$[FormatNumber, #index]], variable, #MetaVar, #MetaArgs, #index, sink, term, ok.#[ok]]
//;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-Pattern-MetaArgs-arity[$String, $Numeric, ok::OK_SORT.Text] :: Text;

-[Data[#MetaVarArity]]
:
{#env}
F-Pattern-MetaArgs-arity[#MetaVarArity, #arity, ok.#[ok]]
→
{#env; #MetaVarArity : NUM_VALUE[#arity]}
#[OK]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Pattern-MetaArgs-variable[$String, $String, Reified_Variable, $String, $List[Reified_Binder], $Numeric, Text, Text, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text, term::Text, variable::Text]]
:
{#env}
F-Pattern-MetaArgs-variable[#MetaVarIndex, #ReuseVar, variable, #MetaVar, #MetaArgs, #index, sink, term, ok.#[ok]]
→
{#env; #MetaVarIndex : VARIABLE[variable]}
F-Pattern-MetaArgs-variable2[$[{#env}Get[STRING_ENTRY], #ReuseVar, NO], variable, #MetaVar, #MetaArgs, #index, sink, term, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-Pattern-MetaArgs-variable2[STRING_ENTRY, Reified_Variable, $String, $List[Reified_Binder], $Numeric, Text, Text, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text, term::Text, variable::Text]]
:
{#env}
F-Pattern-MetaArgs-variable2[NO, variable, #MetaVar, #MetaArgs, #index, sink, term, ok.#[ok]]
→
{#env}
F-Pattern-MetaArgs[#MetaVar, #MetaArgs, $[Plus,#index,1], sink, term, ok.#[ok]]
;

-[Free[reuse::Text, sink::Text, term::Text, variable::Text]]
:
{#env}
F-Pattern-MetaArgs-variable2[VARIABLE[reuse], variable, #MetaVar, #MetaArgs, #index, sink, term, ok.#[ok]]
→
%n⟪Variable «reuse» = «variable»; permitUnusedVariable(«reuse»);
« {#env} F-Pattern-MetaArgs[#MetaVar, #MetaArgs, $[Plus,#index,1], sink, term, ok.#[ok]] »⟫
;

// Extract sub. Determine if linking is needed when meta var is not just an intermediary construction.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-PatternSub[Reified_Term, PASS, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

-[Free[sink::Text, term::Text]]
:
{#env}
F-PatternSub[PROPERTY-REF[#Ref, #Use, #Term], #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]] 
→ 
{#env}
F-PatternSub[#Term,  #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]]
;

-[Free[sink::Text, term::Text]]
:
{#env}
F-PatternSub[PROPERTY[#Key, #Value, #Term], #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]] 
→ 
{#env}
F-PatternSub[#Term, #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]]
;

-[Free[sink::Text, term::Text]]
:
{#env}
F-PatternSub[PROPERTY-NOT[#Key, #Term], #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]] 
→ 
{#env}
F-PatternSub[#Term, #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]]
;

-[Free[sink::Text, term::Text]]
:
{#env}
F-PatternSub[CONSTRUCTION[#kind,#Symbol, #Binder], #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]] 
→ 
{#env}
F-PatternSub2[$False, #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]]
;

-[Free[sink::Text, term::Text]]
:
{#env}
F-PatternSub[LITERAL[#Value, #Sort], #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]] 
→ 
{#env}
F-PatternSub2[$False, #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]]
;

-[Free[sink::Text, term::Text]]
:
{#env}
F-PatternSub[VARIABLE-USE[#Variable], #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]] 
→ 
{#env}
F-PatternSub2[$False, #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]]
;

-[Free[sink::Text, term::Text]]
:
{#env}
F-PatternSub[META-APPLICATION[#MetaVar, #Binders, USE[#Count]], #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]] 
→
{#env}
F-PatternSub2[$True, #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]]
;

-[Free[sink::Text, term::Text]]
:
{#env}
F-PatternSub[META-APPLICATION[#MetaVar, #Binders, DISCARD], #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]] 
→
{#env}
F-PatternSub2[$False, #pass, #stage, #sort, #Pattern, sink, #code, #unique, term, #i, ok.#[ok]]
;

-[Free[term::Text]]
:
{#env}
F-PatternSub[EVALUATOR[#Primitive, #Patterns, #Options], #pass, #stage, #sort, #Pattern, #sink, #code, #unique, term, #i, ok.#[ok]] 
→ 
{#env}
F-PatternSub2[$False, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, term, #i, ok.#[ok]]
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-PatternSub2[$Boolean<!-- Whether to link sub -->, PASS, Pattern-Stage, Reified_Sort, Reified_Term, Text, Text, $Boolean, Text, $Numeric, ok::OK_SORT.Text] :: Text;

-[Free[term::Text], Fresh[sub::Reified_Variable]]
:
{#env; "$Subs": LIST_VARIABLE[#subs]}
F-PatternSub2[$True, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, term, #i, ok.#[ok]] 
→ 
{#env; sub: SUB[term, #i, $True]; "$Subs":LIST_VARIABLE[(sub;#subs)]}
F-Pattern[#pass, #stage, #Pattern, #sink, %n⟪« #code »Term «sub» = LINK(«#sink»->context, SUB(«term», «INTEGER[#i]»)); int «sub»_count = «term»_count*LINK_COUNT(«sub»); permitUnusedInt(«sub»_count);
«D-check-sort[#sink, sub, #sort]»⟫, $True, #unique, sub, ok.#[ok]]
;

-[Free[term::Text], Fresh[sub::Text]]
:
{#env}
F-PatternSub2[$False, #pass, #stage, #sort, #Pattern, #sink, #code, #unique, term, #i, ok.#[ok]] 
→
{#env; sub: SUB[term, #i, $False]}
F-Pattern[#pass, #stage, #Pattern, #sink, %n⟪« #code »Term «sub» = SUB(«term», «INTEGER[#i]»); int «sub»_count = «term»_count*LINK_COUNT(«sub»); permitUnusedInt(«sub»_count);
«D-check-sort[#sink, sub, #sort]»⟫, $False, #unique, sub, ok.#[ok]]
;


///////////////////////////////////////////////////////////////////////////////////////////////////
// Match term against pattern.
//
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-then-Send[OK_SORT, Text, Reified_Term, Text] :: Text;

{#env}
F-then-Send[OK, #term, #Contractum, #sink]
→
%n⟪UNLINK(«#sink»->context, «#term»);
« {#env} T-send[#Contractum, #sink] »«{#env}F-unlink-refs[#sink, $[{#env}Get[STRING_ENTRY], "$Refs"]]»«{#env}F-unlink-var[#sink, $[{#env}Get[STRING_ENTRY], "$Vars"]]»
⟫
;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Cleanup
//

// Cleanup after pattern failure.
{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-fail-cleanup[Text] :: Text;

{#env}
F-fail-cleanup[#sink] →
    %n⟪«F-unlink[#sink, $[{#env}Get[STRING_ENTRY], "$Subs"]]»«{#env}F-unlink-refs[#sink, $[{#env}Get[STRING_ENTRY], "$Refs"]]»«F-unlink-var[#sink, $[{#env}Get[STRING_ENTRY], "$Vars"]]»⟫
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-unlink-refs[Text, STRING_ENTRY] :: Text;

{#env}
F-unlink-refs[#sink, LIST_STRING[#Refs]] 
→ 
{#env}
F-unlink-refs2[#sink, #Refs] 
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}F-unlink-refs2[Text, $List[$String]] :: Text;

{#env}F-unlink-refs2[#sink, ()] 
→ 
%n⟪⟫
;

{#env}
F-unlink-refs2[#sink, (#RefCookie; #refs)] 
→ 
{#env}
F-unlink-refs3[#sink, $[{#env}Get[STRING_ENTRY], #RefCookie], #refs] 
;

{$String:STRING_ENTRY; Reified_Variable:VARIABLE_ENTRY}
F-unlink-refs3[Text, STRING_ENTRY, $List[$String]] :: Text;

{#env}
F-unlink-refs3[#sink,  PROPERTY_VARIABLE[#namedP, #varP], #refs] 
→ 
%n⟪UNLINK_NamedPropertyLink(«#sink»->context, «#namedP»); 
UNLINK_VariablePropertyLink(«#sink»->context, «#varP»);«{#env}F-unlink-refs2[#sink, #refs]»⟫
;

F-unlink[Text, STRING_ENTRY] :: Text;

F-unlink[#sink, LIST_VARIABLE[#Refs]] → 
    F-unlink2[#sink, #Refs] 
;

F-unlink2[Text, $List[Text]] :: Text;

F-unlink2[#sink, ()]  → 
    %n⟪⟫
;

-[Free[sink::Text, v::Text]]
: 
F-unlink2[sink, (v;#vs)] → 
    %n⟪
UNLINK(«sink»->context, «v»);«F-unlink2[sink, #vs]»⟫
;

F-unlink-var[Text, STRING_ENTRY] :: Text;

F-unlink-var[#sink, LIST_VARIABLE[#Refs]] → 
    F-unlink2-var[#sink, #Refs] 
;

F-unlink2-var[Text, $List[Text]] :: Text;

F-unlink2-var[#sink, ()]  → 
    %n⟪⟫
;

-[Free[sink::Text, v::Text]]
: 
F-unlink2-var[sink, (v;#vs)] → 
    %n⟪
unlinkVariable(«sink»->context, «v»);«F-unlink2-var[sink, #vs]»⟫
;


///////////////////////////////////////////////////////////////////////////////////////////////////
)] //F

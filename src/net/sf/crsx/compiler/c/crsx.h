// Copyright (c) 2010, 2014 IBM Corporation.
// $Id: crsx.h,v 3.64 2014/02/05 23:02:01 krisrose Exp $
#ifndef _CRSX_H
# define _CRSX_H
#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
// HEADER FILE WITH SORT-INDEPENDENT DECLARATIONS FOR GENERATING CRSX TERMS IN C
//
// Include this header file with programs that include fragments generated by rules.crs.
///////////////////////////////////////////////////////////////////////////////////////////////////

// Includes.
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <assert.h>
#include <sys/types.h>
#include <alloca.h>
#include <ctype.h>
#include <math.h>
#include <limits.h>
#ifndef SSIZE_MAX
# include <bits/local_lim.h>
#endif

// All the pointer types declared forward.
typedef struct _Context *Context;
typedef struct _Variable *Variable;
typedef struct _Term *Term;
typedef struct _VariableUse *VariableUse;
typedef struct _Construction *Construction;
typedef struct _Literal *Literal;
typedef struct _ConstructionDescriptor *ConstructionDescriptor;
typedef struct _SortDescriptor *SortDescriptor;
typedef struct _Sink *Sink;
typedef struct _SubstitutionFrame *SubstitutionFrame;
typedef struct _Properties *Properties;
typedef struct _NamedPropertyLink *NamedPropertyLink;
typedef struct _VariablePropertyLink *VariablePropertyLink;
typedef struct _Variables *Variables;
typedef struct _VariableSet *VariableSet;
typedef struct _VariableSetLink *VariableSetLink;
typedef struct _VariableMap *VariableMap;
typedef struct _VariableMapLink *VariableMapLink;
typedef struct _VariableNameMapLink *VariableNameMapLink;
typedef struct _Hashset* Hashset;
typedef struct _Hashset2* Hashset2;
typedef struct _Buffer *Buffer;
typedef struct _BufferEntry *BufferEntry;
typedef struct _BufferSegment *BufferSegment;
typedef const char *PooledString;

///////////////////////////////////////////////////////////////////////////////////////////////////
// IDIOMS

// Context.

#define CONS_POOL_MAX_SIZE_SIZE 32
#define CONS_POOL_MAX_SIZE 4096

#define MAX_BUFFER_POOL_SIZE 32
#define MAX_SEGMENT_POOL_SIZE 2048

#define HASHSET_MAX_NBITS 6
#define HASHSET_MAX_PER_NBITS 256

struct _Context
{
    unsigned int stamp;   // satisfy old C compilers and provide variable identity
#ifndef OMIT_TIMESPEC
    struct timespec time;  // time when compute started.
#endif
    unsigned int depth;   // monitor recursion depth
    Hashset2 env;           // General environment.

    int poolRefCount;
    Hashset2 stringPool;    // Set of dynamic PooledString
    Hashset2 keyPool;       // Set of static PooledString

    Construction** consPool; // Array of Construction
    ssize_t* consPoolSize;

    Buffer bufferPool[MAX_BUFFER_POOL_SIZE];
    ssize_t bufferPoolSize;

    BufferSegment segmentPool;
    ssize_t segmentPoolSize;

    Hashset* hashsetPool[HASHSET_MAX_NBITS];
    ssize_t hashsetPoolSize[HASHSET_MAX_NBITS];

    PooledString str_filelocation;
    PooledString str_linelocation;
    PooledString str_columnlocation;

    Variable functional;       // unique global bound variable representing all functional binders.
    VariableUse functionalUse; // Variable use of the functional variable.

    // Spilled parameters
    void* crsxArg[96];

    // Named properties indexing threshold
    unsigned int indexThreshold;

    unsigned int fv_enabled    : 1; // Whether the free variable optimization is on.
    unsigned int debugsteps    : 1;
    unsigned int debugtrace    : 1;
    unsigned int debugviz      : 1;
    unsigned int debugliterals : 1;
    unsigned int strict        : 1; // Execute in strict mode?

#ifdef CRSX_ENABLE_PROFILING
    unsigned int profiling : 1; // user-defined program profiling
    unsigned int internal : 1; // internal profiling

#endif
};

// Call this function before using a Context:
extern void initCRSXContext(Context context);

// Debugging and profiling
//
#ifdef DEBUG
# ifndef DEBUGENV
#  define DEBUGENV(NAME,CMD) if (getenv(NAME)) CMD
# endif
# ifndef DEBUGCOND
#  define DEBUGCOND(COND,CMD) if (COND) CMD
# endif
# ifndef DEBUGF
#  define DEBUGF(CONTEXT,...) printf(__VA_ARGS__)
# endif
# ifndef DEBUGT
#  define DEBUGT(CONTEXT,NESTING,TERM) ppt(CONTEXT, NESTING, TERM)
# endif
# ifndef DEBUGX
#  define DEBUGX(X) X
# endif
# define CRSX_CHECK(CONTEXT,TERM) noop()
#else
# ifndef DEBUGENV
#  define DEBUGENV(NAME,CMD) noop()
# endif
# ifndef DEBUGCOND
#  define DEBUGCOND(COND,CMD) noop()
# endif
# ifndef DEBUGF
#  define DEBUGF(CONTEXT,FMT,...) noop()
# endif
# ifndef DEBUGT
#  define DEBUGT(CONTEXT,PREFIX,TERM) noop()
# endif
# ifndef DEBUGX
#  define DEBUGX(X) noop()
# endif
# define CRSX_CHECK(CONTEXT,TERM) noop()
#endif
#ifndef DEBUGRULE
# define DEBUGRULE(CONTEXT,RULE) DEBUGF(CONTEXT, "//%s\n", RULE)
#endif


#ifdef CRSX_ENABLE_PROFILING

extern void crsxpInstrumentEnter(Context context, Variable id, char* name);
extern void crsxpInstrumentExit(Context context, Variable id);

#ifndef PROFILE_ENTER
#define PROFILE_ENTER(CONTEXT,ID,NAME) crsxpInstrumentEnter(CONTEXT,ID,NAME)
#endif

#ifndef PROFILE_EXIT
#define PROFILE_EXIT(CONTEXT,ID) crsxpInstrumentExit(CONTEXT,ID)
#endif

#else

#ifndef PROFILE_ENTER
#define PROFILE_ENTER(CONTEXT,ID,NAME) noop()
#endif

#ifndef PROFILE_EXIT
#define PROFILE_EXIT(CONTEXT,ID) noop()
#endif

#endif

// Turn on profiling.
extern void enableProfiling(Context context);

// Returns elapsed time (in ms) since beginning of compute
extern long elapsed(Context context);

// Memory allocation.
//
// Usage:
//   struct MyStruct *p = ALLOCATE(context, sizeof(struct MyStruct));
//   struct MyStruct *localp = ALLOCA(context, sizeof(struct MyStruct)); // Use when localp cannot escape from the scope!
//   char *text = ALLOCATENF(context, max_size, "%s%d", some_string, some_int); // like snprintf
//   char *text = GLOBAL(context, "Existing String That Should Be Available Globally!");
// 
// The second form is only guaranteed to be available until the END OF THE CURRENT FRAME.
// 
// Define these before loading this header to not use naive defaults.
// The 'context' pointer will be passed as type Context with the value passed in as the initial Context.
// Allocated space may or may not be explicitly released.
//
// By default the macros map to the standard malloc(3) and alloca(3) functions.
//
#ifndef ALLOCATE
# define ALLOCATE(CONTEXT,SIZE) crsx_allocate((Context)CONTEXT,SIZE)
  extern void *crsx_allocate(Context context, size_t size);
#endif
//
#ifndef CALLOCATE
# define CALLOCATE(CONTEXT,SIZE) crsx_callocate((Context)CONTEXT,SIZE)
  extern void *crsx_callocate(Context context, size_t size);
#endif
//
#ifndef ALLOCATENF
# define ALLOCATENF(CONTEXT,MAXSIZE,...) stringnf(CONTEXT, MAXSIZE, __VA_ARGS__)
#endif
//
#ifndef REALLOCATE
# define REALLOCATE(CONTEXT,POINTER,SIZE) crsx_reallocate((Context)CONTEXT, POINTER, SIZE)
  extern void *crsx_reallocate(Context context, void *pointer, size_t size);
#endif
//
#ifndef FREE
# define FREE(CONTEXT,POINTER) crsx_free((Context)CONTEXT, POINTER)
  extern void crsx_free(Context context, void *pointer);
#endif
//
#ifndef ALLOCA
# define ALLOCA(CONTEXT,SIZE) alloca(SIZE)
#endif
//
#ifndef GLOBAL
# define GLOBAL(CONTEXT,STRING) makeKeyString(CONTEXT,STRING)
#endif

// STRING HELPERS.
//
// Note that all the string operations assume "zero-avoiding UTF-8", which is
// * Strings contain UTF-8 encoded Unicode without any '\0' bytes.
// * The U+0000 code point is encoded as 0xC0 0x80.
// * Internal utility functions use *byte* size and index parameters.

// FORMAT backs up $[Format, format, ...].
//
#ifndef FORMAT
# define FORMAT_BUFFER_SIZE 5000
# define FORMAT(CONTEXT,KIND,...) stringnf(CONTEXT, FORMAT_BUFFER_SIZE, __VA_ARGS__)
  // Low level formatting by default ignores KIND parameter!
#endif

// ALLOCATE a formatted string constant up to the specified maximum size.
// (Uses an internal ALLOCA to size followed by an ALLOCATE to the actual size.)
extern char *stringnf(Context context, const size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));

// Addref pools
extern void crsxAddPools(Context context);

// Release pools
extern void crsxReleasePools(Context context);

// Allocate copy of existing string on heap.
extern char *makeString(Context context, const char *src);

// Allocate copy of substring of existing string.
extern char *makeSubstring(Context context, const char *src, size_t first, size_t length);

// ALLOCATE strings corresponding to the $[Escape], $[Rescape], and $[Mangle], primitives. Does not deallocate src/term.
extern char *makeEscaped(Context context, const char *src);
extern char *makeRescaped(Context context, const char *src);
extern char *makeMangled(Context context, const char *src);
extern char *makeEncodePoint(Context context, unsigned int code);

// Allocate interned copy of existing string on heap.
extern PooledString makeKeyString(Context context, const char *src);

// Literals value initialization
extern void initLiterals();

// Static pooled literal table
extern PooledString literalsTable[];

// Number of static literals
extern size_t literalsCount;

// Constant term initialization
extern void initConstants();

// Allocate new global construction
extern Construction makeGlobalConstruction(ConstructionDescriptor desc);

// Hash code for term.
#define HASH_CODE(CONTEXT, TERM) termHashCode(CONTEXT, TERM, NULL)
typedef struct _VariableLink *VariableLink;
struct _VariableLink { VariableLink next; Variable variable; };
extern long long termHashCode(Context context, Term term, VariableLink deBruijn);

// Failure.
//
// ERRORF backs up $[Error[KIND], format, ...].
// NOTE: all internal errors use KIND=Crsx (no quotes).
//
#ifndef ERRORF
# define ERRORF(CONTEXT,KIND,...) errorf(CONTEXT, __VA_ARGS__)
  // Low level error reporting; by default ignores KIND parameter!
#endif
extern void *errorf(Context context, char *format, ...) __attribute__((format(printf, 2, 3)));

//
#ifndef FORGIVABLEERRORF
# define FORGIVABLEERRORF(CONTEXT,KIND,...) errorf(CONTEXT, __VA_ARGS__)
#endif

//
#ifndef CHECKF
# define CHECKF(CONTEXT,TEST,OK,KIND,...) (({ if (!(TEST)) ERRORF(CONTEXT,KIND,__VA_ARGS__); }), OK)
  // Low level error reporting; by default ignores KIND parameter!
#endif

//
// TRACEF backs up $[Trace[KIND], ...] for system level tracing.
//
#ifndef TRACEF
# define TRACEF(CONTEXT,KIND,...) FPRINTF(CONTEXT, STDERR, __VA_ARGS__)
  // By default just prints the message and ignores KIND parameter!
#endif
extern void *errorf(Context context, char *format, ...) __attribute__((format(printf, 2, 3)));

// MatchRegex support
#define MATCHREGEX(regex, string) matchRegex(regex, string)
extern int matchRegex(char* regex, char* str);

// Split string using regex and send list of strings to sink
#define SEND_SPLIT(string, regex, sink) sendSplit(string, regex, sink)
extern void sendSplit(char* str, char* regex, Sink sink);

// TryCall support
#ifndef CRSXTRY
# define CRSXTRY do { jmp_buf ex_buf__; if( !setjmp(ex_buf__) ) {
# define CRSXCATCH(x) } else {
# define CRSXTRYEND } } while(0)
# define CRSXEXCEPTION(x) ""
#endif

// Hook to check for substitution overflow.
//
#ifndef CHECK_METASUBSTITUTE_SIZE
# define CHECK_METASUBSTITUTE_SIZE(context,metaSubstituteSize) permitUnusedLong(metaSubstituteSize)
#endif

// I/O.
//
// Mimic stdio(3) idioms; by default maps to the corresponding stdio(3) functions and macros.
//
#ifndef STDOUT
# define STDOUT stdout
#endif
//
#ifndef STDERR
# define STDERR stderr
#endif
//
#ifndef PRINTF
# define PRINTF(CONTEXT,...) FPRINTF(CONTEXT, STDOUT, __VA_ARGS__)
#endif
//
#ifndef FPRINTF
# define FPRINTF(CONTEXT,OUT,...) fprintf(OUT, __VA_ARGS__)
#endif

// Persistence layer.
//
// Permit saving of terms that can later be loaded.
//
#ifndef SAVE_TERM
# define SAVE_TERM(CONTEXT,NAME,TERM) saveTerm(CONTEXT, NAME, TERM)
#endif
extern int saveTerm(Context context, char *name, Term term);
//
// Note: the (parse+)load functions are defined in crsx_scan.l
//
#ifndef LOAD_TERM
# define LOAD_TERM(SINK,CAT,NAME) loadTerm(SINK, NAME)
#endif
#ifndef SCAN_TERM
# define SCAN_TERM(SINK,CAT,TEXT) scanTerm(SINK, TEXT)
#endif
extern int loadTerm(Sink sink, char *name);
extern int readTerm(Sink sink, FILE *input);
extern int scanTerm(Sink sink, const char *text);
//
// Persistence helpers using stdio(3) FILE streams.
//
#ifndef FOPEN_IN
# define FOPEN_IN(CONTEXT,NAME) fopen_in(CONTEXT, NAME)
#endif
extern FILE* fopen_in(Context context, char *name);
//
#ifndef FOPEN_OUT
# define FOPEN_OUT(CONTEXT,NAME) fopen_out(CONTEXT, NAME)
#endif
extern FILE* fopen_out(Context context, char *name);

// Assertions.
//
#ifndef ASSERT
# define ASSERT(CONTEXT,TEST) assert(TEST)
#endif

// List construction symbols.
//
extern struct _ConstructionDescriptor descriptor_M__sCons;
extern struct _ConstructionDescriptor descriptor_M__sNil;

///////////////////////////////////////////////////////////////////////////////////////////////////
// BitSet forward declarations

#ifndef MAKE_SET_BITS
typedef unsigned long long BITS;
#endif

typedef struct _BitSet {
    unsigned size; // Number of bits
    BITS* bits;
} BitSet;
typedef struct _BitSet* BitSetP;


///////////////////////////////////////////////////////////////////////////////////////////////////
// TERMS

// Term traversal.
//
// Usage:
//   int arity = ARITY(term);
//   int subtermBinderRank = RANK(term,index);
//   Variable binder = BINDER(term,index,binderindex);  assert( index<arity && binderindex<RANK(term,index) )
//   BINDER(term,index,binderindex) = variable;
//   Term subterm = SUB(term,index);
//   SUB(term,index) = subterm;
//   NAMED_PROPERTY(construction,name) is the term bound to the property char *name in term, or NULL
//   VARIABLE_PROPERTY(construction,varable) is the term bound to the property Variable variable in term, or NULL
//
// These macros support the usual CRSX Term data model for constructions:
// - ARITY(term) is the number of subterms of the term (even 0 for variable uses).
// - RANK(term,index) is the number of variables bound for the index'th subterm
// - BINDERS(term,i) is the array of variables bound for the i'th subterm
// - BINDER(term,i,b) is the same as BINDERS(term,i)[b] but with index checking
// - SUB(term,index) is the actual index'th subterm
// - NAMED_PROPERTY(construction,name) is the term bound to the char *name in term, or NULL
// - VARIABLE_PROPERTY(construction,variable) is the term bound to the Variable variable in term, or NULL
// Note that SUB and BINDER can be used as lvalues.
//
// For any term.
#define ARITY(T) (IS_VARIABLE_USE(T) ? 0 : (T)->descriptor->arity)
#define IS_VARIABLE_USE(T) ((T)->descriptor == NULL)
#define IS_CONSTRUCTION(T) ((T)->descriptor != NULL)
#define IS_FUNCTION(T) (IS_CONSTRUCTION(T) && TAG(T) == 0)
#define IS_FUNCTIONAL_USE(C,T) ((Term)(C)->functionalUse == (T)) 
#define IS_DATA(T) (IS_CONSTRUCTION(T) && TAG(T) > 0)
#define IS_LITERAL(T) (IS_DATA(T) && !SORT(T))
#define IS_CONTAINER(T) (IS_DATA(T) && SORT(T))

// Tests: normal form and function that cannot currently step.
#define IS_NF(T) (IS_VARIABLE_USE(T) || asConstruction(T)->nf)
#define IS_NOSTEP(T) (IS_VARIABLE_USE(T) || asConstruction(T)->nostep)
#define IS_CLOSED(T) (!IS_VARIABLE_USE(T) && !asConstruction(T)->fvs);
#define IS_CLOSURE(T) (IS_CONSTRUCTION(T) && asConstruction(T)->closure)

// For variable use terms.
#define VARIABLE(T) (asVariableUse(T)->variable)

// For construction terms:
#define SORT(T) ((T)->descriptor->sort)
#define TAG(T) ((T)->descriptor->sortoffset)
#define SUB(T,I) (*(c_subp(asConstruction(T),I)))
#define RANK(T,I) c_rank(asConstruction(T),I)
#define BINDERS(T,I) c_binders(asConstruction(T),I)
#define BINDER(T,I,BI) BINDERS(T,I)[BI]

#define SYMBOL(T) (IS_VARIABLE_USE(T) ? VARIABLE(T)->name : c_name(asConstruction(T)))
#define TEXT(T) c_name(asConstruction(T))
#define LONGLONG(T) atoll(c_name(asConstruction(T)))
#define DOUBLE(T) atof(c_name(asConstruction(T)))
#define LENGTH(T) strlen(TEXT(T))

#define DPROPERTY(C,N,V,P) c_property(C,N,V,P)
#define PROPERTY(C,T,P) DPROPERTY(C, asConstruction(T)->namedProperties, asConstruction(T)->variableProperties, P)
#define DNAMED_PROPERTY(C,N,K)  c_namedProperty((N), K)
#define NAMED_PROPERTY(C,T,N)  c_namedProperty(asConstruction(T)->namedProperties, N)
#define DVARIABLE_PROPERTY(V,K)  c_variableProperty((V), K)
#define VARIABLE_PROPERTY(T,V)  c_variableProperty(asConstruction(T)->variableProperties, V)
#define NAMED_PROPERTIES(T) (asConstruction(T)->namedProperties)
#define VARIABLE_PROPERTIES(T) (asConstruction(T)->variableProperties)

static inline Term c_deref(Term *p) { return (p ? *p : (Term)0); }

// Dummies to prevent warnings...
static inline int noop(void) { return 0; }
static inline void permitUnusedTerm(Term t) {}
static inline void permitUnusedTermP(Term *p) {}
static inline void permitUnusedInt(int i) {}
static inline void permitUnusedLong(long l) {}
static inline void permitUnusedVariable(Variable v) {}
static inline void permitUnusedNLink(NamedPropertyLink v) {}
static inline void permitUnusedVLink(VariablePropertyLink v) {}

// Representation.

// All term structures start with a pointer to a descriptor.
struct _Term
{
    ConstructionDescriptor descriptor;  // of the term or NULL for variables
    ssize_t nr;                         // number of references to this term (node)
#ifdef CRSX_ENABLE_PROFILING
    size_t marker;                      // counter helper for graph traversal.
#endif
};
// Pick Variable set representation

// Hash set based

#define VARIABLESET Hashset

#define LINK_VARIABLESET(C,S) ((VARIABLESET) LINK_Hashset(C,S))
#define UNLINK_VARIABLESET(C,S) ((VARIABLESET) UNLINK_Hashset(C,S))

#define VARIABLESET_REMOVEALL(C,S,V,L) removeAllHS(C,S,V,L)
#define VARIABLESET_MERGEALL(C,S1,S2) mergeAllHS(C,S1,S2)
#define VARIABLESET_ADDVARIABLE(C,S,V) addVariableHS(C,S,V)
#define VARIABLESET_CONTAINS(S,V) containsHS(S,V)
#define VARIABLESET_CLEAR(C,S) clearHS(C,S)
#define VARIABLESET_MINUS(C,S,O) minusHS(C,S,O)
#define VARIABLESET_PRINTF(C,O,S) printfHS(C,O,S)
#define VARIABLESET_ISEMPTY(S) ((S)== NULL || ((S) != AllFreeVariables && (S)->nitems == 0))
#define VARIABLESET_COUNT(S) ((S)== NULL ? 0 : (S)->nitems)
#define VARIABLESET_ADDVARIABLESOF(C, VS, S, CO, P) (addVariablesOfHS(C, VS, S, CO, P))

// Reference counting: ALWAYS use these when storing or eliminating Term values.
//
// The following are the rules:
// * Every function and macro parameter of type Term is assumed to consume one reference to the term.
// * Every function parameter of type Term* is assumed to maintain the references to the term.
// * a new term created by BUFFER_TERM comes fully internally linked, and with one link to the top node.
// * a special case is the step() function which ONLY consumes the link it is passed if it returns true.
//
#define LINK_COUNT(T) ((T)->nr)
#define LINK(C,T) linkTerm(C, T)

#define UNLINKSET(CONTEXT,T,V) ((--LINK_COUNT(T) ? T : freeTerm(CONTEXT,T)), (T)=V)
#define UNLINK(CONTEXT, T) (T=unlinkTerm(CONTEXT,T))
#define UNLINK_SUB(CONTEXT, T, I) UNLINK(CONTEXT, SUB(T, I))

extern void freeTerm(Context context, Term term);

static inline Term linkTerm(Context context, Term t)
{
    if (t->nr == SSIZE_MAX)
    	return t;

    assert(t->nr > 0);
    t->nr ++;
    return t;
}

static inline Term unlinkTerm(Context context, Term t)
{
	if (t->nr == SSIZE_MAX)
		return t;

    assert(t->nr > 0);
    if (--t->nr == 0)
    {
        freeTerm(context,t);
        return NULL;
    }
    return t;
}

// Variable added for variable use subterm.
struct _VariableUse
{
    struct _Term term; // extends Term but with term.descriptor==NULL
    Variable variable; // never NULL
};

// Construction has properties, free variables, subterms, and binders (obtained by casting).
struct _Construction
{
    struct _Term term; // extends _Term with term.descriptor!=NULL

    unsigned int nf : 1;      // whether subterm known to be normal form
    unsigned int nostep : 1;  // whether function construction subterm known to not currently be steppable
    unsigned int closure : 1; // whether function construction is a closure and can never be be steppable

    NamedPropertyLink namedProperties;       // named properties. (may be null)
    VariablePropertyLink variableProperties; // variable properties. (may be null)

    // Keep all free variable sets separated in order to maximize reuse, and minimize merging.
    Hashset fvs;  // free variables known to occur in subterms only (excluding properties)
    Hashset nfvs; // free variables known to occur in named properties (on this construction AND subterms)
    Hashset vfvs; // free variables known to occur in variable properties (on this construction AND subterms)

    Term sub[]; // subterms -- actual size is ARITY(term)
    // Variable binder[]; // binders -- actual size is term->descriptor->binderoffset[ARITY(term)]
};


// Helper computing free variables from child terms.
extern void propagateFreeVariables(Context context, Term term);

extern VARIABLESET AllFreeVariables;

// Helper adding modified location properties.
extern void passLocationProperties(Context context, Term locTerm, Term term);

// For constants and basic constructors.
struct _ConstantConstruction
{
    struct _Construction construction; // extends Construction
};

struct _Literal // only strings
{
    struct _Construction construction; // extends Construction but with .term.sort==NULL
    const char *text;
};

// Construction term internals.
//
// Description of specific construction:
// - The construction has arity subterms
// - The n'th subterm (from 0) scopes binders binderoffset[n] up to (but not including) binderoffset[n+1]
// - The sub and binder functions return individual subterm and binder
// - Finally, provides the mechanism for accessing the properties of associated terms.
//
struct _ConstructionDescriptor
{
    SortDescriptor sort; // result sort for descriptor (NULL for polymorphic constructors)
    int sortoffset; // current descriptor tag offset in sort (>0 for data, 0 for functions)
    int arity; // number of subterms
    int size; // sizeof instances of the constructor
    int *binderoffset; // offset in binder list of first binder for each argument; for length = arity+1
    char *(*name)(Term term); // of descriptor
#ifdef STRICT
    int argcount; // number of arguments in direct step expression. Does not count the sink, shared and the environment.
    int (*step)(Sink, ssize_t, Term); // rewrite the term to get closer to a top level data descriptor and return whether the rewrite has fully been complete
#else
    int (*step)(Sink sink, Term term); // rewrite the term to get closer to a top level data descriptor and return 1 is term has been sent to sink
#endif
};

//#define CRSX_CHECK_SORT(CONTEXT,T,SORT) ASSERT(CONTEXT, IS_VARIABLE_USE(T) || !(T)->descriptor->sort  ||  (T)->descriptor->sort == (SORT))
//#define CRSX_CHECK_SORT(CONTEXT,T,SORT) (ASSERT(CONTEXT, (T)->nr > 0))
#define CRSX_CHECK_SORT(CONTEXT,T,SORT) noop()

// Casting helpers.
#define asVariableUse(term) ((VariableUse) term)
#define asConstruction(term) ((Construction) term)
#define asLiteral(term) ((Literal) term)

// Construction helpers.
#define c_name(c)      (c->term.descriptor->name(&(c->term)))
// Does *not* create a new reference
#define c_subp(c,i)    (&(c->sub[i]))

#define c_binders(c,i) (&(((Variable *) &(c->sub[c->term.descriptor->arity]))[c->term.descriptor->binderoffset[i]]))
#define c_rank(c,i)    (c->term.descriptor->binderoffset[i+1] - c->term.descriptor->binderoffset[i])
#define c_rankd(d,i)    (d->binderoffset[i+1] - d->binderoffset[i])

// Constant descriptors used for literals.

// Use when arity is zero.
extern int noBinderOffsets[];
extern Term *noSub(Term term, int n);
extern Variable *noBinders(Term term, int n);

// Generic components of ConstructionDescriptors.
extern char *dataName(Term term);

#ifdef STRICT
extern int dataStep(Sink sink, ssize_t, Term term);
#else
extern int dataStep(Sink sink, Term term);
#endif

// Description of sort.
//
struct _SortDescriptor
{
    char *name; // of sort
    ConstructionDescriptor *constructors; // NULL-terminated array of data constructors
    char **constructorNames; // NULL-terminated array of corresponding data constructor names
    char **constructorInternalNames; // NULL-terminated array of corresponding internal data constructor names (for START and END macro *generation*)
    SortDescriptor previous;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// VARIABLES

// Creating a globally unique variable.
//
// Usage:
//   Variable variable = MAKE_*_VARIABLE(context, "name_candidate");
//
// Variables are compared as pointers with ==.  The name is a guideline and may be ignored.
//
#define MAKE_BOUND_PROMISCUOUS_VARIABLE(context,v) makeVariableTrusty(context,v,1,0,0)
#define MAKE_FRESH_PROMISCUOUS_VARIABLE(context,v) makeVariableTrusty(context,v,0,0,0)
#define MAKE_BOUND_LINEAR_VARIABLE(context,v) makeVariableTrusty(context,v,1,1,0)
#define MAKE_FRESH_LINEAR_VARIABLE(context,v) makeVariableTrusty(context,v,0,1,0)
#define MAKE_BOUND_PROMISCUOUS_VARIABLE_TRUSTY(context,v) makeVariableTrusty(context,v,1,0,1)
#define MAKE_FRESH_PROMISCUOUS_VARIABLE_TRUSTY(context,v) makeVariableTrusty(context,v,0,0,1)
#define MAKE_BOUND_LINEAR_VARIABLE_TRUSTY(context,v) makeVariableTrusty(context,v,1,1,1)
#define MAKE_FRESH_LINEAR_VARIABLE_TRUSTY(context,v) makeVariableTrusty(context,v,0,1,1)

//
struct _Variable
{
    long nr;               // Number of references
    long uses;             // Number of uses in the tree term and properties. Speed up meta substitution.
    char *name;              // name...neither guaranteed to be globally unique nor the same as originally provided
    unsigned int linear : 1; // whether this variable is linear
    unsigned int bound : 1;  // whether this variable is bound
};

/**
 * @Brief Make new variable. Reference count is 1, use count is 0
 */
extern Variable makeVariable(Context context, char *name, unsigned int bound, unsigned int linear);

/**
 * @Brief Make new variable (possibly trusting the name). Reference count is 1, use count is 0
 */
extern Variable makeVariableTrusty(Context context, char *name, unsigned int bound, unsigned int linear, unsigned int trustname);

/**
 * @Brief Free variable
 */
extern void freeVariable(Context context, Variable variable);

/**
 * @Brief Make term using the given variable reference
 */
extern VariableUse makeVariableUse(Context context, Variable variable);

/**
 * @Brief Increment variable reference count. Don't increment use count
 */
static inline Variable linkVariable(Context context, Variable variable)
{
    assert(variable->nr > 0);
    variable->nr ++;
    return variable;
}

/**
 * @Brief Decrement variable reference count. Don't decrement use count
 */
static inline void unlinkVariable(Context context, Variable variable)
{
    assert(variable->nr > 0);
    variable->nr --;
    if (variable->nr == 0)
        freeVariable(context, variable);
}

/**
 * @Brief Unuse variable. Decrement ref count and use count
 */
static inline Variable useVariable(Context context, Variable variable)
{
    assert(variable->nr > 0);
    variable->uses ++;
    return variable;
}


/**
 * @Brief Unuse variable. Decrement ref count and use count
 */
static inline void unuseVariable(Context context, Variable variable)
{
    assert(variable->nr > 0);
    assert(variable->uses > 0);
    variable->uses --;
}

#define IS_BOUND(v) ((v)->bound)
#define IS_LINEAR(v) ((v)->linear)

// Used when reusing bound variables as fresh or different bound variables.
#define UNBIND(variable) (variable)->bound = 0
#define REBIND(variable) (variable)->bound = 1

/**
 * @Brief set the base variable name. The base name occurs before the first occurrence of '_'
 */
extern void setVariableBaseName(Context context, Variable variable, char *newbase);

/////////////////////////////////////////////////////////////////////////////////
// Literal allocation.

extern Term makeStringLiteral(Context context, const char *text);

///////////////////////////////////////////////////////////////////////////////////////////////////
// CREATING TERMS
//
// Term creation events.
//
// Usage:
//   Sink sink = ...;
//   START(sink,constructorName);
//   END(sink,constructorName);
//   USE(sink,variable);
//   BINDS(sink,rank,variableArray);
//
//   LITERAL(sink,text);
//   LITERALF(sink,fmt,...);
//   LITERALNF(sink,size,fmt,...);
//
//   ADD_PROPERTY_REF(sink,term);
//   ADD_PROPERTY_NAMED(sink,name,term);
//   ADD_PROPERTY_VARIABLE(sink,variable,term);
//   ADD_PROPERTY_WEAKEN(sink,variable);
//   PROPERTIES_RESET(sink);
//
//   WEAKEN(sink,variable);
//
//   COPY(sink,term);
//
// where in each case the sink is obtained with one of the methods described below,
// the constructorName is a MANGLED constructor name defined by the RulesCompiler output, and
// all Variable arguments must be made with one of the MAKE_*_VARIABLE variants.
//
// The events do the following:
// - START(sink,constructorName): Emit start event for construction with constructor with (mangled*)
//      constructorName.
// - END(sink,constructorName): Emit end event for construction started with START(sink,constructorName).
// - LITERAL(sink,text): Emit start and end event for unsorted constant construction with text as (unmangled) constructor
// - LITERALU(sink,text): Variant ('unsafe') for constant or pre-ALLOCATEd text.
// - LITERALF(sink,fmt,...): Same as LITERAL except the string is composed safely using vsnprintf(3) (using a large stack-allocated temp buffer).
// - LITERALNF(sink,maxsize,fmt,...): Same as LITERAL except the string is composed using vsnprintf(3).
// - USE(sink,v): Emit variable use event for previously allocated Variable v.
// - BINDS(sink,rank,vs): Emit binder event for previously allocated array Variable vs[rank] (which is copied and thus can be automatic).
// - ADD_PROPERTY_REF(sink,term): copy properties from term into the next START. Term reference is *NOT* transferred
// - ADD_PROPERTY_NAMED(sink,name,term): add named property with value into the next START. Term reference is transferred
// - ADD_PROPERTY_VARIABLE(sink,variable,term): add variable property with value into the next START. Term reference is transferred
//   ADD_PROPERTY_WEAKEN(sink,variable): add the specified variables list to the list of impossible free variables in properties with next START.
// - COPY(sink,term): copies the term to the sink.
//
// Note: Properties events are given "inside-out" so typically like this
//   ADD_PROPERTY_REF(sink,x); ADD_PROPERTY_WEAKEN(sink,var_not_in_x); ADD_PROPERTY_VAIRABLE(sink,var_not_in_x,value);...
//
// Furthermore, each event returns 1 except if it is known that no other events sent to the sink will
// have any affect, where 0 is returned instead (permits using &&-chains for event creation).
//
#define START(sink,c) ((sink) ? ((Sink)(sink))->start(sink, &descriptor##c) : NULL)
#define END(sink,c) ((sink) ? ((Sink)(sink))->end(sink, &descriptor##c) : NULL)
#define USE(sink,variable) ((sink) ? ((Sink)(sink))->use(sink, variable) : NULL)
#define USEL(sink,variable) ((sink) ? ((Sink)(sink))->use(sink, linkVariable(((Sink)sink)->context, variable)) : NULL)
#define USEF(sink) (USEL((sink), (sink)->context->functional))
#define BINDS(sink,rank,binders) ((sink) ? ((Sink)(sink))->binds(sink, rank, binders) : NULL)

#define COPY(sink,term) ((sink) ? ((Sink)(sink))->copy(sink, term) : NULL)
#define COPYC(sink,term,ccount) COPY(sink,term)

#define LITERALU(sink,text) ((sink) ? ((Sink)(sink))->literal(sink, text) : NULL)
//#define LITERAL(sink,text) LITERALU(sink, GLOBAL((sink)->context, text))
#define LITERAL(sink,text) LITERALU(sink, text)

#define LITERALF_SIZE_LIMIT 10000
#define LITERALF(sink,...) LITERALU(sink,ALLOCATENF((sink)->context, (size_t) LITERALF_SIZE_LIMIT, __VA_ARGS__))
#define LITERALNF(sink,maxsize,...) LITERALU(sink, ALLOCATENF((sink)->context, maxsize, __VA_ARGS__))

#define ADD_PROPERTIES(sink,namedProperties,variableProperties) ((Sink)(sink))->properties(sink,namedProperties,variableProperties)
#define ADD_PROPERTY_REF(sink,construction) ((Sink)(sink))->propertyRef(sink, asConstruction(construction))
#define ADD_PROPERTY(sink,P,value) (IS_VARIABLE_USE(P) ? ADD_PROPERTY_VARIABLE(sink, linkVariable(sink->context, VARIABLE(P)), value) : ADD_PROPERTY_NAMED(sink, GLOBAL(sink->context, SYMBOL(P)), value))
#define ADD_PROPERTY_NAMED(sink,name,value) ((Sink)(sink))->propertyNamed(sink, name, value)
#define ADD_PROPERTY_VARIABLE(sink,variable,value) ((Sink)(sink))->propertyVariable(sink, variable, value)
#define ADD_PROPERTY_WEAKEN(sink,variable) ((Sink)(sink))->propertyWeaken(sink, variable)
#define PROPERTIES_RESET(sink) ((Sink)(sink))->propertiesReset(sink)

// A Sink is a generic event handler for capturing terms.
//
typedef enum { SINK_UNDEFINED, SINK_IS_BUFFER, SINK_IS_SHOW } SinkKind;
struct _Sink
{
    SinkKind kind;  // the kind of Sink...to permit sanity checks before casts.
    Context context; // context used for internal allocations
    Term (*term)(Sink sink); // Extract the term of the captured (and possibly step'd) term

    Sink (*start)(Sink sink, ConstructionDescriptor descriptor); // start event
    Sink (*end)(Sink sink, ConstructionDescriptor descriptor); // end event
    Sink (*literal)(Sink sink, const char *text); // literal event. Text reference is transferred
    Sink (*use)(Sink sink, Variable variable); // use event. Variable reference is transferred.
    Sink (*binds)(Sink sink, int rank, Variable binds[]); // binds event. Variable references are transferred.
    Sink (*copy)(Sink sink, Term term); // copy term as event(s)

    Sink (*propertyRef)(Sink sink, Construction construction); // base properties for next START
    Sink (*properties)(Sink sink, NamedPropertyLink namedProperties, VariablePropertyLink variableProperties); // base properties for next START

    Sink (*propertyNamed)(Sink sink, PooledString name, Term term); // add named property to next START
    Sink (*propertyVariable)(Sink sink, Variable variable, Term term); // add variable property to next START. Variable reference is transferred.
    Sink (*propertiesReset)(Sink sink); // reset property state
};

#define SINK_IS_BUFFER(sink) (((Sink)(sink))->kind == SINK_IS_BUFFER)

#define BUFFER_SEGMENT_SIZE 7

struct _Buffer
{
    struct _Sink sink; // the sink (including the kind, embedded FIRST to allow casting)
    Term term; // the term collected by the buffer (after it is done)
    BufferSegment first; // the first segment; all allocated segments available through segment ->next chain TODO: include first segment here!
    BufferSegment last; // the last segment (with top of stack in it) or NULL when empty
    int lastTop; // index of top entry (in last segment) or <0 when empty
    NamedPropertyLink pendingNamedProperties; // named properties for next START (NOTE: cannot be shared). Buffer owns ref.
    VariablePropertyLink pendingVariableProperties; // variable properties for next START (NOTE: cannot be shared). Buffer owns ref.
};

struct _BufferEntry
{
    Term term; // allocated partial construction
    int index; // subterm we are working on
};

struct _BufferSegment
{
    BufferSegment previous, next; // previous and next buffer segment (NULL for first/last)
    struct _BufferEntry entry[BUFFER_SEGMENT_SIZE];
};


// Create a buffer to accumulate a term.
// Extract built term from buffer, once it has finished.
// Free the buffer.
//
// Usage:
//   Sink sink = MAKE_BUFFER(context); //allocated buffer of dynamic size
//   Term result = BUFFER_TERM(sink); //sink was created previuosly by MAKE_BUFFER...ONLY USE ONCE
//   FREE_BUFFER(sink);
//
#ifndef MAKE_BUFFER
#define MAKE_BUFFER(context) makeBuffer(context)
#endif
#ifndef BUFFER_TERM
#define BUFFER_TERM(sink) bufferTerm(sink)
#endif
#ifndef FREE_BUFFER
#define FREE_BUFFER(sink) freeBuffer(sink)
#endif
extern Sink makeBuffer(Context context);
extern Sink initBuffer(Context context, Buffer buffer);
extern Term bufferTerm(Sink sink);
extern void freeBuffer(Sink sink);
//
#ifndef ALLOCA_BUFFER
//#define ALLOCA_BUFFER(context) initBuffer(context, (Buffer) ALLOCA(context, sizeof(struct _Buffer)), 0)
#define ALLOCA_BUFFER(context) makeBuffer(context)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
// EVALUATION
//
// Usage:
//   FORCE(context, term); // term MUST BE LValue
//   NORMALIZE(context, termp);

#ifndef FORCE
# define FORCE(CONTEXT,T) (T = (IS_NOSTEP(T) ? (T) : force(CONTEXT, T)))
#endif
#ifndef NORMALIZE
# define NORMALIZE(CONTEXT,T) normalize(CONTEXT, &T)
#endif
#ifndef NORMALIZEP
# define NORMALIZEP(CONTEXT,T) normalizep(CONTEXT, T)
#endif
extern Term force(Context context, Term term);
extern void normalize(Context context, Term *termp);
extern Term normalizep(Context context, Term term);

// Obsolete:
#ifndef COMPUTE
# define COMPUTE(CONTEXT,T) (T = (IS_NF(T) ? (T) : compute(CONTEXT,T)))
#endif
extern Term compute(Context context, Term term);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//// CLOSURE
////

#ifdef STRICT

typedef int (*DStepFun)(Sink, ssize_t, Term);

extern int call0(Sink sink, Term term);
extern int call1(Sink sink, Term term, void* arg1);
extern int call2(Sink sink, Term term, void* arg1, void* arg2);
extern int call3(Sink sink, Term term, void* arg1, void* arg2, void* arg3);
extern int call4(Sink sink, Term term, void* arg1, void* arg2, void* arg3, void* arg4);
extern int call(Sink sink, Term term, int argcount, void* arg1, void* arg2, void* arg3);

#ifndef CALL0
#define CALL0(SINK,TERM) call0(SINK, TERM)
#endif

#ifndef CALL1
#define CALL1(SINK,TERM,A1) call1(SINK, TERM, A1)
#endif

#ifndef CALL2
#define CALL2(SINK,TERM,A1,A2) call2(SINK, TERM, A1, A2)
#endif

#ifndef CALL3
#define CALL3(SINK,TERM,A1,A2,A3) call3(SINK, TERM, A1, A2, A3)
#endif

#ifndef CALL4
#define CALL4(SINK,TERM,A1,A2,A3,A4) call4(SINK, TERM, A1, A2, A3, A4)
#endif

#ifndef CALL
# define CALL(SINK,T,ARGC,A1,A2,A3) call(SINK, (T), ARGC, A1, A2, A3)
#endif

#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
// SUBSTITUTE
//
// Usage:
// - SUBSTITUTE(sink,T,frame) sends a copy of term T to the sink except as substituted by frame;

struct _SubstitutionFrame
{
    SubstitutionFrame parent;  // parent frame (or NULL)
    int parentCount;           // number of variable-substitute pairs in all parent frames
    int count;                 // number of variable-substitute pairs in this frame
    Variable *variables;       // count redex variables to substitute, in order. *Not* owned by frame.
    Term *substitutes;         // count redex subterms to substitute for variables, in order
};

#ifndef SUBSTITUTE
# define SUBSTITUTE(sink,term,substitution) metaSubstitute(sink, term, substitution)
#endif
extern int metaSubstitute(Sink sink, Term term, SubstitutionFrame substitution);

///////////////////////////////////////////////////////////////////////////////////////////////////
// PROPERTIES

extern Term c_namedProperty(NamedPropertyLink link, PooledString name);
extern Term c_variableProperty(VariablePropertyLink link, Variable variable);
static inline Term c_property(Context context, NamedPropertyLink namedProperties, VariablePropertyLink varProperties, Term key)
{
    return (IS_VARIABLE_USE(key) ? c_variableProperty(varProperties, VARIABLE(key)) : c_namedProperty(namedProperties, GLOBAL(context,SYMBOL(key))));
}

/**
 * Extend named environment with given key/value pair. All refs are transferred.
 */
extern NamedPropertyLink addNamedProperty(Context context, NamedPropertyLink link, PooledString key, Term value);

/**
 * Extend variable environment with given key/value pair. All refs are transferred.
 */
extern VariablePropertyLink addVariableProperty(Context context, VariablePropertyLink link, Variable variable, Term value);

struct _NamedPropertyLink
{
    NamedPropertyLink link;
    PooledString name;            // pooled name.
    union {
        Term term; // when name != NULL
        Hashset2 propset; // when name == NULL - hash set of many links at once
    } u;
#ifdef CRSX_ENABLE_PROFILING
    size_t marker; // counter helper for graph traversal.
#endif
    int count;
    int nr;
    Hashset fvs;
};

// Make a new named property link.
// All references (term, nlink and fvs) are transferred.
extern NamedPropertyLink ALLOCATE_NamedPropertyLink(Context context, PooledString name, Term term, NamedPropertyLink nlink, Hashset fvs, int index);

static inline NamedPropertyLink LINK_NamedPropertyLink(Context context, NamedPropertyLink link)
{
    if (link)
        link->nr++;

    return link;
}

extern void freeNamedPropertyLink(Context context, NamedPropertyLink link);

static inline NamedPropertyLink UNLINK_NamedPropertyLink(Context context, NamedPropertyLink link)
{
    if (link)
    {
        if (--link->nr == 0)
        {
             freeNamedPropertyLink(context, link);
             return NULL;
        }
    }
    return link;
}

struct _VariablePropertyLink
{
    VariablePropertyLink link;
    Variable variable;
    union {
        Term term; // when variable != NULL
        Hashset2 propset; // when name == NULL - hash set of many links at once
    } u;
#ifdef CRSX_ENABLE_PROFILING
    size_t marker; // counter helper for graph traversal.
#endif
    int count;
    int nr;
    Hashset fvs;
};

extern void freeVariablePropertyLink(Context context, VariablePropertyLink link);

static inline VariablePropertyLink LINK_VariablePropertyLink(Context context, VariablePropertyLink link)
{
    if (link)
        ++(link->nr);
    return link;
};

static inline VariablePropertyLink UNLINK_VariablePropertyLink(Context context, VariablePropertyLink link)
{
    if (link)
    {
        if (--link->nr == 0)
        {
            freeVariablePropertyLink(context, link);
            return NULL;
        }
    }
    return link;
}


#define ASSERT_VARIABLE_PROPERTIES(context, properties) \
ASSERT(context, (!context->fv_enabled || ((properties->variableProperties && properties->variableFreeVars) || (! properties->variableProperties &&  ! properties->variableFreeVars))));

///////////////////////////////////////////////////////////////////////////////////////////////////
// GLOBAL ENVIRONMENT

/**
 * Return the value of the environment name. The returned value is not copied.
 * First look in the normalization context and if not defined, look in the global environment
 */
extern char* getEnvValue(Context context, const char *name);

/**
 * Set the value of the environment name in the context.
 * The name and value strings are not copied. They will be released upon crsx shutdown.
 */
extern void setContextEnv(Context context, const char *name, const char* value);

///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERIC VARIABLE SETS AND MAPS

struct _VariableSet
{
    Context context;

    union {
        VariableSetLink link;
    } u;

    int (*addVariable)(VariableSet, Variable);
    void (*free)(VariableSet);
    int (*containsVariable)(VariableSet, Variable);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// Linked-list variable set

struct _VariableSetLink
{
    size_t nr;            // Number of references.
    VariableSetLink link;
    Variable variable;
};

// Make linked-list based variable set.
extern VariableSet makeVariableSet(Context context);
// Add variable to set; returns 1 if variable actually added. Variable reference is transferred.
extern int addVariable(VariableSet set, Variable variable);
// Check whether set contains a variable.
extern int containsVariable(VariableSet set, Variable variable);
// Release variable set.
extern void freeVariableSet(VariableSet set);

// Check whether variable array contains a variable.
extern int containsAL(Variable* vars, int len, Variable variable);

///////////////////////////////////////////////////////////////////////////////////////////////////
// Copy-on-write linked-list variable set

// Copy variable set.
extern VariableSetLink copyL(Context context, VariableSetLink set);
// Count variable set links.
extern size_t countL(VariableSetLink set);
// Add variable to set. Create new set if needed.
extern VariableSetLink addVariableL(Context context, VariableSetLink set, Variable variable);
// Check whether set contains a variable.
extern int containsL(VariableSetLink set, Variable variable);
// Check whether set contains a variable of given name. Debugging use only
extern int containsNameL(VariableSetLink link, char* name);
// Check whether variable links list contains a variable and returns the link (no ref transferred), or NULL
//extern VariableSetLink variableSetLinkFor(VariableSetLink link, Variable variable);
// Merge the two sets. Both references are transferred.
extern VariableSetLink mergeAllL(Context context, VariableSetLink first, VariableSetLink second);
// Remove all variables contains in other from set. 'set' reference is transferred. 'other' is not transferred.
extern VariableSetLink minusL(Context context, VariableSetLink set, VariableSetLink other);
// Remove all given variables from set. 'set' reference is transferred.
extern VariableSetLink removeAllL(Context context, VariableSetLink set, Variable* vars, int len);
//// Compute intersection
//extern VariableSetLink intersectL(Context context, VariableSetLink set, VariableSetLink other);
//// Compute intersection
//extern VariableSetLink intersectGL(Context context, VariableSetLink set, VariableSetLink other, VariableSetLink* removed);
// Clear set
extern VariableSetLink clearL(Context context, VariableSetLink set);
// Print out set
extern void printfL(Context context, FILE* out, VariableSetLink set);

///////////////////////////////////////////////////////////////////////////////////////////////////
// Copy-on-write open addressing variable set

struct _Hashset {
    unsigned nr;
    unsigned nbits;
#ifdef CRSX_ENABLE_PROFILING
    size_t marker;
#endif
    size_t nitems;
    size_t* items;
};

// Allocation variable set.
extern Hashset makeHS(Context context, unsigned nbits);
// Free variable set. Try to put it in the pool if requested.
extern void freeHS(Context context, Hashset set, int pool);
// Copy variable set.
extern Hashset copyHS(Context context, Hashset set, unsigned nbits);
// Add variable reference to set. Create new set if needed.
extern Hashset addVariableHS(Context context, Hashset set, Variable variable);
// Remove variable from set. 'set' reference is transferred.
extern Hashset removeVariableHS(Context context, Hashset set, Variable var);
// Check whether set contains a variable.
extern int containsHS(Hashset set, Variable variable);
// Merge the two sets. Both references are transferred.
extern Hashset mergeAllHS(Context context, Hashset first, Hashset second);
// Remove all variables contains in other from set. 'set' reference is transferred. 'other' is not transferred.
extern Hashset minusHS(Context context, Hashset set, Hashset other);
// Remove all given variables from set. 'set' reference is transferred.
extern Hashset removeAllHS(Context context, Hashset set, Variable* vars, int len);
// Clear set
extern Hashset clearHS(Context context, Hashset set);
// Enumerate set as old-fashioned VariableSet
extern void addVariablesOfHS(Context context, VariableSet vars, Hashset set, int constrained, VariablePropertyLink props);
// Print out set
extern void pHS(Context context, Hashset set);
// Print out set
extern void printfHS(Context context, FILE* out, Hashset set);

static inline Hashset LINK_Hashset(Context context, Hashset set)
{
    if (set && set != AllFreeVariables)
        ++(set->nr);
    return set;
}

static inline Hashset UNLINK_Hashset(Context context, Hashset set)
{
    if (set && set != AllFreeVariables)
    {
        assert(set->nr > 0);
        if (--set->nr == 0)
        {
            freeHS(context, set, 1);
            return NULL;
        }
    }
    return set;
}

// General bucket-based hash set. Read-only when shared.

typedef struct _Pair* Pair;

struct _Pair {
    const void *key;
    void* value; // may be null
};

typedef struct _LinkedList2* LinkedList2;

struct _LinkedList2 {
    const void *key;
    void* value; // may be null for set.
    LinkedList2 next;
};

    
// Hashset2 iterator state
typedef struct _Iterator2 *Iterator2;
struct _Iterator2
{
    Hashset2 set;   // The set
    size_t index; // current table index
    LinkedList2 slot; // Current slot.
};
    
// Get current key. No ref transfer
extern const void* getKeyIHS2(Iterator2 iter);
// Get current value. No ref transfer
extern void* getValueIHS2(Iterator2 iter);
// Move to next entry. Returns true if has next.
extern int nextIHS2(Iterator2 iter);
// Release iterator.
extern void freeIHS2(Context context, Iterator2 iter);

    
struct _Hashset2
{
    int nr;
    unsigned int nbits;      // Number of bits for nslots
    size_t nslots;           // Number of entry slots. Always nbits ^ 2
    size_t size;             // Number of entries

    LinkedList2 *entries;                // Array of entries. Size of array = nslots

    void   (*unlink)(Context, const void*, void*);   // function to unlink key-value entries
    int    (*equals)(const void*, const void*);      // function to compare entries
    size_t (*hash)  (const void*);                   // function to hash entries
};

// Increment ref count.
extern Hashset2 linkHS2(Hashset2 set);
// Decrement ref count.
extern void unlinkHS2(Context context, Hashset2 set);
// Allocate set
extern Hashset2 makeHS2(Context context, unsigned int numbits, void (*unlink)(Context, const void*, void*), int (*equals)(const void*, const void*), size_t (*hash)(const void*));
// Add key-value pair to set. Value may be null. If key exists, replace value and call unlink on key/old value
extern Hashset2 addValueHS2(Context context, Hashset2 set, const void* key, void* value);
// Get value for given string key
extern void* getValueHS2(Hashset2 set, const void* key);
// Remove entry to set.
extern Hashset2 removeHS2(Context context, Hashset2 set, const void* key);
// Check whether set contains the given key.
extern int containsHS2(Hashset2 set, const void* key);
// Clear set
extern Hashset2 clearHS2(Context context, Hashset2 set);
// Convert to array. Don't copy entries (treat as read-only)
extern Pair* toArrayHS2(Context context, Hashset2 set);
// Creates an iterator over the set
extern Iterator2 iteratorHS2(Context context, Hashset2 set);
// Print out HS2
extern void printPropsHS2(Context context, Hashset2 set);

extern void freeValue(Context context, const void* key, void* value);
extern int equalsPtr(const void* left, const void* right);
extern size_t hashPtr(const void* entry);

int equalsChars(const void* left, const void* right);
size_t hashChars(const void* key);

    
// Link-list based map

struct _VariableMap
{
    VariableMapLink link;
    Context context;
};
struct _VariableMapLink
{
    VariableMapLink link;
    Variable key;
    Variable value;
};
// Create variable map.
extern VariableMap makeVariableMap(Context context);
// Add mapping.
extern void addVariableMap(VariableMap map, Variable key, Variable value);
// Lookup the variable in the map, and return the name or NULL if none.
extern Variable lookupVariable(VariableMap map, Variable variable);
// Pop the latest n entries added to the variable map.
extern void popVariableMap(VariableMap map, int n);
// Release variable map.
extern void freeVariableMap(VariableMap map);

struct _VariableNameMapLink
{
    VariableNameMapLink link;
    char *key;
    Variable value;
};
// Add link.
extern VariableNameMapLink addNameMapLink(Context context, VariableNameMapLink parent, char *name, Variable variable);
// Search stack of links.
extern Variable lookupNameLink(VariableNameMapLink link, char *name);
// Free entire stack (but not the linked values).
extern void freeVariableNameMapLinks(Context context, VariableNameMapLink link);

///////////////////////////////////////////////////////////////////////////////////////////////////
// PRINTING

extern void printTerm(Context context, Term term);
extern void printTermWithIndent(Context context, Term term);
extern void fprintTerm(Context context, FILE* out, Term term);
extern void fprintTermWithIndent(Context context, FILE* out, Term term);
extern void printTermFullWithIndent(Context context, Term term);
extern void fprintTermFullWithIndent(Context context, FILE*, Term term);
extern void ppt(Context context, int nesting, Term term);
extern void pt(Context context, Term term);
extern void pnp(Context context,  NamedPropertyLink namedProperties);

extern void fprintTermTop(Context context, FILE* out, Term term, int depth, VariableSet encountered, Hashset2 used, int indent, int *positionp, int includeprops, int debug);
extern void fprintFreeVars(Context context, FILE* out, VARIABLESET freeVars);

extern char* fprintNamedProperties(Context context, FILE* out, NamedPropertyLink namedProperties, char* sep, int depth, VariableSet encountered, Hashset2 used, int indent, int *positionp, int debug, int max);
extern char* fprintVariableProperties(Context context, FILE* out, VariablePropertyLink variableProperties, char* sep, int depth, VariableSet encountered, Hashset2 used, int indent, int *positionp, int debug, int max);

extern void printCTerm(Context context, Term term);

///////////////////////////////////////////////////////////////////////////////////////////////////
// AUXILIARY SORT STRUCTURES

// Last sort descriptor in ->previous chain.
//extern SortDescriptor lastSortDescriptor;

// Structure for generated lookup function.
struct _SymbolDescriptor
{
    char* symbol;
    ConstructionDescriptor descriptor;
};
typedef struct _SymbolDescriptor *SymbolDescriptor;

// Special macro for crsx_scan.l: see sample Makefile for how to generate the required symbol table!
#ifndef LOOKUP_DESCRIPTOR 
# define LOOKUP_DESCRIPTOR(context,name) lookupSymbolTableDescriptor(context, symbolDescriptorTable, symbolDescriptorCount, name)
  extern size_t symbolDescriptorCount;
  extern struct _SymbolDescriptor symbolDescriptorTable[];
#endif
extern ConstructionDescriptor lookupSymbolTableDescriptor(Context context, SymbolDescriptor table, size_t size, const char *symbol);

///////////////////////////////////////////////////////////////////////////////////////////////////
// MISCELLANEOUS

// Add all free variables in term to free set. If constrained set then only include variables included in props.
extern VariableSet makeFreeVariableSet(Context context, Term term, SortDescriptor sort, int constrained, VariablePropertyLink props);

// Check if two terms are equal module renaming of bound variables, and module environment when compenv is false
extern int deepEqual(Context context, Term term1, Term term2, int compenv);

// Check that a term structure is well defined and return the size.
extern int check(Context context, Term term);

// Check free variable set is correct
extern void checkFreeVariables(Context context, Term term);

// Send a $Cons/$Nil-list of all keys in the passed properties to the sink.
extern void sendPropertiesKeys(Sink sink, NamedPropertyLink named, VariablePropertyLink vard);

// Truth values.
extern const char *True;
extern const char *False;

// Empty list.
extern const char *Nil;

///////////////////////////////////////////////////////////////////////////////////////////////////
// BIT SET MANAGEMENT

#ifndef MAKE_SET_BITS

#define BITS_MAX_SIZE (sizeof(BITS)*8)
#define NO_BITS 0ULL
#define ONE_BITS 1ULL
#define MAKE_BITS(context,size) CHECKF(context, (size) <= BITS_MAX_SIZE, NO_BITS, Msg, "Nested Variable Overflow", XSLJIT_XJOOM, NULL, NULL, NULL, "")
#define MAKE_SET_BITS(context,size) CHECKF(context, (size) <= BITS_MAX_SIZE, ((~NO_BITS) >> (BITS_MAX_SIZE - (size))), Msg, "Nested Variable Overflow", XSLJIT_XJOOM, NULL, NULL, NULL, "")
#define COPY_BITS(context,bitset,size) CHECKF(context, (size) <= BITS_MAX_SIZE, bitset, Msg, "Nested Variable Overflow", XSLJIT_XJOOM, NULL, NULL, NULL, "")
#define ADD_BITS(bitset,bitset2) ((bitset) |= (bitset2))
#define MASK_BITS(bitset,bitset2) ((bitset) &= (bitset2))
#define BIT(bitset,index) (((bitset) >> (index)) & ONE_BITS)
#define ANY_BITS(bitset) ((bitset) != NO_BITS)
#define AND_BITS(bitset1,bitset2) ((bitset1)&(bitset2))
#define OR_BITS(bitset1,bitset2) ((bitset1)|(bitset2))
#define XOR_BITS(bitset1,bitset2) ((bitset1)^(bitset2))
#define SET_BIT(bitset,index) ((bitset) |= (ONE_BITS << (index)))
#define CLEAR_BIT(bitset,index) ((bitset) &= ~(ONE_BITS << (index)))
#define FREE_BITS(context,bitset) noop()

#endif


#define ASIZE(size) ((size / BITS_MAX_SIZE) + 1)
#define BSIZE(size) (size % BITS_MAX_SIZE)
#define AINDEX(index) (index / BITS_MAX_SIZE)
#define BINDEX(index) (index % BITS_MAX_SIZE)

#define MAKE_SET_LBITS(context, bitset, size) (bitset)->bits = (BITS *) ALLOCA(context, ASIZE(size)*sizeof(BITS)); makeSetBits(bitset, size)
#define COPY_LBITS(context, dst, size, src) (dst)->bits = (BITS *) ALLOCA(context, ASIZE(size)*sizeof(BITS)); copyBits(context, dst, size, src)
#define MASK_LBITS(bitset,bitset2) maskBits(bitset,bitset2)
#define LBIT(bitset,index) lbit(bitset, index)
#define ANY_LBITS(bitset) anyBits(bitset)
#define SET_LBIT(bitset,index) setBit(bitset, index)
#define CLEAR_LBIT(bitset,index) clearBit(bitset, index)
#define FREE_LBITS(context,bitset) noop()

static inline unsigned lbit(BitSetP bitset, unsigned index)
{
    return bitset->bits[AINDEX(index)] >> (BINDEX(index) & ONE_BITS);
}

static inline void setBit(BitSetP bitset, unsigned index)
{
    assert(index < bitset->size);

    unsigned ai = AINDEX(index);
    unsigned bi = BINDEX(index);
    BITS newbits = bitset->bits[ai] | (ONE_BITS << bi);
    bitset->bits[ai] = newbits;
}

static inline void clearBit(BitSetP bitset, unsigned index)
{
    assert(index < bitset->size);

    unsigned ai = AINDEX(index);
    unsigned bi = BINDEX(index);
    BITS newbits = bitset->bits[ai] & (~(ONE_BITS << bi));
    bitset->bits[ai] = newbits;
}

static inline void makeSetBits(BitSetP bitset, unsigned size)
{
    // Set all bits
    bitset->size = size;
    const int asize = ASIZE(size);

    int i = asize - 2;
    for (; i >= 0; i --)
        bitset->bits[i] = (~NO_BITS);

    bitset->bits[asize - 1] = (~NO_BITS) >> (BITS_MAX_SIZE - (BSIZE(size)));
}

static inline void copyBits(Context context, BitSetP dst, unsigned size, BitSetP src)
{
    assert(size >= src->size);

    dst->size = size;
    memset((void*)dst->bits, 0, ASIZE(size)*sizeof(BITS));
    memcpy((void*)dst->bits, (void*)src->bits, ASIZE(src->size)*sizeof(BITS));
}

static inline void maskBits(BitSetP bitset1, BitSetP bitset2)
{
    int i = ASIZE(bitset1->size) - 1;
    for (; i >= 0; i --)
        bitset1->bits[i] &= bitset2->bits[i];
}

static inline int anyBits(BitSetP bitset)
{
    int i = ASIZE(bitset->size) - 1;
    for (; i >= 0; i --)
        if (bitset->bits[i]) return 1;
    return 0;
}

// Bitset set

// Allocate variable set.
extern void makeB(Context context, BitSetP bitset, unsigned size);
// Copy variable set.
extern void copyB(BitSetP src, BitSetP dst);
// Add variable to set. Create new set if needed.
extern void addVariableB(BitSetP set, Variable variable);
// Check whether set contains a variable. Might return false positive (variable might actually not in the set)
extern int containsB(BitSetP set, Variable variable);
// Merge the two sets.
extern void mergeAllB(BitSetP first, BitSetP second);

///////////////////////////////////////////////////////////////////////////////////////////////////
// STACK OF MEMORY-MANAGED SEGMENTS
//
// Usage:
//   SETUP_STACK_TYPE(T)
//
// Expands to declarations of a new type of pointer, TStack, with the following static functions:
//
// TStack makeTStack(Context) - create empty stack of T elements
// int emptyTStack(TStack)    - whether the stack is empty
// void pushT(TStack, T)      - push a T element onto a stack
// T* topT(TStack)            - pointer to the top element of non-empty stack
// void popT(TStack)          - pop the top element off non-empty stack
// void freeTStack(TStack)    - free the entire stack

#ifndef STACK_SEGMENT_SIZE
# define STACK_SEGMENT_SIZE 63
#endif
#define SETUP_STACK_TYPE(TYPE)                                                                          \
                                                                                                        \
  typedef struct _##TYPE##Stack *TYPE##Stack;                                                           \
  typedef struct _##TYPE##StackSegment *TYPE##StackSegment;                                             \
                                                                                                        \
  struct _##TYPE##Stack { Context context; TYPE##StackSegment last; int top; };                         \
  struct _##TYPE##StackSegment { TYPE##StackSegment previous; TYPE entry[STACK_SEGMENT_SIZE]; };        \
                                                                                                        \
  static TYPE##Stack make##TYPE##Stack(Context context)                                                 \
  {                                                                                                     \
      TYPE##Stack stack = (TYPE##Stack) ALLOCATE(context, sizeof(struct _##TYPE##Stack)); \
      stack->context = context;                                                                         \
      stack->last = NULL;                                                                               \
      stack->top = -1;                                                                                  \
      return stack;                                                                                     \
  }                                                                                                     \
                                                                                                        \
  static int empty##TYPE##Stack(TYPE##Stack stack)                                                      \
  {                                                                                                     \
      return !stack->last;                                                                              \
  }                                                                                                     \
                                                                                                        \
  static void push##TYPE(TYPE##Stack stack, TYPE value)                                                 \
  {                                                                                                     \
      ++stack->top;                                                                                     \
      if (!stack->last || stack->top >= STACK_SEGMENT_SIZE)                                             \
      {                                                                                                 \
          TYPE##StackSegment segment = (TYPE##StackSegment) ALLOCATE(stack->context, sizeof(struct _##TYPE##StackSegment)); \
          segment->previous = stack->last;                                                              \
          stack->last = segment;                                                                        \
          stack->top = 0;                                                                               \
      }                                                                                                 \
      stack->last->entry[stack->top] = value;                                                           \
  }                                                                                                     \
                                                                                                        \
  static void pop##TYPE(TYPE##Stack stack)                                                              \
  {                                                                                                     \
      --stack->top;                                                                                     \
      if (stack->top < 0 && stack->last)                                                                \
      {                                                                                                 \
          TYPE##StackSegment segment = stack->last;                                                     \
          stack->last = segment->previous;                                                              \
          FREE(stack->context, segment);                                                                \
          if (stack->last)                                                                              \
              stack->top = STACK_SEGMENT_SIZE-1;                                                        \
      }                                                                                                 \
  }                                                                                                     \
                                                                                                        \
  static TYPE *top##TYPE(TYPE##Stack stack)                                                             \
  {                                                                                                     \
      return &stack->last->entry[stack->top];                                                           \
  }                                                                                                     \
                                                                                                        \
  static void free##TYPE##Stack(TYPE##Stack stack)                                                      \
  {                                                                                                     \
      TYPE##StackSegment last = stack->last;                                                            \
      while (last)                                                                                      \
      {                                                                                                 \
          TYPE##StackSegment previous = last->previous;                                                 \
          FREE(stack->context, last);                                                                   \
          last = previous;                                                                              \
      }                                                                                                 \
      FREE(stack->context, stack);                                                                      \
  }

///////////////////////////////////////////////////////////////////////////////////////////////////
// QUEUES OF MEMORY-MANAGED SEGMENTS
//
// Usage:
//   SETUP_QUEUE_TYPE(T)
//
// Expands to declarations of a new type of pointer, TQueue, with the following static functions:
//
// TQueue makeTQueue(Context) - create empty queue of T elements
// void addT(TQueue, T)       - add a T element onto a queue
// T* headT(TQueue)           - pointer to the head element of the queue
// void nextT(TQueue)         - discard the head element off the queue
// void freeTQueue(TQueue)    - free the entire queue

// The state of a TQueue q is determined as follows:
// - if q->first is NULL then the queue is empty; implies that so is q->last and that both q->hd and q->tl are negative.
// - if q->first is not NULL then the queue contains the entries from q->first->entry[q->hd] through q->last->entry[q->tl] (inclusive).

#define QUEUE_SEGMENT_SIZE 127
#define SETUP_QUEUE_TYPE(TYPE)                                                                            \
                                                                                                          \
  typedef struct _##TYPE##Queue *TYPE##Queue;                                                             \
  typedef struct _##TYPE##QueueSegment * TYPE##QueueSegment;                                              \
                                                                                                          \
  struct _##TYPE##Queue { Context context; TYPE##QueueSegment first, last; int hd, tl; };                 \
  struct _##TYPE##QueueSegment { TYPE##QueueSegment next; TYPE entry[QUEUE_SEGMENT_SIZE]; };              \
                                                                                                          \
  static TYPE##Queue make##TYPE##Queue(Context context)                                                   \
  {                                                                                                       \
      TYPE##Queue q = (TYPE##Queue) ALLOCATE(context, sizeof(struct _##TYPE##Queue)); \
      q->context = context;                                                                               \
      q->first = q->last = NULL;                                                                          \
      q->hd = q->tl = -1;                                                                                 \
      return queue;                                                                                       \
  }                                                                                                       \
                                                                                                          \
  static int empty##TYPE##Queue(TYPE##Queue queue)                                                        \
  {                                                                                                       \
      return !queue->first;                                                                               \
  }                                                                                                       \
                                                                                                          \
  static void add##TYPE(TYPE##Queue queue, TYPE value)                                                    \
  {                                                                                                       \
      ++queue->tl;                                                                                        \
      if (!queue->first || queue->tl >= QUEUE_SEGMENT_SIZE)                                               \
      {                                                                                                   \
          TYPE##QueueSegment segment = (TYPE##QueueSegment) ALLOCATE(queue->context, sizeof(struct _##TYPE##QueueSegment)); \
          if (!queue->first)                                                                              \
          {                                                                                               \
              queue->first = segment;                                                                     \
              queue->hd = 0;                                                                              \
          }                                                                                               \
          else                                                                                            \
          {                                                                                               \
              queue->last->next = segment;                                                                \
          }                                                                                               \
          queue->last = segment;                                                                          \
          queue->tl = 0;                                                                                  \
      }                                                                                                   \
      queue->last->entry[queue->tl] = value;                                                              \
  }                                                                                                       \
                                                                                                          \
  static TYPE *head##TYPE(TYPE##Queue queue)                                                              \
  {                                                                                                       \
      ASSERT(context, !queue->first);                                                                     \
      return queue->first->entry[queue->hd];                                                              \
  }                                                                                                       \
                                                                                                          \
  static void next##TYPE(TYPE##Queue queue)                                                               \
  {                                                                                                       \
      ASSERT(context, !queue->first);                                                                     \
      ++queue->hd;                                                                                        \
      if (queue->first == queue->last && queue->hd > queue->tl)                                           \
      {                                                                                                   \
          FREE(queue->context, queue->first);                                                             \
          q->first = q->last = NULL;                                                                      \
          q->hd = q->tl = -1;                                                                             \
      }                                                                                                   \
      else if (queue->first != queue->last && queue->hd >= QUEUE_SEGMENT_SIZE)                            \
      {                                                                                                   \
          TYPE##QueueSegment next = queue->first->next;                                                   \
          FREE(queue->context, queue->first);                                                             \
          queue->first = next;                                                                            \
          queue->hd = 0;                                                                                  \
      }                                                                                                   \
  }                                                                                                       \
                                                                                                          \
  static void free##TYPE##Queue(TYPE##Queue queue)                                                        \
  {                                                                                                       \
      TYPE##QueueSegment first = queue->first;                                                            \
      while (first)                                                                                       \
      {                                                                                                   \
          TYPE##QueueSegment next = first->next;                                                          \
          FREE(queue->context, first);                                                                    \
          first = next;                                                                                   \
      }                                                                                                   \
      FREE(queue->context, queue);                                                                        \
  }

#ifdef __cplusplus
}
#endif

#endif
///////////////////////////////////////////////////////////////////////////////////////////////////

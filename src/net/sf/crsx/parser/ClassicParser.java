/* ClassicParser.java */
/* Generated By:JavaCC: Do not edit this line. ClassicParser.java */
package net.sf.crsx.parser;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import net.sf.crsx.Builder;
import net.sf.crsx.CRS;
import net.sf.crsx.CRSException;
import net.sf.crsx.Constructor;
import net.sf.crsx.Factory;
import net.sf.crsx.Kind;
import net.sf.crsx.Maker;
import net.sf.crsx.Parser;
import net.sf.crsx.Sink;
import net.sf.crsx.Stub;
import net.sf.crsx.Term;
import net.sf.crsx.Variable;
import net.sf.crsx.generic.PropertiesWrapperConstructor;
import net.sf.crsx.util.Buffer;
import net.sf.crsx.util.ExtensibleMap;
import net.sf.crsx.util.LinkedExtensibleMap;
import net.sf.crsx.util.Pair;
import net.sf.crsx.util.PropertiesConstructor;
import net.sf.crsx.util.SinkContentHandler;
import net.sf.crsx.util.SmallSet;
import net.sf.crsx.util.Util;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

/**
 * JavaCC parser for populating {@link CRS} terms using a generic syntax.
 * The syntax is described in the "CRSX HOWTO" document.
 *
 * @author <a href="http://www.research.ibm.com/people/k/krisrose">Kristoffer Rose</a>.
 * @version $Id: ClassicParser.jj,v 3.6 2013/12/09 05:48:40 krisrose Exp $
 */
@SuppressWarnings("unused")
public class ClassicParser implements Parser, ClassicParserConstants {
        // State.

        /** Standard application (left recursive concatenation) constructor. */
        private Constructor applicationConstructor;

        /** Standard list (right recursive concatenation) constructor. */
        private Constructor sequenceCons;

        /** Standard list (right recursive concatenation) constructor. */
        private Constructor sequenceNil;

        /** Minimal null term inserted where nothing is given in a sequence. */
        private Stub sequenceNull;

        /** Patterns for infix operators. */
        private Map<String[], Constructor> infixPatterns = new HashMap<String[], Constructor>();

        /** Factory set for parser. */
        private Factory<? extends Term> factory;

        /** Compilation unit name... */
        private String unit;

        /** Whether this parser has been used. */
        private boolean used;

    /** Whether to ignore property duplicates */
    private boolean ignoreDuplicates;


        /** Whether location properties are added to constructors. */
        private boolean captureLocations;
        private Constructor makeConstructor(Sink sink, Token t, String s, String sort)
        {
                Constructor c = sort == null ? sink.makeConstructor(s) : sink.makeLiteral(s, sort);
                return locateConstructor(sink, t, c);
        }
        private Constructor locateConstructor(Sink sink, Token t, Constructor c)
        {
                if (captureLocations && t != null)
                {
            c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn); //endLine and endColumn not yet used
                }
                return c;
        }

        // Constructors.

        /**
	 * Create parser instance.
	 * The parser cannot read anything, in particular it has factory == null.
	 */
        public ClassicParser()
        {
                disable_tracing();
        }

        // Methods.

        /**
	 * Add a new infix pattern.
	 * @param pattern should contain a null value for each subterm and the string representation of
	 *   the symbol for each constructor that must be present
	 * @param constructor to actually use for such occurrences
	 */
        public void addInfix(String[] pattern, Constructor constructor)
        {
                infixPatterns.put(pattern, constructor);
        }

        /** Remove wrapping {{...}} or .... (double ASCII or single other unicode character from each end) */
        public String unembed(String s)
        {
                return s.charAt(0) <= '~' ? s.substring(2, s.length()-2) : s.substring(1, s.length()-1);
        }

        /** Remove wrapping #'...' or &lt;em&gt;...&lt;/em&gt; pairs. */
        private String unmeta(String s)
        {
                return s.startsWith("#'") ? unquote(s.substring(1)) : s.startsWith("#\u005c"") ? unquote(s.substring(1)) : s.startsWith("<em>") ? untag(s) : s;
        }

        /** Remove wrapping v'...' or &lt;var&gt;...&lt;/var&gt; pairs. */
        private String unvar(String s)
        {
                return s.startsWith("v'") ? unquote(s.substring(1)) : s.startsWith("v\u005c"") ? unquote(s.substring(1)) : s.startsWith("<var>") ? untag(s) : s;
        }

        /** Remove &lt;...&gt;...&lt;/...&gt;. */
        private String untag(String s)
        {
                return s.substring(s.indexOf(">")+1, s.lastIndexOf("</"));
        }

        /** Extract category=... attribute. */
        private String classify(String s)
        {
                int tagend = s.indexOf(">");
                int attbegin = s.indexOf(" category=\u005c"");
                if (attbegin < tagend)
                {
                        int catbegin = attbegin + 11;
                        int catend = s.indexOf("\u005c"", catbegin);
                        if (catbegin < catend)
                                return s.substring(catbegin, catend);
                }
                return null;
        }

        /** Remove "s from string. */
        private static String unquote(String s)
        {
                return Util.unquoteJava(s);
        }

        private boolean isLinear(String s)
        {
                return (s.contains("&sup1;") || s.contains("\u00b9"));
        }

        private String unLinear(String s)
        {
                if (isLinear(s))
                {
                        StringBuilder b = new StringBuilder();
                        for (int i = 0; i < s.length(); ++i)
                        {
                            if (s.startsWith("&sup1;", i))
                                i += 5; // skip
                                else if (s.charAt(i) != '\u00b9')
                                        b.append(s.charAt(i));
                        }
                        s = b.toString();
                }
                return s;
        }

    private boolean isBlocking(String s)
    {
        return s.contains("\u1d47");
    }

        private String unBlocking(String s)
        {
           return s.replaceAll("\u1d47", "");
        }

    private boolean isShallow(String s)
    {
        return s.contains("\u02e2");
    }

    private String unShallow(String s)
    {
       return s.replaceAll("\u02e2", "");
    }


        /** Create a parse error on the current token with a nicely formatted message. */
        ParseException oops(String summary, Token t, Throwable e)
        {
                return new ParseException(summary
                        + (t == null ? "" : ": " + shorten(t.toString()) + " at line " + t.beginLine + ", column " + t.beginColumn)
                        + (e == null ? "" : "\u005cn " + e.getMessage()));
        }

        /** Utility to dump at most 60 characters of string. */
        static String shorten(String text)
        {
                return (text.length() < 60 ? text : text.substring(0,60)+"...");
        }

        // Parser...

        public Parser parser(Factory<? extends Term> f)
        {
           factory = f;

       ignoreDuplicates = f.defined(Factory.IGNORE_DUPLICATE);

           return this;

        }

        private Sink realParse(Sink sink, String unit, ExtensibleMap<String, Variable> bound) throws CRSException, IOException
        {
                try
                {
                        // Setup
                        this.unit = unit;

                        applicationConstructor = sink.makeConstructor(CRS.APPLICATION_SYMBOL);
                        sequenceCons = sink.makeConstructor(CRS.CONS_SYMBOL);
                        sequenceNil = sink.makeConstructor(CRS.NIL_SYMBOL);

                        Constructor ruleConstructor = sink.makeConstructor(Builder.RULE_SYMBOL);
                        String[] ruleInfix1 = {null, "&rarr;", null};
                        addInfix(ruleInfix1, ruleConstructor);
                        String[] ruleInfix2 = {null, ":", null, "&rarr;", null};
                        addInfix(ruleInfix2, ruleConstructor);
                        String[] ruleInfix3 = {null, "\u2192", null};
                        addInfix(ruleInfix3, ruleConstructor);
                        String[] ruleInfix4 = {null, ":", null, "\u2192", null};
                        addInfix(ruleInfix4, ruleConstructor);

                        Constructor sortConstructor = sink.makeConstructor(Builder.DATA_SORT_SYMBOL);
                        String[] sortInfix1 = {null, "::=", null};
                        addInfix(sortInfix1, sortConstructor);
                        Constructor funSortConstructor = sink.makeConstructor(Builder.FUNCTION_SORT_SYMBOL);
                        String[] sortInfix2 = {null, "::", null};
                        addInfix(sortInfix2, funSortConstructor);

                        Buffer b = new Buffer(sink);
                        b.sink().start(sequenceNil).end();
                        sequenceNull = b.term(true);
                        if (bound == null) bound = new LinkedExtensibleMap<String, net.sf.crsx.Variable>();
                        return CompleteSequence(sink, bound);
                }
                catch (ParseException e)
                {
                        throw new CRSException(e);
                }
        }

        public Sink parse(Sink sink, String category, Reader reader, String unit, int line, int column, ExtensibleMap<String, Variable> bound) throws CRSException, IOException
        {
                assert factory != null && !used : "Parser must be instantiated with .parser() and only have one use of parse()!";
                if (category == null || category.length() == 0)
                {
                        ClassicParser realParser = new ClassicParser(new FixedSimpleCharStream(reader, line, column));
                        realParser.parser(factory);
                        realParser.setParserVerbose(trace_enabled);
                        return realParser.realParse(sink, unit, bound);
                }
                else if (category.equals(CRS.XML))
                {
                        try
                        {
                                SAXParserFactory parserFactory = SAXParserFactory.newInstance();
                                parserFactory.setFeature("http://xml.org/sax/features/namespaces", true);
                                parserFactory.setFeature("http://xml.org/sax/features/namespace-prefixes", true);
                                SAXParser parser = parserFactory.newSAXParser();
                                SinkContentHandler handler = new SinkContentHandler(sink, this, bound, null);
                                parser.parse(new InputSource(reader), handler);
                                return handler.getSink();
                        }
                        catch (ParserConfigurationException e)
                        {
                                throw new RuntimeException(e);
                        }
                        catch (SAXException e)
                        {
                                throw new RuntimeException(e);
                        }
                        catch (IOException e)
                        {
                                throw new RuntimeException(e);
                        }
                        finally
                        {
                                //inUse = false;
                        }
                }
                else
                {
                        throw new CRSException("Parser invocation error: does not support categories ("+category+")");
                }
        }

        public final Set<String> categories = new SmallSet<String>();
        { categories.add(""); categories.add(CRS.XML); }
        public Iterable<String> categories()
        {
                return categories;
        }

        public void setParserVerbose(boolean verbose)
        {
                if (verbose)
                        enable_tracing();
                else
                        disable_tracing();
        }

        public void setParserLocation(boolean capture)
        {
                captureLocations = capture;
        }

/**
 * Top-level that requires EOF afterwards.
 */
  final public Sink CompleteSequence(Sink sink, ExtensibleMap<String, Variable> bound) throws ParseException {
    trace_call("CompleteSequence");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case HASHBANG:{
        jj_consume_token(HASHBANG);
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      // permit executable scripts
              sink = Sequence(sink, bound);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CompleteSequence");
    }
  }

/**
 * Sequence  ::=  Application ( ";" [Application] )*  .
 */
  final public Sink Sequence(Sink sink, ExtensibleMap<String, Variable> bound) throws ParseException {
    trace_call("Sequence");
    try {Stub head, tail = null; // list ends
        List<Stub> list = new ArrayList<Stub>(1);
      head = BufferedApplication(sink, bound);
list.add(head);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SEMI:{
          ;
          break;
          }
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        jj_consume_token(SEMI);
tail=sequenceNull.copy(false, LinkedExtensibleMap.EMPTY_RENAMING);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:
        case LROUND:
        case LCURLY:
        case NOT:
        case CONSTRUCTOR:
        case VARIABLE:
        case METAVARIABLE:
        case QUOTED_VARIABLE:
        case QUOTED_METAVARIABLE:
        case PERCENT_NAME:
        case STRING:
        case ATOM:
        case NUMERIC:
        case EMBEDDED:{
          tail = BufferedApplication(sink, bound);
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          ;
        }
list.add(tail);
      }
// t is echoed as t
                // t1;...;tn;t, n>0, is echoed as $Cons[$t1, ...$Cons[$tn, t]...]
                final int lastIndex = list.size() - 1;
                for (int i = 0; i < lastIndex; ++i)
                        sink = sink.start(sequenceCons).copy(list.get(i), true);
                sink = sink.copy(list.get(lastIndex), true); // t or $Nil
                for (int i = 0; i < lastIndex; ++i)
                        sink = sink.end();
                {if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Sequence");
    }
  }

/** Materialized application. */
  final public Term BufferedApplication(Maker maker, ExtensibleMap<String, Variable> bound) throws ParseException {
    trace_call("BufferedApplication");
    try {Buffer buffer = new Buffer(maker);
        Sink sink = buffer.sink();
      sink = Application(sink, bound, true, null);
{if ("" != null) return buffer.term(true);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BufferedApplication");
    }
  }

/**
 * Application	::=  (Simple)+	|  C (v (":" Simple)?)* "." Application
 * BApplication	 ::=  (v)+ "." Application  |  Application  .  // when allowBinders
 */
  final public Sink Application(Sink sink, ExtensibleMap<String, Variable> bound, boolean allowBinders, Map<Variable,Term> contextVariableMap) throws ParseException {
    trace_call("Application");
    try {Token t;
        Term head, tail;
        List<Term> list = new ArrayList<Term>(1);
        int starts = 0;
        Map<Variable,Term> variableMap = null;
if (contextVariableMap != null && !contextVariableMap.isEmpty())
                {
                        sink = PropertiesWrapperConstructor.start(sink, null, null, contextVariableMap, null);
                        ++starts;
                }
      head = BufferedSimple(sink, bound);
list.add(head);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:
        case LROUND:
        case LCURLY:
        case NOT:
        case CONSTRUCTOR:
        case VARIABLE:
        case METAVARIABLE:
        case QUOTED_VARIABLE:
        case QUOTED_METAVARIABLE:
        case PERCENT_NAME:
        case STRING:
        case ATOM:
        case NUMERIC:
        case EMBEDDED:{
          ;
          break;
          }
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        tail = BufferedSimple(sink, bound);
list.add(tail);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        // Concatenation is lambda-style abstraction.
                        t = jj_consume_token(DOT);
if (head.kind() == Kind.CONSTRUCTION && head.arity() == 0)
                        {
                                // Composite form: "C v1...vn . t" = C[[v1] ... C[[vn]t]...].
                                Constructor constructor = head.constructor();
                                Variable lastVariableWithProperty = null;
                                Term lastVariableProperty = null;
                                // Get the variables...but make new ones to ensure unicity!
                                for (int i = 1; i < list.size(); ++i)
                                {
                                        Term term = list.get(i);
                                        if (term.kind() != Kind.VARIABLE_USE)
                                                {if (true) throw oops("CRS error: dot abstraction must only have variables (with optional inner property) between constructor and dot", t, null);}
                                        Variable tv = term.variable();
                                        Variable v = sink.makeVariable(tv.name(), tv.promiscuous(), tv.blocking(), tv.shallow()); // vi
                                        Variable[] bs = {v};
                                        Constructor c = constructor;
                                        if (lastVariableWithProperty != null)
                                        {
                                                c = Util.wrapWithProperty(sink, c, lastVariableWithProperty, lastVariableProperty);
                                                lastVariableWithProperty = null;
                                        }
                                        sink = sink.start(captureLocations ? Util.copyLocation(sink, c, term.constructor()) : c).binds(bs); // emit C[vi.
                                        ++starts;
                                        bound = bound.extend(v.name(), v);
                                        if (i+2 < list.size() && (":".equals(Util.symbol(list.get(i+1))) || "::".equals(Util.symbol(list.get(i+1))))) // got : type
                                        {
                                                lastVariableWithProperty = v;
                                                lastVariableProperty = list.get(i += 2);
                                        }
                                }
                                if (lastVariableWithProperty != null) // last variable property bleeds to contained term
                                {
                                        variableMap = new HashMap<Variable,Term>();
                                        variableMap.put(lastVariableWithProperty, lastVariableProperty);
                                }
                        }
                        else if (allowBinders && head.kind() == Kind.VARIABLE_USE)
                        {
                                // Optional composite form: subterm with binders "v1:t1...vn:tn . t" = [v1,...,vn]t.
                                List<Variable> bs = new ArrayList<Variable>();
                                Variable lastVariable = null;
                                boolean afterColon = false;
                                for (int i = 0; i < list.size(); ++i)
                                {
                                        Term term = list.get(i);
                                        if (term.kind() != Kind.VARIABLE_USE)
                                                {if (true) throw oops("CRS error: binders for argument must only have variables (with optional inner property) before dot", t, null);}
                                        Variable tv = term.variable();
                                        Variable v = sink.makeVariable(tv.name(), tv.promiscuous(), tv.blocking(), tv.shallow()); // vi
                                        bs.add(v);
                                        bound = bound.extend(v.name(), v);
                                        if (i+2 < list.size() && (":".equals(Util.symbol(list.get(i+1))) || "::".equals(Util.symbol(list.get(i+1))))) // got : type
                                        {
                                                if (variableMap == null)
                                                         variableMap = new HashMap<Variable,Term>();
                                                variableMap.put(v, list.get(i += 2));
                                        }
                                }
                                sink = sink.binds(bs.toArray(new Variable[bs.size()]));
                        }
                        else
                                {if (true) throw oops("CRS error: Dot abstraction must start with simple constructor", t, null);}
        sink = Application(sink, bound, false, variableMap);
while (starts-- > 0)
                                sink = sink.end(); // emit ] after start events
                        {if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        ;
      }
// Check for special infix form...
            if (list.size() > 1)
            {
                        Entries : for (Map.Entry<String[], Constructor> e : infixPatterns.entrySet())
                        {
                                String[] ss = e.getKey();
                                Constructor first = null;
                                if (list.size() != ss.length)
                                        continue Entries; // length mismatch
                                for (int i = 0; i < ss.length; ++i)
                                {
                                        if (ss[i] != null)
                                        {
                                                Term term = list.get(i);
                                                if (term.kind() != Kind.CONSTRUCTION || term.arity() != 0 || !ss[i].equals(term.constructor().symbol()))
                                                        continue Entries; // operator mismatch
                                                if (first == null)
                                                        first = term.constructor();
                                        }
                                }
                                // Match!
                                Constructor c = e.getValue();
                                if (captureLocations)
                                        c = Util.copyLocation(sink, c, first);
                                sink = sink.start(c);
                                ++starts;
                                for (int i = 0; i < ss.length; ++i)
                                {
                                        if (ss[i] == null)
                                        {
                                                Term term = list.get(i);
                                                sink = sink.copy(term, false);
                                        }
                                }
                                while (starts-- > 0)
                                        sink = sink.end(); // emit ] after start events
                                {if ("" != null) return sink;}
                        }
            }

                // Fall back to basic applicative form "f a1...an" = @[...@[f, a1],...,an].
                for (int i = 1; i < list.size(); ++i)
                        sink = sink.start(applicationConstructor); // emit @[
                boolean argument = false;
                for (Term term : list)
                {
                        sink = sink.copy(term, true); // emit f or ai
                        if (argument)
                                sink = sink.end(); // emit ] after ai
                        else
                                argument = true;
                }
                while (starts-- > 0)
                        sink = sink.end(); // emit ] after start events
                {if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Application");
    }
  }

/** Materialized simple CRS term. */
  final public Term BufferedSimple(Maker maker, ExtensibleMap<String, Variable> bound) throws ParseException {
    trace_call("BufferedSimple");
    try {Buffer buffer = new Buffer(maker);
        Sink sink = buffer.sink();
      Simple(sink, bound, new HashMap<String, Term>(), new HashMap<Variable, Term>(), new HashMap<String,Term>(), new HashSet<String>());
{if ("" != null) return buffer.term(true);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BufferedSimple");
    }
  }

/**
 * Simple  ::=	"(" Sequence? ")"  |  v[Â¹]  |	[PropPrefix] C ["[" BindingList "]"]  |	 [PropPrefix] # ["[" List "]"]	|  "{{"..."}}"	|  "%" C "{{"..."}}"
 * PropPrefix  ::=  "{" [# ";"] [PropertyList] "}" 
 */
  final public Sink Simple(Sink sink, ExtensibleMap<String, Variable> bound, Map<String, Term> properties, Map<Variable, Term> varProperties, HashMap<String,Term> metaProperties, Set<String> refs) throws ParseException {
    trace_call("Simple");
    try {Token t; String sort = null, s, category; int embeddedOffset = 0;
        boolean wrap = false, linear = false, blocking = false, shallow = false;
        if (properties != null) for (Map.Entry<String, Term> e : properties.entrySet()) if (e.getValue() == null) wrap = true;
        if (varProperties != null) for (Map.Entry<Variable, Term> e : varProperties.entrySet()) if (e.getValue() == null) wrap = true;
        if (metaProperties != null && !metaProperties.isEmpty()) wrap = true;
        if (!refs.isEmpty()) wrap = true;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LROUND:{
        jj_consume_token(LROUND);
// Deal with property context...
                if (wrap || properties.size() > 0 || varProperties.size() > 0 || metaProperties.size() > 0)
                {
                        String ref = refs.isEmpty() ? null : refs.iterator().next();
                        sink = PropertiesWrapperConstructor.start(sink, ref, properties, varProperties, metaProperties);
                }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:
        case LROUND:
        case LCURLY:
        case NOT:
        case CONSTRUCTOR:
        case VARIABLE:
        case METAVARIABLE:
        case QUOTED_VARIABLE:
        case QUOTED_METAVARIABLE:
        case PERCENT_NAME:
        case STRING:
        case ATOM:
        case NUMERIC:
        case EMBEDDED:{
          // (t;...;t).
                          sink = Sequence(sink, bound);
          jj_consume_token(RROUND);
          break;
          }
        case RROUND:{
sink = sink.copy(sequenceNull, false);
          jj_consume_token(RROUND);
          break;
          }
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return wrap ? sink.end() : sink;}
        break;
        }
      case COLON:
      case NOT:
      case CONSTRUCTOR:
      case STRING:
      case ATOM:
      case NUMERIC:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CONSTRUCTOR:{
          t = jj_consume_token(CONSTRUCTOR);
s = t.toString();
          break;
          }
        case ATOM:{
          t = jj_consume_token(ATOM);
s = unquote(t.toString());
          break;
          }
        case NUMERIC:{
          t = jj_consume_token(NUMERIC);
s = t.toString(); sort = "$Numeric";
          break;
          }
        case STRING:{
          t = jj_consume_token(STRING);
s = unquote(t.toString()); sort = "$String";
          break;
          }
        case COLON:{
          t = jj_consume_token(COLON);
s = t.toString();
          break;
          }
        case NOT:{
          t = jj_consume_token(NOT);
s = t.toString();
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
// Deal with property context...
                if (wrap)
                {
                        // Meta-properties...we need fully general pattern/contraction wrapper.
                        String ref = (refs.isEmpty() ? null : refs.iterator().next());
                        sink = PropertiesWrapperConstructor.start(sink, ref, properties, varProperties, metaProperties);
                        sink=sink.start(makeConstructor(sink, t, s, sort));
                }
                else
                {
                        // At most simple key=value properties so use property-extended constructor.
                try
                        {
                                sink=sink.start(Util.wrapWithProperties(sink, makeConstructor(sink, t, s, sort), properties, varProperties));
                        }
                        catch (CRSException e)
                        {
                                {if (true) throw oops("CRS Error", t, e);}
                        }
                }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LSQUARE:{
          jj_consume_token(LSQUARE);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COLON:
          case LROUND:
          case LCURLY:
          case NOT:
          case CONSTRUCTOR:
          case VARIABLE:
          case METAVARIABLE:
          case QUOTED_VARIABLE:
          case QUOTED_METAVARIABLE:
          case PERCENT_NAME:
          case STRING:
          case ATOM:
          case NUMERIC:
          case EMBEDDED:{
            sink = List(sink, bound, true);
            break;
            }
          default:
            jj_la1[7] = jj_gen;
            ;
          }
          jj_consume_token(RSQUARE);
          break;
          }
        default:
          jj_la1[8] = jj_gen;
          ;
        }
sink = sink.end();
                {if ("" != null) return wrap ? sink.end() : sink;}
        break;
        }
      case VARIABLE:
      case QUOTED_VARIABLE:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case VARIABLE:{
          t = jj_consume_token(VARIABLE);
s=t.toString(); shallow = isShallow(s); s = unShallow(s); blocking = isBlocking(s); s = unBlocking(s); linear = isLinear(s); s = unLinear(s);
          break;
          }
        case QUOTED_VARIABLE:{
          t = jj_consume_token(QUOTED_VARIABLE);
s=unvar(t.toString());  shallow = isShallow(s); s = unShallow(s);  blocking = isBlocking(s); s = unBlocking(s); linear = isLinear(s); s = unLinear(s);
          break;
          }
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{
                if (!refs.isEmpty() || properties.size() > 0 || varProperties.size() > 0 || metaProperties.size() > 0)
                {
                        String ref = (refs.isEmpty() ? null : refs.iterator().next());
                        sink = PropertiesWrapperConstructor.start(sink, ref, properties, varProperties, metaProperties);
                        wrap = true;
                }
                Variable v = bound.get(s);
                if (v == null) v = factory.freeVariable(s, !linear, blocking, shallow, true);
                sink = sink.use(v);
                {if ("" != null) return wrap ? sink.end() : sink;}
        }
        break;
        }
      case METAVARIABLE:
      case QUOTED_METAVARIABLE:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case METAVARIABLE:{
          t = jj_consume_token(METAVARIABLE);
s=t.toString();
          break;
          }
        case QUOTED_METAVARIABLE:{
          t = jj_consume_token(QUOTED_METAVARIABLE);
s=unmeta(t.toString());
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
if (!refs.isEmpty() || properties.size() > 0 || varProperties.size() > 0 || metaProperties.size() > 0)
                {{
                        String ref = (refs.isEmpty() ? null : refs.iterator().next());
                        sink = PropertiesWrapperConstructor.start(sink, ref, properties, varProperties, metaProperties);
                        wrap = true;
                }}
                sink = sink.startMetaApplication(s);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LSQUARE:{
          jj_consume_token(LSQUARE);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COLON:
          case LROUND:
          case LCURLY:
          case NOT:
          case CONSTRUCTOR:
          case VARIABLE:
          case METAVARIABLE:
          case QUOTED_VARIABLE:
          case QUOTED_METAVARIABLE:
          case PERCENT_NAME:
          case STRING:
          case ATOM:
          case NUMERIC:
          case EMBEDDED:{
            sink = List(sink, bound, false);
            break;
            }
          default:
            jj_la1[11] = jj_gen;
            ;
          }
          jj_consume_token(RSQUARE);
          break;
          }
        default:
          jj_la1[12] = jj_gen;
          ;
        }
sink = sink.endMetaApplication();
                {if ("" != null) return wrap ? sink.end() : sink;}
        break;
        }
      case PERCENT_NAME:
      case EMBEDDED:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EMBEDDED:{
category = null;
          t = Embedded();
s = unembed(t.toString()); embeddedOffset = 1;
          break;
          }
        case PERCENT_NAME:{
          // %category{{text}}.
                          t = jj_consume_token(PERCENT_NAME);
category = t.toString().substring(1).trim();
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case EMBEDDED:{
            t = Embedded();
s = unembed(t.toString()); embeddedOffset = 1;
            break;
            }
          case STRING:{
            t = jj_consume_token(STRING);
s = unquote(t.toString()); embeddedOffset = 1;
            break;
            }
          default:
            jj_la1[13] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
if (!refs.isEmpty() || properties.size() > 0 || varProperties.size() > 0 || metaProperties.size() > 0)
                {
                        String ref = (refs.isEmpty() ? null : refs.iterator().next());
                        sink = PropertiesWrapperConstructor.start(sink, ref, properties, varProperties, metaProperties);
                        wrap = true;
                }
                try
                {
                        StringReader reader = new StringReader(new String(s.toCharArray())); // real clone!!
                        sink = factory.parse(sink, category, reader, unit, t.beginLine, t.beginColumn + embeddedOffset, bound);
                }
                catch (CRSException e)
                {
                        Throwable cause = e.getCause();
                        if (cause instanceof ParseException)
                        {
                                // Recast parse error.
                                {if (true) throw (ParseException) cause;}
                        }
                        {if (true) throw oops((unit==null?"":unit + ": ")+"Parse error in embedded "+(category==null?"":category+" ")+"term at line "+t.beginLine+", column "+t.beginColumn, t, e);}
                }
                catch (IOException e)
                {
                        {if (true) throw oops((unit==null?"":unit + ": ")+"Read error for embedded "+category+" term", t, e);}
                }
                catch (TokenMgrError e)
                {
                        {if (true) throw oops((unit==null?"":unit + ": ")+"Read error for embedded "+category+" term", t, e);}
                }
                {if ("" != null) return wrap ? sink.end() : sink;}
        break;
        }
      case LCURLY:{
        jj_consume_token(LCURLY);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NOT:
        case CONSTRUCTOR:
        case VARIABLE:
        case METAVARIABLE:
        case QUOTED_VARIABLE:
        case QUOTED_METAVARIABLE:
        case PERCENT_NAME:
        case STRING:
        case ATOM:
        case NUMERIC:{
          Property(sink, bound, properties, varProperties, metaProperties, refs);
          break;
          }
        default:
          jj_la1[15] = jj_gen;
          ;
        }
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case SEMI:{
            ;
            break;
            }
          default:
            jj_la1[16] = jj_gen;
            break label_3;
          }
          jj_consume_token(SEMI);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case NOT:
          case CONSTRUCTOR:
          case VARIABLE:
          case METAVARIABLE:
          case QUOTED_VARIABLE:
          case QUOTED_METAVARIABLE:
          case PERCENT_NAME:
          case STRING:
          case ATOM:
          case NUMERIC:{
            Property(sink, bound, properties, varProperties, metaProperties, refs);
            break;
            }
          default:
            jj_la1[17] = jj_gen;
            ;
          }
        }
        jj_consume_token(RCURLY);
        sink = Simple(sink, bound, properties, varProperties, metaProperties, refs);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Simple");
    }
  }

/**
 * List	 ::=  Application ( "," Application )*
 * BList  ::=  BApplication ( "," BApplication )*
 */
  final public Sink List(Sink sink, ExtensibleMap<String, Variable> bound, boolean allowBinders) throws ParseException {
    trace_call("List");
    try {
      // t,...,t.
              sink = Application(sink,bound, allowBinders, null);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[19] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        sink = Application(sink, bound, allowBinders, null);
      }
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("List");
    }
  }

/**
 * Property  ::=  ¬C  |	 C  |	C ":" Simple  |	 v  |  Â¬v  |  v ":" Simple | # | Â¬# | #name ":" Simple.
 */
  final public void Property(Maker maker, ExtensibleMap<String, Variable> bound, Map<String, Term> properties, Map<Variable, Term> varProperties, HashMap<String,Term> metaProperties, Set<String> refs) throws ParseException {
    trace_call("Property");
    try {Token t;
        Term term = null;
        boolean linear, blocking, shallow = false;
        String p, s, category;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NOT:{
        jj_consume_token(NOT);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CONSTRUCTOR:
        case STRING:
        case ATOM:
        case NUMERIC:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case CONSTRUCTOR:{
            t = jj_consume_token(CONSTRUCTOR);
p = t.toString();
            break;
            }
          case ATOM:{
            t = jj_consume_token(ATOM);
p = unquote(t.toString());
            break;
            }
          case NUMERIC:{
            t = jj_consume_token(NUMERIC);
p = t.toString();
            break;
            }
          case STRING:{
            t = jj_consume_token(STRING);
p = unquote(t.toString());
            break;
            }
          default:
            jj_la1[20] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
if (!ignoreDuplicates || !properties.containsKey(p))
                           properties.put(p, null);
          break;
          }
        case VARIABLE:
        case QUOTED_VARIABLE:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case VARIABLE:{
            t = jj_consume_token(VARIABLE);
s=t.toString(); shallow = isShallow(s); s = unShallow(s); blocking = isBlocking(s); s = unBlocking(s); linear = isLinear(s); s = unLinear(s);
            break;
            }
          case QUOTED_VARIABLE:{
            t = jj_consume_token(QUOTED_VARIABLE);
s=unvar(t.toString());  shallow = isShallow(s); s = unShallow(s);  blocking = isBlocking(s); s = unBlocking(s); linear = isLinear(s); s = unLinear(s);
            break;
            }
          default:
            jj_la1[21] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
{
                        Variable v = bound.get(s);
                        if (v == null) v = factory.freeVariable(s, !linear, blocking, shallow, true);
                        if (!ignoreDuplicates || !varProperties.containsKey(v))
                            varProperties.put(v, null);
                }
          break;
          }
        case METAVARIABLE:
        case QUOTED_METAVARIABLE:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case METAVARIABLE:{
            t = jj_consume_token(METAVARIABLE);
s=t.toString();
            break;
            }
          case QUOTED_METAVARIABLE:{
            t = jj_consume_token(QUOTED_METAVARIABLE);
s=unmeta(t.toString());
            break;
            }
          default:
            jj_la1[22] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
metaProperties.put(s, null);
          break;
          }
        case PERCENT_NAME:{
          // ¬ %category{{text}}
                          t = jj_consume_token(PERCENT_NAME);
category = t.toString().substring(1).trim();
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case EMBEDDED:{
            t = Embedded();
s = unembed(t.toString());
            break;
            }
          case STRING:{
            t = jj_consume_token(STRING);
s = unquote(t.toString());
            break;
            }
          default:
            jj_la1[23] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
try
                        {
                                StringReader reader = new StringReader(new String(s.toCharArray())); // real clone!!
                                Term key = factory.parse(reader, category, unit, t.beginLine, t.beginColumn + 1, bound);
                                switch (key.kind())
                                {
                                case VARIABLE_USE : varProperties.put(key.variable(), null); break;
                                case CONSTRUCTION : properties.put(Util.symbol(key), null); break;
                                case META_APPLICATION : metaProperties.put(key.metaVariable(), null); break;
                                }
                        }
                        catch (CRSException e)
                        {
                                Throwable cause = e.getCause();
                                if (cause instanceof ParseException)
                                {
                                        // Recast parse error.
                                        {if (true) throw (ParseException) cause;}
                                }
                                {if (true) throw oops((unit==null?"":unit + ": ")+"Parse error in embedded "+(category==null?"":category+" ")+"term at line "+t.beginLine+", column "+t.beginColumn, t, e);}
                        }
                        catch (TokenMgrError e)
                        {
                                {if (true) throw oops((unit==null?"":unit + ": ")+"Read error for embedded "+category+" term", t, e);}
                        }
          break;
          }
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      case CONSTRUCTOR:
      case STRING:
      case ATOM:
      case NUMERIC:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CONSTRUCTOR:{
          t = jj_consume_token(CONSTRUCTOR);
p = t.toString();
          break;
          }
        case ATOM:{
          t = jj_consume_token(ATOM);
p = unquote(t.toString());
          break;
          }
        case NUMERIC:{
          t = jj_consume_token(NUMERIC);
p = t.toString();
          break;
          }
        case STRING:{
          t = jj_consume_token(STRING);
p = unquote(t.toString());
          break;
          }
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:{
          jj_consume_token(COLON);
          term = BufferedSimple(maker, bound);
          break;
          }
        default:
          jj_la1[26] = jj_gen;
          ;
        }
if (!ignoreDuplicates || !properties.containsKey(p))
                  properties.put(p, term != null ? term : sequenceNull.copy(false, LinkedExtensibleMap.EMPTY_RENAMING));
        break;
        }
      case VARIABLE:
      case QUOTED_VARIABLE:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case VARIABLE:{
          t = jj_consume_token(VARIABLE);
s=t.toString();  shallow = isShallow(s); s = unShallow(s); blocking = isBlocking(s); s = unBlocking(s); linear = isLinear(s); s = unLinear(s);
          break;
          }
        case QUOTED_VARIABLE:{
          t = jj_consume_token(QUOTED_VARIABLE);
s=unvar(t.toString());  shallow = isShallow(s); s = unShallow(s); blocking = isBlocking(s); s = unBlocking(s);  linear = isLinear(s); s = unLinear(s);
          break;
          }
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:{
          jj_consume_token(COLON);
          term = BufferedSimple(maker, bound);
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          ;
        }
{
                Variable v = bound.get(s);
                if (v == null) v = factory.freeVariable(s, !linear, blocking, shallow, true);
                if (!ignoreDuplicates || !varProperties.containsKey(v))
                  varProperties.put(v, term != null ? term : sequenceNull.copy(false, LinkedExtensibleMap.EMPTY_RENAMING));
        }
        break;
        }
      case PERCENT_NAME:{
        // %category{{text}} : t
                t = jj_consume_token(PERCENT_NAME);
category = t.toString().substring(1).trim();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EMBEDDED:{
          t = Embedded();
s = unembed(t.toString());
          break;
          }
        case STRING:{
          t = jj_consume_token(STRING);
s = unquote(t.toString());
          break;
          }
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:{
          jj_consume_token(COLON);
          term = BufferedSimple(maker, bound);
          break;
          }
        default:
          jj_la1[30] = jj_gen;
          ;
        }
try
                {
                        StringReader reader = new StringReader(new String(s.toCharArray())); // real clone!!
                        Term key = factory.parse(reader, category, unit, t.beginLine, t.beginColumn + 1, bound);
                        switch (key.kind())
                        {
                        case VARIABLE_USE : varProperties.put(key.variable(), term != null ? term : sequenceNull.copy(false, LinkedExtensibleMap.EMPTY_RENAMING)); break;
                        case CONSTRUCTION : properties.put(Util.symbol(key), term != null ? term : sequenceNull.copy(false, LinkedExtensibleMap.EMPTY_RENAMING)); break;
                        case META_APPLICATION : metaProperties.put(key.metaVariable(), term != null ? term : sequenceNull.copy(false, LinkedExtensibleMap.EMPTY_RENAMING)); break;
                        }
                }
                catch (CRSException e)
                {
                        Throwable cause = e.getCause();
                        if (cause instanceof ParseException)
                        {
                                // Recast parse error.
                                {if (true) throw (ParseException) cause;}
                        }
                        {if (true) throw oops((unit==null?"":unit + ": ")+"Parse error in embedded "+(category==null?"":category+" ")+"term at line "+t.beginLine+", column "+t.beginColumn, t, e);}
                }
                catch (TokenMgrError e)
                {
                        {if (true) throw oops((unit==null?"":unit + ": ")+"Read error for embedded "+category+" term", t, e);}
                }
        break;
        }
      case METAVARIABLE:
      case QUOTED_METAVARIABLE:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case METAVARIABLE:{
          t = jj_consume_token(METAVARIABLE);
s=t.toString();
          break;
          }
        case QUOTED_METAVARIABLE:{
          t = jj_consume_token(QUOTED_METAVARIABLE);
s=unmeta(t.toString());
          break;
          }
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COLON:{
          jj_consume_token(COLON);
          term = BufferedSimple(maker, bound);
metaProperties.put(s, term);
          break;
          }
        default:
          jj_la1[32] = jj_gen;
if (!refs.isEmpty())
                                {if (true) throw oops("CRS error: Cannot have two property collector meta-mariables in property pattern", t, null);}
                        refs.add(s);
        }
        break;
        }
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Property");
    }
  }

// EMBEDDED STRINGS
  final public 
Token Embedded() throws ParseException {
    trace_call("Embedded");
    try {Token t;
      t = jj_consume_token(EMBEDDED);
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Embedded");
    }
  }

  /** Generated Token Manager. */
  public ClassicParserTokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[34];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1000,0x10000,0xc78a4000,0xc78a4000,0x2000,0xc78e4000,0x1804000,0xc78a4000,0x200000,0x42000000,0x84000000,0xc78a4000,0x200000,0x0,0x0,0xc7800000,0x10000,0xc7800000,0xc78a4000,0x8000,0x1000000,0x42000000,0x84000000,0x0,0xc7000000,0x1000000,0x4000,0x42000000,0x4000,0x0,0x4000,0x84000000,0x4000,0xc7800000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x23c00,0x23c00,0x0,0x23c00,0x3800,0x23c00,0x0,0x0,0x0,0x23c00,0x0,0x20800,0x20400,0x3c00,0x0,0x3c00,0x23c00,0x0,0x3800,0x0,0x0,0x20800,0x3c00,0x3800,0x0,0x0,0x0,0x20800,0x0,0x0,0x0,0x3c00,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with user supplied CharStream. */
  public ClassicParser(CharStream stream) {
    token_source = new ClassicParserTokenManager(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public ClassicParser(ClassicParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ClassicParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[70];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 34; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 70; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}
